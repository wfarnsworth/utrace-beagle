#!/bin/bash

# "configme" script.

#  Copyright (c) 2009-2010 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

# Wrapper script to use existing tools to translate kernel
# config fragments into the pre-processed assembly of frags,
# and then finally a .config, and optionally an audit of that
# final .config

# Assumes you have a "default_kernel" clone, non-bare, with
# all BSPs/branches as local refs (i.e. not origin/*), i.e.
# 	git clone --bare git://myserver/default_kernel linux-2.6
# 	cd linux-2.6
#	mkdir .git ; mv * .git
#	git config core.bare false
#	git checkout -f wrs_meta
# Also assumes that current dir is in this linux git repo.

# Return values: zero if a ".config" was created, one otherwise.

CURRENT=`git branch |grep \*|sed 's/^\* //'`
if [ -d `pwd`/wrs/scripts ]; then
	SCRIPT_DIR=`pwd`/wrs/scripts
else
    	SCRIPT_DIR=`pwd`/meta/scripts
fi
PATH=$PATH:$SCRIPT_DIR
QUICK=1
META_DIR=meta

usage()
{
	echo "`basename $0` \[--audit\] \[--reconfig\] \[--o <outdir>] [target] [machine]"
	echo "   audit: do an audit of final .config file"
	echo "   reconfig: reconfigure an existing build"
	echo "   target: name of the configuration target (branch)"
	echo "   machine: specified if multiple machines use target"
	echo "   outdir: name of the output directory"
	exit 1
}


get_branch_name()
{
    _meta_series=$1

    branchpoints=`cat $_meta_series|grep '_branch_begin\|_force_branch'|awk '{print $3"|"$4}'`
    if [ -z "$branchpoints" ]; then
	branchpoints=master
    fi

old_ifs=$IFS
IFS='
'
    for i in $branchpoints ; do
	name=`echo  $i | cut -d'|' -f1`
	force=`echo $i | cut -d'|' -f2`

        # pickup the first forced branch, we'll throw the rest away as
	# "branches". Meaning they won't have been created as branches
	# unless multi_branch_divergence was specified
  	if [ -z "$branchname" ]; then
	    branchname=$name
	else
	    if [  "$META_DIR" == "meta" ]; then
		branchname="$branchname/$name"
	    else
		branchname=$name
	    fi
	fi
    done

    echo $branchname
}

# This is factored out into a function because for a given branch,
# there may be more than one user (i.e. big endian, little endian,
# or BSPs that use the same branch but differ only in kernel configs)
# So for each branch, we loop over all "users" (i.e. scc leaf'ers).
run_board_config()
{
    # Can't set these until we've unwound the checkpoint and have wrs data.
    KVER=`cat ./$META_DIR/cfg/kernel-*cache/kver|sed 's/^v//'`

    # Look for standard defines, with compatibility fallbacks
    KARCH=`grep KARCH $SCC | awk '{print $3}'`
    if [ -z "$KARCH" ]; then
	KARCH=`grep WRS_ARCH $SCC | awk '{print $3}'`
    fi
    KPROFILE=`grep KMACHINE $SCC | awk '{print $3}'`
    if [ -z "$KPROFILE" ]; then
	KPROFILE=`grep WRS_BOARD $SCC | awk '{print $3}'`
    fi
    KTYPE=`grep KTYPE $SCC | awk '{print $3}'`
    if [ -z "$KTYPE" ]; then
	KTYPE=`grep WRS_KERNEL $SCC | awk '{print $3}'`
    fi
    # KTGT=$KPROFILE-$KTYPE
    KTGT=$full_tgt
    META=./$META_DIR/cfg/meta/`basename $SCC .scc`-meta
    META_ALT=./$META_DIR/cfg/meta/$KTGT-meta
    META_ALT_ALT=./$META_DIR/cfg/meta/$KTGT-meta
    
    # Build system uses linux_BUILD=$(linux_SRC)-$(ktgt)-build
    # with ktgt=$(kprofile)-$(ktype)
    # and KERNEL_CONFIG=${kprofile}-${ktype}-config-${LINUX_KERNEL_VERSION}
    BUILD_DIR=$out_dir
    CFGFILE=$KTGT-config-$KVER

    if [ "x$KARCH" == "x" ] ; then
	echo Couldnt determine architecture from file:
	echo -e \\t$SCC
	echo Assuming scc is not a valid BSP endpoint...
	return 1
    fi

    # Fixups to match KARCH onto kernel.org arch
    if [ $KARCH == "powerpc_64" ]; then
	KARCH=powerpc
    fi
    if [ $KARCH == "mips64" ]; then
	KARCH=mips
    fi

    if [ -z "$reconfig" ] && [ -d $BUILD_DIR ]; then
	echo Dir $BUILD_DIR already exists, remove/move
	echo it if you want to re-run this configuration utility.
	return 1
    fi

    if [ ! -d $BUILD_DIR ]; then
	mkdir $BUILD_DIR
	if [ $? != 0 ]; then
	    echo Failed to mkdir $BUILD_DIR for final .config file
	    return 1
	fi
    fi

    mkdir -p ./$META_DIR/cfg/$KTGT
    if [ $? != 0 ]; then
	echo Failed to mkdir ./$META_DIR/cfg/$KTGT for config data
	return 1
    fi

    if [ ! -f $META ]; then
	if [ ! -f $META_ALT ]; then
		echo Failed to find meta series $META or $META_ALT
		return 1
	else
		META=$META_ALT
	fi
    fi

    kgit-meta -v -k $META
    if [ $? != 0 ]; then
	echo Error running the meta series for collecting config data
	return 1
    fi

    KTGT=`get_branch_name $META`
    generate_cfg $CFGFILE /dev/null `pwd` $BUILD_DIR $KTGT

    if [ $? != 0 ]; then
	echo creation of pre-processed config data failed
	return 1
    fi

    echo "[INFO] Pre-processed cfg file $CFGFILE created."

    make ARCH=$KARCH O=$BUILD_DIR \
	KBUILD_DEFCONFIG=../../../$META_DIR/cfg/$KTGT/$CFGFILE \
	defconfig > $META_DIR/cfg/$KTGT/config.log 2>&1

    if [ $? != 0 ]; then
	echo Kernel LKC processing of raw config data failed \($KARCH\)
	echo See $META_DIR/cfg/$KTGT/config.log for details.
	return 1
    fi

    echo "[INFO] processing of raw cfg data completed."

    if [ $QUICK -ne 1 ]; then
	kconf_check $CFGFILE /dev/null `pwd` $BUILD_DIR $KTGT
    fi

cat << EOF

********************************************************************************
  Configuration stored in $BUILD_DIR/.config
********************************************************************************

  To build with this kernel configuration, ensure a suitable toolchain
  is in your path for $KARCH, note its common command prefix, and do:

   make O=$BUILD_DIR ARCH=$KARCH \\
        CROSS_COMPILE=<cross-compile-prefix>

  Prefix is usually "<arch>-wrs-linux-gnu-", i.e. powerpc-wrs-linux-gnu-
  as an ARCH=powerpc specific example.

EOF
    return 0
}

#########################  Start here ##########################

if [ -z "$1" ]; then
	usage
	exit
fi

while [ $# -gt 0 ]; do
	case "$1" in
	    --help) 
		usage
		exit
		;;
	    --audit)
		QUICK=0
		;;
	    --reconfig)
		reconfig=t
		;;
	    --output|-o|--o)
		out_dir=$2
		shift
		;;
	    -v) verbose=t
		;;
	    *) break
		;;
	esac
	shift
done

# an explicit target to configure may have been passed 
# (whatever is left over). If something wasn't passed, we configure
# based on the current branch.
target=$1
machine=$2
if [ -z "$target" ]; then
    target=$CURRENT
fi
echo "[INFO] Finding user(s) of branch \"$target\""

# we need to condition the branch. If it is in the form that
# uses / for inheritance, special processing needs to be done.
echo $target | grep -q "/"
if [ $? -eq 0 ]; then
    # remove trailing "/base" that won't be in the .scc files
    # themselves
    tgt=`echo $target | sed 's%/base$%%'`
    # the parent branch is the second to last, i.e. standard/common_pc
    # so we can reverse everything and take the second field
    parent=`echo $tgt | rev | cut -d'/' -f2 | rev`
    target=`echo $tgt | rev | cut -d'/' -f1 | rev`
    if [ -z $out_dir ]; then
	out_dir=$target-$parent
    fi
    full_tgt=$target-$parent
    META_DIR=meta
else
    if [ -z $out_dir ]; then
	out_dir=$target
    fi
    parent=`echo $target | rev | cut -d'-' -f1 | rev`
    full_tgt=$target
    META_DIR=wrs
fi

if [ -e $META_DIR/top_tgt ]; then
    SCC_LIST=`cat $META_DIR/top_tgt`
else
    echo "[INFO] Finding user(s) of target: $target with parent: $parent"
    # Note the space and EOL anchor.  We want to find the SCC file where
    # CURRENT is on the far RHS, i.e. the one that created the branch,
    # and NOT some SCC file that uses the branch as a starting point
    # There is an alternate target, where all _ have been replaced by -
    alt_target=`echo $target | sed 's/_/.*/g'`
    SCC_LIST=`grep -Rl -e 'scc_leaf.* '$alt_target'$' -e 'scc_leaf.* '$target'$' \
            ./$META_DIR/cfg/kernel-*cache/bsp/ ./$META_DIR/cfg/meta/obj`
    for s in $SCC_LIST; do 
	found=`grep -E "scc_leaf.*$parent" $s`
	if [ -n "$found" ] && [ -z "$found_scc" ]; then
	    found_scc=$s
	fi
	if [ -n "$found" ]; then
	    case `basename $s` in
		$machine*) best_match=$s ;;
                *) other_match=$s ;;                
	    esac
	fi
    done
    if [ -n "$best_match" ]; then
	SCC_LIST=$best_match
    elif [ -n "$other_match" ]; then
	SCC_LIST=$other_match
    else
	SCC_LIST=$found_scc
    fi
fi

if [ -z "$SCC_LIST" ]; then
	echo Error: No BSPs \(scc\) use branch $CURRENT as their endpoint.
	exit 1
fi

for SCC in $SCC_LIST ; do
	if [ ! -f $SCC ] ; then
		echo Couldnt find scc file $SCC for $CURRENT
		exit 1
	fi
	echo "[INFO] Branch $CURRENT used by "`basename $SCC`
	run_board_config
	if [ $? != 0 ]; then
		echo config of $CURRENT \(`basename $SCC`\) failed
		exit 1
	fi
done
exit 0
