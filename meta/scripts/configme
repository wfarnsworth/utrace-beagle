#!/bin/bash

# "configme" script.

#  Copyright (c) 2009-2010 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

# Wrapper script to use existing tools to translate kernel
# config fragments into the pre-processed assembly of frags,
# and then finally a .config, and optionally an audit of that
# final .config

# Assumes you have a "default_kernel" clone, non-bare, with
# all BSPs/branches as local refs (i.e. not origin/*), i.e.
# 	git clone --bare git://myserver/default_kernel linux-2.6
# 	cd linux-2.6
#	mkdir .git ; mv * .git
#	git config core.bare false
#	git checkout -f wrs_meta
# Also assumes that current dir is in this linux git repo.

# Return values: zero if a ".config" was created, one otherwise.

CURRENT=`git branch |grep \*|sed 's/^\* //'`
SCRIPT_DIR=`pwd`/wrs/scripts
PATH=$PATH:$SCRIPT_DIR
QUICK=1
META_DIR=meta

usage()
{
	echo `basename $0` \[--audit\] \[--reconfig\] [target]
	echo \t audit: do an audit of final .config file
	echo \t reconfig: reconfigure an existing build
	echo \t target: name of the configuration target
	exit 1
}


get_branch_name()
{
    _meta_series=$1

    branchpoints=`cat $_meta_series|grep '_branch_begin\|_force_branch'|awk '{print $3"|"$4}'`
    if [ -z "$branchpoints" ]; then
	branchpoints=master
    fi

old_ifs=$IFS
IFS='
'
    for i in $branchpoints ; do
	name=`echo  $i | cut -d'|' -f1`
	force=`echo $i | cut -d'|' -f2`

        # pickup the first forced branch, we'll throw the rest away as
	# "branches". Meaning they won't have been created as branches
	# unless multi_branch_divergence was specified
  	if [ -z "$branchname" ]; then
	    branchname=$name
	else
	    if [  "$META_DIR" == "meta" ]; then
		branchname="$branchname/$name"
	    else
		branchname=$name
	    fi
	fi
    done

    echo $branchname
}

# This is factored out into a function because for a given branch,
# there may be more than one user (i.e. big endian, little endian,
# or BSPs that use the same branch but differ only in kernel configs)
# So for each branch, we loop over all "users" (i.e. scc leaf'ers).
run_board_config()
{
    # Can't set these until we've unwound the checkpoint and have wrs data.
    KVER=`cat ./$META_DIR/cfg/kernel-*cache/kver|sed 's/^v//'`
    WRS_ARCH=`grep WRS_ARCH $SCC | awk '{print $3}'`
    KPROFILE=`grep WRS_BOARD $SCC | awk '{print $3}'`
    KTYPE=`grep WRS_KERNEL $SCC | awk '{print $3}'`
    # KTGT=$KPROFILE-$KTYPE
    KTGT=$full_target
    META=./$META_DIR/cfg/meta/`basename $SCC .scc`-meta

    # Build system uses linux_BUILD=$(linux_SRC)-$(ktgt)-build
    # with ktgt=$(kprofile)-$(ktype)
    # and KERNEL_CONFIG=${kprofile}-${ktype}-config-${LINUX_KERNEL_VERSION}
    BUILD_DIR=../linux-$KTGT-build
    CFGFILE=$KTGT-config-$KVER

    if [ "x$WRS_ARCH" == "x" ] ; then
	echo Couldnt determine architecture from file:
	echo -e \\t$SCC
	echo Assuming scc is not a valid BSP endpoint...
	return 1
    fi

    # Fixups to match WRS_ARCH onto kernel.org arch
    if [ $WRS_ARCH == "powerpc_64" ]; then
	WRS_ARCH=powerpc
    fi
    if [ $WRS_ARCH == "mips64" ]; then
	WRS_ARCH=mips
    fi

    if [ -z "$reconfig" ] && [ -d $BUILD_DIR ]; then
	echo Dir $BUILD_DIR already exists, remove/move
	echo it if you want to re-run this configuration utility.
	return 1
    fi

    if [ ! -d $BUILD_DIR ]; then
	mkdir $BUILD_DIR
	if [ $? != 0 ]; then
	    echo Failed to mkdir $BUILD_DIR for final .config file
	    return 1
	fi
    fi

    mkdir -p ./$META_DIR/cfg/$KTGT
    if [ $? != 0 ]; then
	echo Failed to mkdir ./$META_DIR/cfg/$KTGT for config data
	return 1
    fi

    if [ ! -f $META ]; then
	echo Failed to find meta series $META
	return 1
    fi

    kgit-meta -v -k $META
    if [ $? != 0 ]; then
	echo Error running the meta series for collecting config data
	return 1
    fi

    KTGT=`get_branch_name $META`
    generate_cfg $CFGFILE /dev/null `pwd` $BUILD_DIR $KTGT

    if [ $? != 0 ]; then
	echo creation of pre-processed config data failed
	return 1
    fi

    echo "[INFO] Pre-processed cfg file $CFGFILE created."

    make ARCH=$WRS_ARCH O=$BUILD_DIR \
	KBUILD_DEFCONFIG=../../../$META_DIR/cfg/$KTGT/$CFGFILE \
	defconfig > $META_DIR/cfg/$KTGT/config.log 2>&1

    if [ $? != 0 ]; then
	echo Kernel LKC processing of raw config data failed \($WRS_ARCH\)
	echo See $META_DIR/cfg/$KTGT/config.log for details.
	return 1
    fi

    echo "[INFO] processing of raw cfg data completed."

    if [ $QUICK -ne 1 ]; then
	kconf_check $CFGFILE /dev/null `pwd` $BUILD_DIR $KTGT
    fi

cat << EOF

********************************************************************************
  Configuration stored in $BUILD_DIR/.config
********************************************************************************

  To build with this kernel configuration, ensure a suitable toolchain
  is in your path for $WRS_ARCH, note its common command prefix, and do:

   make O=$BUILD_DIR ARCH=$WRS_ARCH \\
        CROSS_COMPILE=<cross-compile-prefix>

  Prefix is usually "<arch>-wrs-linux-gnu-", i.e. powerpc-wrs-linux-gnu-
  as an ARCH=powerpc specific example.

EOF
    return 0
}

#########################  Start here ##########################

if [ -z "$1" ]; then
	usage
	exit
fi

while [ $# -gt 0 ]; do
	case "$1" in
	    --help) 
		usage
		exit
		;;
	    --audit)
		QUICK=0
		;;
	    --reconfig)
		reconfig=t
		;;
	    -v) verbose=t
		;;
	    *) break
		;;
	esac
	shift
done

# an explicit target to configure may have been passed 
# (whatever is left over). If something wasn't passed, we configure
# based on the current branch.
target=$@
if [ -z "$target" ]; then
    echo "[INFO] Finding user(s) of branch \"$CURRENT\""
    target=$CURRENT
fi

# we need to condition the branch. If it is in the form that
# uses / for inheritance, special processing needs to be done.
echo $target | grep -q "/"
if [ $? -eq 0 ]; then
    # remove trailing "/base" that won't be in the .scc files
    # themselves
    tgt=`echo $target | sed 's%/base$%%'`
    # the parent branch is the second to last, i.e. standard/common_pc
    # so we can reverse everything and take the second field
    parent=`echo $tgt | rev | cut -d'/' -f2 | rev`
    target=`echo $tgt | rev | cut -d'/' -f1 | rev`
    full_target=$target-$parent
    META_DIR=meta
else
    full_target=$target
    parent=`echo $target | rev | cut -d'-' -f1 | rev`
    # target=`echo $target | cut -d'-' -f1`
    META_DIR=wrs
fi

echo "[INFO] Finding user(s) of target -- $target -- $parent -"
# Note the space and EOL anchor.  We want to find the SCC file where
# CURRENT is on the far RHS, i.e. the one that created the branch,
# and NOT some SCC file that uses the branch as a starting point.
SCC_LIST=`grep -Rl 'scc_leaf.* '$target'$' ./$META_DIR/cfg/kernel-*cache/bsp/ ./$META_DIR/cfg/meta/obj`
for s in $SCC_LIST; do 
    found=`grep -E "scc_leaf.*$parent" $s`
    if [ -n "$found" ] && [ -z "$found_scc" ]; then
	found_scc=$s
    fi
done
SCC_LIST=$found_scc

if [ -z "$SCC_LIST" ]; then
	echo Error: No BSPs \(scc\) use branch $CURRENT as their endpoint.
	exit 1
fi

for SCC in $SCC_LIST ; do
	if [ ! -f $SCC ] ; then
		echo Couldnt find scc file $SCC for $CURRENT
		exit 1
	fi
	echo "[INFO] Branch $CURRENT used by "`basename $SCC`
	run_board_config
	if [ $? != 0 ]; then
		echo config of $CURRENT \(`basename $SCC`\) failed
		exit 1
	fi
done
exit 0
