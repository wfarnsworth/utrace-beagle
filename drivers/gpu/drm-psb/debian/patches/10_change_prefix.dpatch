#! /bin/sh /usr/share/dpatch/dpatch-run
## 10_change_prefix.dpatch by  <jbs@jbs-laptop>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: change prefix from drm to psb_drm

@DPATCH@

diff -urNad psb-kernel-source-4.41.2/ati_pcigart.c psb-kernel-source-4.41.2.drm_psb/ati_pcigart.c
--- psb-kernel-source-4.41.2/ati_pcigart.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/ati_pcigart.c	2010-05-02 10:13:44.039193286 +0200
@@ -120,7 +120,7 @@
 	free_pages((unsigned long)address, order);
 }
 
-int drm_ati_pcigart_cleanup(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info)
+int psb_drm_ati_pcigart_cleanup(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info)
 {
 	struct drm_sg_mem *entry = dev->sg;
 	unsigned long pages;
@@ -134,7 +134,7 @@
 		return 0;
 	}
 
-	order = drm_order((gart_info->table_size + (PAGE_SIZE-1)) / PAGE_SIZE);
+	order = psb_drm_order((gart_info->table_size + (PAGE_SIZE-1)) / PAGE_SIZE);
 	num_pages = 1 << order;
 
 	if (gart_info->bus_addr) {
@@ -169,9 +169,9 @@
 
 	return 1;
 }
-EXPORT_SYMBOL(drm_ati_pcigart_cleanup);
+EXPORT_SYMBOL(psb_drm_ati_pcigart_cleanup);
 
-int drm_ati_pcigart_init(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info)
+int psb_drm_ati_pcigart_init(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info)
 {
 	struct drm_sg_mem *entry = dev->sg;
 	void *address = NULL;
@@ -190,7 +190,7 @@
 	if (gart_info->gart_table_location == DRM_ATI_GART_MAIN) {
 		DRM_DEBUG("PCI: no table in VRAM: using normal RAM\n");
 
-		order = drm_order((gart_info->table_size +
+		order = psb_drm_order((gart_info->table_size +
 				   (PAGE_SIZE-1)) / PAGE_SIZE);
 		num_pages = 1 << order;
 		address = drm_ati_alloc_pcigart_table(order);
@@ -209,7 +209,7 @@
 					     PCI_DMA_TODEVICE);
 		if (bus_address == 0) {
 			DRM_ERROR("unable to map PCIGART pages!\n");
-			order = drm_order((gart_info->table_size +
+			order = psb_drm_order((gart_info->table_size +
 					   (PAGE_SIZE-1)) / PAGE_SIZE);
 			drm_ati_free_pcigart_table(address, order);
 			address = NULL;
@@ -238,7 +238,7 @@
 						   PAGE_SIZE, PCI_DMA_TODEVICE);
 		if (entry->busaddr[i] == 0) {
 			DRM_ERROR("unable to map PCIGART pages!\n");
-			drm_ati_pcigart_cleanup(dev, gart_info);
+			psb_drm_ati_pcigart_cleanup(dev, gart_info);
 			address = NULL;
 			bus_address = 0;
 			goto done;
@@ -265,7 +265,7 @@
 	gart_info->bus_addr = bus_address;
 	return ret;
 }
-EXPORT_SYMBOL(drm_ati_pcigart_init);
+EXPORT_SYMBOL(psb_drm_ati_pcigart_init);
 
 static int ati_pcigart_needs_unbind_cache_adjust(struct drm_ttm_backend *backend)
 {
@@ -392,7 +392,7 @@
 	.destroy =  ati_pcigart_destroy_ttm,
 };
 
-struct drm_ttm_backend *ati_pcigart_init_ttm(struct drm_device *dev, struct drm_ati_pcigart_info *info, void (*gart_flush_fn)(struct drm_device *dev))
+struct drm_ttm_backend *psb_ati_pcigart_init_ttm(struct drm_device *dev, struct drm_ati_pcigart_info *info, void (*gart_flush_fn)(struct drm_device *dev))
 {
 	ati_pcigart_ttm_backend_t *atipci_be;
 
@@ -408,4 +408,4 @@
 
 	return &atipci_be->backend;
 }
-EXPORT_SYMBOL(ati_pcigart_init_ttm);
+EXPORT_SYMBOL(psb_ati_pcigart_init_ttm);
diff -urNad psb-kernel-source-4.41.2/drm_agpsupport.c psb-kernel-source-4.41.2.drm_psb/drm_agpsupport.c
--- psb-kernel-source-4.41.2/drm_agpsupport.c	2009-08-11 20:18:30.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_agpsupport.c	2010-05-02 10:13:42.379192913 +0200
@@ -42,13 +42,13 @@
  * \param inode device inode.
  * \param file_priv DRM file private.
  * \param cmd command.
- * \param arg pointer to a (output) drm_agp_info structure.
+ * \param arg pointer to a (output) psb_drm_agp_info structure.
  * \return zero on success or a negative number on failure.
  *
  * Verifies the AGP device has been initialized and acquired and fills in the
- * drm_agp_info structure with the information in drm_agp_head::agp_info.
+ * psb_drm_agp_info structure with the information in drm_agp_head::agp_info.
  */
-int drm_agp_info(struct drm_device *dev, struct drm_agp_info *info)
+int psb_drm_agp_info(struct drm_device *dev, struct psb_drm_agp_info *info)
 {
 	DRM_AGP_KERN *kern;
 
@@ -68,15 +68,15 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_agp_info);
+EXPORT_SYMBOL(psb_drm_agp_info);
 
 int drm_agp_info_ioctl(struct drm_device *dev, void *data,
 		       struct drm_file *file_priv)
 {
-	struct drm_agp_info *info = data;
+	struct psb_drm_agp_info *info = data;
 	int err;
 
-	err = drm_agp_info(dev, info);
+	err = psb_drm_agp_info(dev, info);
 	if (err)
 		return err;
 
@@ -92,7 +92,7 @@
  * Verifies the AGP device hasn't been acquired before and calls
  * \c agp_backend_acquire.
  */
-int drm_agp_acquire(struct drm_device * dev)
+int psb_drm_agp_acquire(struct drm_device * dev)
 {
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
 	int retcode;
@@ -113,7 +113,7 @@
 	dev->agp->acquired = 1;
 	return 0;
 }
-EXPORT_SYMBOL(drm_agp_acquire);
+EXPORT_SYMBOL(psb_drm_agp_acquire);
 
 /**
  * Acquire the AGP device (ioctl).
@@ -130,7 +130,7 @@
 int drm_agp_acquire_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
 {
-	return drm_agp_acquire((struct drm_device *) file_priv->head->dev);
+	return psb_drm_agp_acquire((struct drm_device *) file_priv->head->dev);
 }
 
 /**
@@ -141,7 +141,7 @@
  *
  * Verifies the AGP device has been acquired and calls \c agp_backend_release.
  */
-int drm_agp_release(struct drm_device *dev)
+int psb_drm_agp_release(struct drm_device *dev)
 {
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
@@ -154,12 +154,12 @@
 	return 0;
 
 }
-EXPORT_SYMBOL(drm_agp_release);
+EXPORT_SYMBOL(psb_drm_agp_release);
 
 int drm_agp_release_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
 {
-	return drm_agp_release(dev);
+	return psb_drm_agp_release(dev);
 }
 
 /**
@@ -172,7 +172,7 @@
  * Verifies the AGP device has been acquired but not enabled, and calls
  * \c agp_enable.
  */
-int drm_agp_enable(struct drm_device *dev, struct drm_agp_mode mode)
+int psb_drm_agp_enable(struct drm_device *dev, struct drm_agp_mode mode)
 {
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
@@ -186,14 +186,14 @@
 	dev->agp->enabled = 1;
 	return 0;
 }
-EXPORT_SYMBOL(drm_agp_enable);
+EXPORT_SYMBOL(psb_drm_agp_enable);
 
 int drm_agp_enable_ioctl(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv)
 {
 	struct drm_agp_mode *mode = data;
 
-	return drm_agp_enable(dev, *mode);
+	return psb_drm_agp_enable(dev, *mode);
 }
 
 /**
@@ -208,7 +208,7 @@
  * Verifies the AGP device is present and has been acquired, allocates the
  * memory via alloc_agp() and creates a drm_agp_mem entry for it.
  */
-int drm_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request)
+int psb_drm_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request)
 {
 	struct drm_agp_mem *entry;
 	DRM_AGP_MEM *memory;
@@ -217,7 +217,7 @@
 
 	if (!dev->agp || !dev->agp->acquired)
 		return -EINVAL;
-	if (!(entry = drm_alloc(sizeof(*entry), DRM_MEM_AGPLISTS)))
+	if (!(entry = psb_drm_alloc(sizeof(*entry), DRM_MEM_AGPLISTS)))
 		return -ENOMEM;
 
 	memset(entry, 0, sizeof(*entry));
@@ -225,7 +225,7 @@
 	pages = (request->size + PAGE_SIZE - 1) / PAGE_SIZE;
 	type = (u32) request->type;
 	if (!(memory = drm_alloc_agp(dev, pages, type))) {
-		drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+		psb_drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
 		return -ENOMEM;
 	}
 
@@ -240,7 +240,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_agp_alloc);
+EXPORT_SYMBOL(psb_drm_agp_alloc);
 
 
 int drm_agp_alloc_ioctl(struct drm_device *dev, void *data,
@@ -248,7 +248,7 @@
 {
 	struct drm_agp_buffer *request = data;
 
-	return drm_agp_alloc(dev, request);
+	return psb_drm_agp_alloc(dev, request);
 }
 
 /**
@@ -284,7 +284,7 @@
  * Verifies the AGP device is present and acquired, looks-up the AGP memory
  * entry and passes it to the unbind_agp() function.
  */
-int drm_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request)
+int psb_drm_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request)
 {
 	struct drm_agp_mem *entry;
 	int ret;
@@ -300,7 +300,7 @@
 		entry->bound = 0;
 	return ret;
 }
-EXPORT_SYMBOL(drm_agp_unbind);
+EXPORT_SYMBOL(psb_drm_agp_unbind);
 
 
 int drm_agp_unbind_ioctl(struct drm_device *dev, void *data,
@@ -308,7 +308,7 @@
 {
 	struct drm_agp_binding *request = data;
 
-	return drm_agp_unbind(dev, request);
+	return psb_drm_agp_unbind(dev, request);
 }
 
 
@@ -325,7 +325,7 @@
  * is currently bound into the GATT. Looks-up the AGP memory entry and passes
  * it to bind_agp() function.
  */
-int drm_agp_bind(struct drm_device *dev, struct drm_agp_binding *request)
+int psb_drm_agp_bind(struct drm_device *dev, struct drm_agp_binding *request)
 {
 	struct drm_agp_mem *entry;
 	int retcode;
@@ -345,7 +345,7 @@
 		  dev->agp->base, entry->bound);
 	return 0;
 }
-EXPORT_SYMBOL(drm_agp_bind);
+EXPORT_SYMBOL(psb_drm_agp_bind);
 
 
 int drm_agp_bind_ioctl(struct drm_device *dev, void *data,
@@ -353,7 +353,7 @@
 {
 	struct drm_agp_binding *request = data;
 
-	return drm_agp_bind(dev, request);
+	return psb_drm_agp_bind(dev, request);
 }
 
 
@@ -371,7 +371,7 @@
  * unbind_agp(). Frees it via free_agp() as well as the entry itself
  * and unlinks from the doubly linked list it's inserted in.
  */
-int drm_agp_free(struct drm_device *dev, struct drm_agp_buffer *request)
+int psb_drm_agp_free(struct drm_device *dev, struct drm_agp_buffer *request)
 {
 	struct drm_agp_mem *entry;
 
@@ -385,10 +385,10 @@
 	list_del(&entry->head);
 
 	drm_free_agp(entry->memory, entry->pages);
-	drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+	psb_drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
 	return 0;
 }
-EXPORT_SYMBOL(drm_agp_free);
+EXPORT_SYMBOL(psb_drm_agp_free);
 
 
 
@@ -397,7 +397,7 @@
 {
 	struct drm_agp_buffer *request = data;
 
-	return drm_agp_free(dev, request);
+	return psb_drm_agp_free(dev, request);
 }
 
 
@@ -414,7 +414,7 @@
 {
 	struct drm_agp_head *head = NULL;
 
-	if (!(head = drm_alloc(sizeof(*head), DRM_MEM_AGPLISTS)))
+	if (!(head = psb_drm_alloc(sizeof(*head), DRM_MEM_AGPLISTS)))
 		return NULL;
 	memset((void *)head, 0, sizeof(*head));
 
@@ -424,7 +424,7 @@
 	head->bridge = agp_find_bridge(dev->pdev);
 	if (!head->bridge) {
 		if (!(head->bridge = agp_backend_acquire(dev->pdev))) {
-			drm_free(head, sizeof(*head), DRM_MEM_AGPLISTS);
+			psb_drm_free(head, sizeof(*head), DRM_MEM_AGPLISTS);
 			return NULL;
 		}
 		agp_copy_info(head->bridge, &head->agp_info);
@@ -434,7 +434,7 @@
 	}
 #endif
 	if (head->agp_info.chipset == NOT_SUPPORTED) {
-		drm_free(head, sizeof(*head), DRM_MEM_AGPLISTS);
+		psb_drm_free(head, sizeof(*head), DRM_MEM_AGPLISTS);
 		return NULL;
 	}
 	INIT_LIST_HEAD(&head->memory);
@@ -468,13 +468,13 @@
 }
 
 /** Calls agp_bind_memory() */
-int drm_agp_bind_memory(DRM_AGP_MEM * handle, off_t start)
+int psb_drm_agp_bind_memory(DRM_AGP_MEM * handle, off_t start)
 {
 	if (!handle)
 		return -EINVAL;
 	return agp_bind_memory(handle, start);
 }
-EXPORT_SYMBOL(drm_agp_bind_memory);
+EXPORT_SYMBOL(psb_drm_agp_bind_memory);
 
 /** Calls agp_unbind_memory() */
 int drm_agp_unbind_memory(DRM_AGP_MEM * handle)
@@ -545,7 +545,7 @@
 	if (snooped)
 		mem->type = AGP_USER_CACHED_MEMORY;
 
-	ret = drm_agp_bind_memory(mem, bo_mem->mm_node->start);
+	ret = psb_drm_agp_bind_memory(mem, bo_mem->mm_node->start);
 	if (ret)
 		DRM_ERROR("AGP Bind memory failed\n");
 
@@ -602,7 +602,7 @@
 	.destroy =  drm_agp_destroy_ttm,
 };
 
-struct drm_ttm_backend *drm_agp_init_ttm(struct drm_device *dev)
+struct drm_ttm_backend *psb_drm_agp_init_ttm(struct drm_device *dev)
 {
 
 	struct drm_agp_ttm_backend *agp_be;
@@ -626,7 +626,7 @@
 	}
 
 
-	agp_be = drm_calloc(1, sizeof(*agp_be), DRM_MEM_TTM);
+	agp_be = psb_drm_calloc(1, sizeof(*agp_be), DRM_MEM_TTM);
 	if (!agp_be)
 		return NULL;
 
@@ -639,14 +639,14 @@
 
 	return &agp_be->backend;
 }
-EXPORT_SYMBOL(drm_agp_init_ttm);
+EXPORT_SYMBOL(psb_drm_agp_init_ttm);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-void drm_agp_flush_chipset(struct drm_device *dev)
+void psb_drm_agp_flush_chipset(struct drm_device *dev)
 {
 	agp_flush_chipset(dev->agp->bridge);
 }
-EXPORT_SYMBOL(drm_agp_flush_chipset);
+EXPORT_SYMBOL(psb_drm_agp_flush_chipset);
 #endif
 
 #endif				/* __OS_HAS_AGP */
diff -urNad psb-kernel-source-4.41.2/drm_auth.c psb-kernel-source-4.41.2.drm_psb/drm_auth.c
--- psb-kernel-source-4.41.2/drm_auth.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_auth.c	2010-05-02 10:13:45.767192784 +0200
@@ -78,7 +78,7 @@
 
 	DRM_DEBUG("%d\n", magic);
 
-	entry = drm_alloc(sizeof(*entry), DRM_MEM_MAGIC);
+	entry = psb_drm_alloc(sizeof(*entry), DRM_MEM_MAGIC);
 	if (!entry)
 		return -ENOMEM;
 	memset(entry, 0, sizeof(*entry));
@@ -118,7 +118,7 @@
 	list_del(&pt->head);
 	mutex_unlock(&dev->struct_mutex);
 
-	drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+	psb_drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
 
 	return 0;
 }
diff -urNad psb-kernel-source-4.41.2/drm_bo.c psb-kernel-source-4.41.2.drm_psb/drm_bo.c
--- psb-kernel-source-4.41.2/drm_bo.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_bo.c	2010-05-02 10:13:45.239192720 +0200
@@ -177,8 +177,8 @@
 {
 	struct drm_device *dev = bo->dev;
 	struct drm_buffer_manager *bm = &dev->bm;
-	int old_is_pci = drm_mem_reg_is_pci(dev, &bo->mem);
-	int new_is_pci = drm_mem_reg_is_pci(dev, mem);
+	int old_is_pci = psb_drm_mem_reg_is_pci(dev, &bo->mem);
+	int new_is_pci = psb_drm_mem_reg_is_pci(dev, mem);
 	struct drm_mem_type_manager *old_man = &bm->man[bo->mem.mem_type];
 	struct drm_mem_type_manager *new_man = &bm->man[mem->mem_type];
 	int ret = 0;
@@ -199,7 +199,7 @@
 			goto out_err;
 
 		if (mem->mem_type != DRM_BO_MEM_LOCAL) {
-			ret = drm_bind_ttm(bo->ttm, mem);
+			ret = psb_drm_bind_ttm(bo->ttm, mem);
 			if (ret)
 				goto out_err;
 		}
@@ -223,14 +223,14 @@
 	if (!(old_man->flags & _DRM_FLAG_MEMTYPE_FIXED) &&
 		   !(new_man->flags & _DRM_FLAG_MEMTYPE_FIXED)) {
 
-		ret = drm_bo_move_ttm(bo, evict, no_wait, mem);
+		ret = psb_drm_bo_move_ttm(bo, evict, no_wait, mem);
 
 	} else if (dev->driver->bo_driver->move) {
 		ret = dev->driver->bo_driver->move(bo, evict, no_wait, mem);
 
 	} else {
 
-		ret = drm_bo_move_memcpy(bo, evict, no_wait, mem);
+		ret = psb_drm_bo_move_memcpy(bo, evict, no_wait, mem);
 
 	}
 
@@ -279,7 +279,7 @@
  * Wait until the buffer is idle.
  */
 
-int drm_bo_wait(struct drm_buffer_object *bo, int lazy, int ignore_signals,
+int psb_drm_bo_wait(struct drm_buffer_object *bo, int lazy, int ignore_signals,
 		int no_wait)
 {
 	int ret;
@@ -287,24 +287,24 @@
 	DRM_ASSERT_LOCKED(&bo->mutex);
 
 	if (bo->fence) {
-		if (drm_fence_object_signaled(bo->fence, bo->fence_type)) {
-			drm_fence_usage_deref_unlocked(&bo->fence);
+		if (psb_drm_fence_object_signaled(bo->fence, bo->fence_type)) {
+			psb_drm_fence_usage_deref_unlocked(&bo->fence);
 			return 0;
 		}
 		if (no_wait)
 			return -EBUSY;
 
-		ret = drm_fence_object_wait(bo->fence, lazy, ignore_signals,
+		ret = psb_drm_fence_object_wait(bo->fence, lazy, ignore_signals,
 					  bo->fence_type);
 		if (ret) {
 			return ret;
 		}
 
-		drm_fence_usage_deref_unlocked(&bo->fence);
+		psb_drm_fence_usage_deref_unlocked(&bo->fence);
 	}
 	return 0;
 }
-EXPORT_SYMBOL(drm_bo_wait);
+EXPORT_SYMBOL(psb_drm_bo_wait);
 
 static int drm_bo_expire_fence(struct drm_buffer_object *bo, int allow_errors)
 {
@@ -316,7 +316,7 @@
 			unsigned long _end = jiffies + 3 * DRM_HZ;
 			int ret;
 			do {
-				ret = drm_bo_wait(bo, 0, 1, 0);
+				ret = psb_drm_bo_wait(bo, 0, 1, 0);
 				if (ret && allow_errors)
 					return ret;
 
@@ -330,7 +330,7 @@
 			}
 		}
 		if (bo->fence)
-			drm_fence_usage_deref_unlocked(&bo->fence);
+			psb_drm_fence_usage_deref_unlocked(&bo->fence);
 	}
 	return 0;
 }
@@ -354,9 +354,9 @@
 
 	DRM_FLAG_MASKED(bo->priv_flags, 0, _DRM_BO_FLAG_UNFENCED);
 
-	if (bo->fence && drm_fence_object_signaled(bo->fence,
+	if (bo->fence && psb_drm_fence_object_signaled(bo->fence,
 						   bo->fence_type))
-		drm_fence_usage_deref_unlocked(&bo->fence);
+		psb_drm_fence_usage_deref_unlocked(&bo->fence);
 
 	if (bo->fence && remove_all)
 		(void)drm_bo_expire_fence(bo, 0);
@@ -369,14 +369,14 @@
 	if (!bo->fence) {
 		list_del_init(&bo->lru);
 		if (bo->mem.mm_node) {
-			drm_mm_put_block(bo->mem.mm_node);
+			psb_drm_mm_put_block(bo->mem.mm_node);
 			if (bo->pinned_node == bo->mem.mm_node)
 				bo->pinned_node = NULL;
 			bo->mem.mm_node = NULL;
 		}
 		list_del_init(&bo->pinned_lru);
 		if (bo->pinned_node) {
-			drm_mm_put_block(bo->pinned_node);
+			psb_drm_mm_put_block(bo->pinned_node);
 			bo->pinned_node = NULL;
 		}
 		list_del_init(&bo->ddestroy);
@@ -386,7 +386,7 @@
 	}
 
 	if (list_empty(&bo->ddestroy)) {
-		drm_fence_object_flush(bo->fence, bo->fence_type);
+		psb_drm_fence_object_flush(bo->fence, bo->fence_type);
 		list_add_tail(&bo->ddestroy, &bm->ddestroy);
 		schedule_delayed_work(&bm->wq,
 				      ((DRM_HZ / 100) < 1) ? 1 : DRM_HZ / 100);
@@ -399,7 +399,7 @@
 
 static void drm_bo_unreserve_size(unsigned long size)
 {
-	drm_free_memctl(size);
+	psb_drm_free_memctl(size);
 }
 
 /*
@@ -439,7 +439,7 @@
 
 		reserved_size = bo->reserved_size;
 
-		drm_free(bo, sizeof(*bo), DRM_MEM_BUFOBJ);
+		psb_drm_free(bo, sizeof(*bo), DRM_MEM_BUFOBJ);
 		drm_bo_unreserve_size(reserved_size);
 
 		return;
@@ -513,7 +513,7 @@
 	mutex_unlock(&dev->struct_mutex);
 }
 
-void drm_bo_usage_deref_locked(struct drm_buffer_object **bo)
+void psb_drm_bo_usage_deref_locked(struct drm_buffer_object **bo)
 {
 	struct drm_buffer_object *tmp_bo = *bo;
 	bo = NULL;
@@ -523,7 +523,7 @@
 	if (atomic_dec_and_test(&tmp_bo->usage))
 		drm_bo_destroy_locked(tmp_bo);
 }
-EXPORT_SYMBOL(drm_bo_usage_deref_locked);
+EXPORT_SYMBOL(psb_drm_bo_usage_deref_locked);
 
 static void drm_bo_base_deref_locked(struct drm_file *file_priv,
 				     struct drm_user_object *uo)
@@ -534,10 +534,10 @@
 	DRM_ASSERT_LOCKED(&bo->dev->struct_mutex);
 
 	drm_bo_takedown_vm_locked(bo);
-	drm_bo_usage_deref_locked(&bo);
+	psb_drm_bo_usage_deref_locked(&bo);
 }
 
-void drm_bo_usage_deref_unlocked(struct drm_buffer_object **bo)
+void psb_drm_bo_usage_deref_unlocked(struct drm_buffer_object **bo)
 {
 	struct drm_buffer_object *tmp_bo = *bo;
 	struct drm_device *dev = tmp_bo->dev;
@@ -550,9 +550,9 @@
 		mutex_unlock(&dev->struct_mutex);
 	}
 }
-EXPORT_SYMBOL(drm_bo_usage_deref_unlocked);
+EXPORT_SYMBOL(psb_drm_bo_usage_deref_unlocked);
 
-void drm_putback_buffer_objects(struct drm_device *dev)
+void psb_drm_putback_buffer_objects(struct drm_device *dev)
 {
 	struct drm_buffer_manager *bm = &dev->bm;
 	struct list_head *list = &bm->unfenced;
@@ -578,11 +578,11 @@
 
 		drm_bo_add_to_lru(entry);
 		mutex_unlock(&entry->mutex);
-		drm_bo_usage_deref_locked(&entry);
+		psb_drm_bo_usage_deref_locked(&entry);
 	}
 	mutex_unlock(&dev->struct_mutex);
 }
-EXPORT_SYMBOL(drm_putback_buffer_objects);
+EXPORT_SYMBOL(psb_drm_putback_buffer_objects);
 
 
 /*
@@ -590,7 +590,7 @@
  * and deregister fence object usage.
  */
 
-int drm_fence_buffer_objects(struct drm_device *dev,
+int psb_drm_fence_buffer_objects(struct drm_device *dev,
 			     struct list_head *list,
 			     uint32_t fence_flags,
 			     struct drm_fence_object *fence,
@@ -643,7 +643,7 @@
 		}
 	} else {
 		mutex_unlock(&dev->struct_mutex);
-		ret = drm_fence_object_create(dev, fence_class, fence_type,
+		ret = psb_drm_fence_object_create(dev, fence_class, fence_type,
 					      fence_flags | DRM_FENCE_FLAG_EMIT,
 					      &fence);
 		mutex_lock(&dev->struct_mutex);
@@ -664,7 +664,7 @@
 		if (entry->priv_flags & _DRM_BO_FLAG_UNFENCED) {
 			count++;
 			if (entry->fence)
-				drm_fence_usage_deref_locked(&entry->fence);
+				psb_drm_fence_usage_deref_locked(&entry->fence);
 			entry->fence = drm_fence_reference_locked(fence);
 			entry->fence_class = entry->new_fence_class;
 			entry->fence_type = entry->new_fence_type;
@@ -674,7 +674,7 @@
 			drm_bo_add_to_lru(entry);
 		}
 		mutex_unlock(&entry->mutex);
-		drm_bo_usage_deref_locked(&entry);
+		psb_drm_bo_usage_deref_locked(&entry);
 		l = list->next;
 	}
 	DRM_DEBUG("Fenced %d buffers\n", count);
@@ -683,7 +683,7 @@
 	*used_fence = fence;
 	return ret;
 }
-EXPORT_SYMBOL(drm_fence_buffer_objects);
+EXPORT_SYMBOL(psb_drm_fence_buffer_objects);
 
 /*
  * bo->mutex locked
@@ -706,7 +706,7 @@
 	if (bo->mem.mem_type != mem_type)
 		goto out;
 
-	ret = drm_bo_wait(bo, 0, 0, no_wait);
+	ret = psb_drm_bo_wait(bo, 0, 0, no_wait);
 
 	if (ret && ret != -EAGAIN) {
 		DRM_ERROR("Failed to expire fence before "
@@ -719,7 +719,7 @@
 
 	evict_mem = bo->mem;
 	evict_mem.mask = dev->driver->bo_driver->evict_mask(bo);
-	ret = drm_bo_mem_space(bo, &evict_mem, no_wait);
+	ret = psb_drm_bo_mem_space(bo, &evict_mem, no_wait);
 
 	if (ret) {
 		if (ret != -EAGAIN)
@@ -739,7 +739,7 @@
 	mutex_lock(&dev->struct_mutex);
 	if (evict_mem.mm_node) {
 		if (evict_mem.mm_node != bo->pinned_node)
-			drm_mm_put_block(evict_mem.mm_node);
+			psb_drm_mm_put_block(evict_mem.mm_node);
 		evict_mem.mm_node = NULL;
 	}
 	list_del(&bo->lru);
@@ -788,7 +788,7 @@
 
 		ret = drm_bo_evict(entry, mem_type, no_wait);
 		mutex_unlock(&entry->mutex);
-		drm_bo_usage_deref_unlocked(&entry);
+		psb_drm_bo_usage_deref_unlocked(&entry);
 		if (ret)
 			return ret;
 		mutex_lock(&dev->struct_mutex);
@@ -862,7 +862,7 @@
  * drm_bo_mem_force_space is attempted in priority order to evict and find
  * space.
  */
-int drm_bo_mem_space(struct drm_buffer_object *bo,
+int psb_drm_bo_mem_space(struct drm_buffer_object *bo,
 		     struct drm_bo_mem_reg *mem, int no_wait)
 {
 	struct drm_device *dev = bo->dev;
@@ -957,7 +957,7 @@
 	ret = (has_eagain) ? -EAGAIN : -ENOMEM;
 	return ret;
 }
-EXPORT_SYMBOL(drm_bo_mem_space);
+EXPORT_SYMBOL(psb_drm_bo_mem_space);
 
 static int drm_bo_new_mask(struct drm_buffer_object *bo,
 			   uint64_t new_flags, uint64_t used_mask)
@@ -1011,13 +1011,13 @@
  * Call dev->struct_mutex locked.
  */
 
-struct drm_buffer_object *drm_lookup_buffer_object(struct drm_file *file_priv,
+struct drm_buffer_object *psb_drm_lookup_buffer_object(struct drm_file *file_priv,
 					      uint32_t handle, int check_owner)
 {
 	struct drm_user_object *uo;
 	struct drm_buffer_object *bo;
 
-	uo = drm_lookup_user_object(file_priv, handle);
+	uo = psb_drm_lookup_user_object(file_priv, handle);
 
 	if (!uo || (uo->type != drm_buffer_type)) {
 		DRM_ERROR("Could not find buffer object 0x%08x\n", handle);
@@ -1025,7 +1025,7 @@
 	}
 
 	if (check_owner && file_priv != uo->owner) {
-		if (!drm_lookup_ref_object(file_priv, uo, _DRM_REF_USE))
+		if (!psb_drm_lookup_ref_object(file_priv, uo, _DRM_REF_USE))
 			return NULL;
 	}
 
@@ -1033,7 +1033,7 @@
 	atomic_inc(&bo->usage);
 	return bo;
 }
-EXPORT_SYMBOL(drm_lookup_buffer_object);
+EXPORT_SYMBOL(psb_drm_lookup_buffer_object);
 
 /*
  * Call bo->mutex locked.
@@ -1047,8 +1047,8 @@
 
 	BUG_ON(bo->priv_flags & _DRM_BO_FLAG_UNFENCED);
 	if (fence) {
-		if (drm_fence_object_signaled(fence, bo->fence_type)) {
-			drm_fence_usage_deref_unlocked(&bo->fence);
+		if (psb_drm_fence_object_signaled(fence, bo->fence_type)) {
+			psb_drm_fence_usage_deref_unlocked(&bo->fence);
 			return 0;
 		}
 		return 1;
@@ -1067,13 +1067,13 @@
 
 	BUG_ON(bo->priv_flags & _DRM_BO_FLAG_UNFENCED);
 	if (fence) {
-		if (drm_fence_object_signaled(fence, bo->fence_type)) {
-			drm_fence_usage_deref_unlocked(&bo->fence);
+		if (psb_drm_fence_object_signaled(fence, bo->fence_type)) {
+			psb_drm_fence_usage_deref_unlocked(&bo->fence);
 			return 0;
 		}
-		drm_fence_object_flush(fence, DRM_FENCE_TYPE_EXE);
-		if (drm_fence_object_signaled(fence, bo->fence_type)) {
-			drm_fence_usage_deref_unlocked(&bo->fence);
+		psb_drm_fence_object_flush(fence, DRM_FENCE_TYPE_EXE);
+		if (psb_drm_fence_object_signaled(fence, bo->fence_type)) {
+			psb_drm_fence_usage_deref_unlocked(&bo->fence);
 			return 0;
 		}
 		return 1;
@@ -1159,7 +1159,7 @@
  * Bo locked.
  */
 
-void drm_bo_fill_rep_arg(struct drm_buffer_object *bo,
+void psb_drm_bo_fill_rep_arg(struct drm_buffer_object *bo,
 			 struct drm_bo_info_rep *rep)
 {
 	if (!rep)
@@ -1186,7 +1186,7 @@
 				DRM_BO_REP_BUSY);
 	}
 }
-EXPORT_SYMBOL(drm_bo_fill_rep_arg);
+EXPORT_SYMBOL(psb_drm_bo_fill_rep_arg);
 
 /*
  * Wait for buffer idle and register that we've mapped the buffer.
@@ -1205,7 +1205,7 @@
 	int no_wait = hint & DRM_BO_HINT_DONT_BLOCK;
 
 	mutex_lock(&dev->struct_mutex);
-	bo = drm_lookup_buffer_object(file_priv, handle, 1);
+	bo = psb_drm_lookup_buffer_object(file_priv, handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 
 	if (!bo)
@@ -1230,7 +1230,7 @@
 				goto out;
 			}
 
-			ret = drm_bo_wait(bo, 0, 0, no_wait);
+			ret = psb_drm_bo_wait(bo, 0, 0, no_wait);
 			if (ret) {
 				atomic_dec(&bo->mapped);
 				goto out;
@@ -1264,10 +1264,10 @@
 			wake_up_all(&bo->event_queue);
 
 	} else
-		drm_bo_fill_rep_arg(bo, rep);
+		psb_drm_bo_fill_rep_arg(bo, rep);
 out:
 	mutex_unlock(&bo->mutex);
-	drm_bo_usage_deref_unlocked(&bo);
+	psb_drm_bo_usage_deref_unlocked(&bo);
 	return ret;
 }
 
@@ -1280,20 +1280,20 @@
 
 	mutex_lock(&dev->struct_mutex);
 
-	bo = drm_lookup_buffer_object(file_priv, handle, 1);
+	bo = psb_drm_lookup_buffer_object(file_priv, handle, 1);
 	if (!bo) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	ro = drm_lookup_ref_object(file_priv, &bo->base, _DRM_REF_TYPE1);
+	ro = psb_drm_lookup_ref_object(file_priv, &bo->base, _DRM_REF_TYPE1);
 	if (!ro) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	drm_remove_ref_object(file_priv, ro);
-	drm_bo_usage_deref_locked(&bo);
+	psb_drm_remove_ref_object(file_priv, ro);
+	psb_drm_bo_usage_deref_locked(&bo);
 out:
 	mutex_unlock(&dev->struct_mutex);
 	return ret;
@@ -1343,7 +1343,7 @@
 	 * Wait for outstanding fences.
 	 */
 
-	ret = drm_bo_wait(bo, 0, 0, no_wait);
+	ret = psb_drm_bo_wait(bo, 0, 0, no_wait);
 	if (ret)
 		return ret;
 
@@ -1360,7 +1360,7 @@
 	/*
 	 * Determine where to move the buffer.
 	 */
-	ret = drm_bo_mem_space(bo, &mem, no_wait);
+	ret = psb_drm_bo_mem_space(bo, &mem, no_wait);
 	if (ret)
 		goto out_unlock;
 
@@ -1371,7 +1371,7 @@
 	if (ret || !move_unfenced) {
 		if (mem.mm_node) {
 			if (mem.mm_node != bo->pinned_node)
-				drm_mm_put_block(mem.mm_node);
+				psb_drm_mm_put_block(mem.mm_node);
 			mem.mm_node = NULL;
 		}
 		drm_bo_add_to_lru(bo);
@@ -1451,7 +1451,7 @@
 							     no_wait);
 		}
 		if (ret)
-			ret = drm_bo_wait(bo, 0, 0, no_wait);
+			ret = psb_drm_bo_wait(bo, 0, 0, no_wait);
 
 		if (ret)
 			return ret;
@@ -1495,7 +1495,7 @@
 
 		if (bo->pinned_node != bo->mem.mm_node) {
 			if (bo->pinned_node != NULL)
-				drm_mm_put_block(bo->pinned_node);
+				psb_drm_mm_put_block(bo->pinned_node);
 			bo->pinned_node = bo->mem.mm_node;
 		}
 
@@ -1506,7 +1506,7 @@
 		mutex_lock(&dev->struct_mutex);
 
 		if (bo->pinned_node != bo->mem.mm_node)
-			drm_mm_put_block(bo->pinned_node);
+			psb_drm_mm_put_block(bo->pinned_node);
 
 		list_del_init(&bo->pinned_lru);
 		bo->pinned_node = NULL;
@@ -1548,7 +1548,7 @@
 	return 0;
 }
 
-int drm_bo_do_validate(struct drm_buffer_object *bo,
+int psb_drm_bo_do_validate(struct drm_buffer_object *bo,
 		       uint64_t flags, uint64_t mask, uint32_t hint,
 		       uint32_t fence_class,
 		       int no_wait,
@@ -1573,15 +1573,15 @@
 					 no_wait);
 out:
 	if (rep)
-		drm_bo_fill_rep_arg(bo, rep);
+		psb_drm_bo_fill_rep_arg(bo, rep);
 
 	mutex_unlock(&bo->mutex);
 	return ret;
 }
-EXPORT_SYMBOL(drm_bo_do_validate);
+EXPORT_SYMBOL(psb_drm_bo_do_validate);
 
 
-int drm_bo_handle_validate(struct drm_file *file_priv, uint32_t handle,
+int psb_drm_bo_handle_validate(struct drm_file *file_priv, uint32_t handle,
 			   uint32_t fence_class,
 			   uint64_t flags, uint64_t mask,
 			   uint32_t hint,
@@ -1595,7 +1595,7 @@
 	int no_wait = hint & DRM_BO_HINT_DONT_BLOCK;
 
 	mutex_lock(&dev->struct_mutex);
-	bo = drm_lookup_buffer_object(file_priv, handle, 1);
+	bo = psb_drm_lookup_buffer_object(file_priv, handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 
 	if (!bo)
@@ -1612,17 +1612,17 @@
 		mask &= ~(DRM_BO_FLAG_NO_EVICT | DRM_BO_FLAG_NO_MOVE);
 
 
-	ret = drm_bo_do_validate(bo, flags, mask, hint, fence_class,
+	ret = psb_drm_bo_do_validate(bo, flags, mask, hint, fence_class,
 				 no_wait, rep);
 
 	if (!ret && bo_rep)
 		*bo_rep = bo;
 	else
-		drm_bo_usage_deref_unlocked(&bo);
+		psb_drm_bo_usage_deref_unlocked(&bo);
 
 	return ret;
 }
-EXPORT_SYMBOL(drm_bo_handle_validate);
+EXPORT_SYMBOL(psb_drm_bo_handle_validate);
 
 static int drm_bo_handle_info(struct drm_file *file_priv, uint32_t handle,
 			      struct drm_bo_info_rep *rep)
@@ -1631,7 +1631,7 @@
 	struct drm_buffer_object *bo;
 
 	mutex_lock(&dev->struct_mutex);
-	bo = drm_lookup_buffer_object(file_priv, handle, 1);
+	bo = psb_drm_lookup_buffer_object(file_priv, handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 
 	if (!bo)
@@ -1640,9 +1640,9 @@
 	mutex_lock(&bo->mutex);
 	if (!(bo->priv_flags & _DRM_BO_FLAG_UNFENCED))
 		(void)drm_bo_busy(bo);
-	drm_bo_fill_rep_arg(bo, rep);
+	psb_drm_bo_fill_rep_arg(bo, rep);
 	mutex_unlock(&bo->mutex);
-	drm_bo_usage_deref_unlocked(&bo);
+	psb_drm_bo_usage_deref_unlocked(&bo);
 	return 0;
 }
 
@@ -1656,7 +1656,7 @@
 	int ret;
 
 	mutex_lock(&dev->struct_mutex);
-	bo = drm_lookup_buffer_object(file_priv, handle, 1);
+	bo = psb_drm_lookup_buffer_object(file_priv, handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 
 	if (!bo)
@@ -1666,15 +1666,15 @@
 	ret = drm_bo_wait_unfenced(bo, no_wait, 0);
 	if (ret)
 		goto out;
-	ret = drm_bo_wait(bo, hint & DRM_BO_HINT_WAIT_LAZY, 0, no_wait);
+	ret = psb_drm_bo_wait(bo, hint & DRM_BO_HINT_WAIT_LAZY, 0, no_wait);
 	if (ret)
 		goto out;
 
-	drm_bo_fill_rep_arg(bo, rep);
+	psb_drm_bo_fill_rep_arg(bo, rep);
 
 out:
 	mutex_unlock(&bo->mutex);
-	drm_bo_usage_deref_unlocked(&bo);
+	psb_drm_bo_usage_deref_unlocked(&bo);
 	return ret;
 }
 
@@ -1698,7 +1698,7 @@
 	return drm_alloc_memctl(*size);
 }
 
-int drm_buffer_object_create(struct drm_device *dev,
+int psb_drm_buffer_object_create(struct drm_device *dev,
 			     unsigned long size,
 			     enum drm_bo_type type,
 			     uint64_t mask,
@@ -1728,7 +1728,7 @@
 		return ret;
 	}
 
-	bo = drm_calloc(1, sizeof(*bo), DRM_MEM_BUFOBJ);
+	bo = psb_drm_calloc(1, sizeof(*bo), DRM_MEM_BUFOBJ);
 
 	if (!bo) {
 		drm_bo_unreserve_size(num_pages);
@@ -1786,10 +1786,10 @@
 out_err:
 	mutex_unlock(&bo->mutex);
 
-	drm_bo_usage_deref_unlocked(&bo);
+	psb_drm_bo_usage_deref_unlocked(&bo);
 	return ret;
 }
-EXPORT_SYMBOL(drm_buffer_object_create);
+EXPORT_SYMBOL(psb_drm_buffer_object_create);
 
 
 static int drm_bo_add_user_object(struct drm_file *file_priv,
@@ -1799,7 +1799,7 @@
 	int ret;
 
 	mutex_lock(&dev->struct_mutex);
-	ret = drm_add_user_object(file_priv, &bo->base, shareable);
+	ret = psb_drm_add_user_object(file_priv, &bo->base, shareable);
 	if (ret)
 		goto out;
 
@@ -1835,7 +1835,7 @@
 	if (bo_type == drm_bo_type_user)
 		req->mask &= ~DRM_BO_FLAG_SHAREABLE;
 
-	ret = drm_buffer_object_create(file_priv->head->dev,
+	ret = psb_drm_buffer_object_create(file_priv->head->dev,
 				       req->size, bo_type, req->mask,
 				       req->hint, req->page_alignment,
 				       req->buffer_start, &entry);
@@ -1845,12 +1845,12 @@
 	ret = drm_bo_add_user_object(file_priv, entry,
 				     req->mask & DRM_BO_FLAG_SHAREABLE);
 	if (ret) {
-		drm_bo_usage_deref_unlocked(&entry);
+		psb_drm_bo_usage_deref_unlocked(&entry);
 		goto out;
 	}
 
 	mutex_lock(&entry->mutex);
-	drm_bo_fill_rep_arg(entry, rep);
+	psb_drm_bo_fill_rep_arg(entry, rep);
 	mutex_unlock(&entry->mutex);
 
 out:
@@ -1870,18 +1870,18 @@
 		return -EINVAL;
 	}
 
-	ret = drm_bo_read_lock(&dev->bm.bm_lock, 1);
+	ret = psb_drm_bo_read_lock(&dev->bm.bm_lock, 1);
 	if (ret)
 		return ret;
 
-	ret = drm_bo_handle_validate(file_priv, req->handle, req->fence_class,
+	ret = psb_drm_bo_handle_validate(file_priv, req->handle, req->fence_class,
 				     req->flags,
 				     req->mask,
 				     req->hint | DRM_BO_HINT_DONT_FENCE,
 				     1,
 				     rep, NULL);
 
-	(void) drm_bo_read_unlock(&dev->bm.bm_lock);
+	(void) psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 	if (ret)
 		return ret;
 
@@ -2019,7 +2019,7 @@
 		if (bo->pinned_node == bo->mem.mm_node)
 			bo->pinned_node = NULL;
 		if (bo->pinned_node != NULL) {
-			drm_mm_put_block(bo->pinned_node);
+			psb_drm_mm_put_block(bo->pinned_node);
 			bo->pinned_node = NULL;
 		}
 		mutex_unlock(&dev->struct_mutex);
@@ -2109,7 +2109,7 @@
 					allow_errors);
 		mutex_lock(&dev->struct_mutex);
 
-		drm_bo_usage_deref_locked(&entry);
+		psb_drm_bo_usage_deref_locked(&entry);
 		if (ret)
 			return ret;
 
@@ -2120,7 +2120,7 @@
 		do_restart = ((next->prev != list) && (next->prev != prev));
 
 		if (nentry != NULL && do_restart)
-			drm_bo_usage_deref_locked(&nentry);
+			psb_drm_bo_usage_deref_locked(&nentry);
 
 		if (do_restart)
 			goto restart;
@@ -2128,7 +2128,7 @@
 	return 0;
 }
 
-int drm_bo_clean_mm(struct drm_device *dev, unsigned mem_type)
+int psb_drm_bo_clean_mm(struct drm_device *dev, unsigned mem_type)
 {
 	struct drm_buffer_manager *bm = &dev->bm;
 	struct drm_mem_type_manager *man = &bm->man[mem_type];
@@ -2154,7 +2154,7 @@
 		drm_bo_force_list_clean(dev, &man->pinned, mem_type, 1, 0, 1);
 
 		if (drm_mm_clean(&man->manager)) {
-			drm_mm_takedown(&man->manager);
+			psb_drm_mm_takedown(&man->manager);
 		} else {
 			ret = -EBUSY;
 		}
@@ -2162,7 +2162,7 @@
 
 	return ret;
 }
-EXPORT_SYMBOL(drm_bo_clean_mm);
+EXPORT_SYMBOL(psb_drm_bo_clean_mm);
 
 /**
  *Evict all buffers of a particular mem_type, but leave memory manager
@@ -2195,7 +2195,7 @@
 	return ret;
 }
 
-int drm_bo_init_mm(struct drm_device *dev,
+int psb_drm_bo_init_mm(struct drm_device *dev,
 		   unsigned type,
 		   unsigned long p_offset, unsigned long p_size)
 {
@@ -2225,7 +2225,7 @@
 			DRM_ERROR("Zero size memory manager type %d\n", type);
 			return ret;
 		}
-		ret = drm_mm_init(&man->manager, p_offset, p_size);
+		ret = psb_drm_mm_init(&man->manager, p_offset, p_size);
 		if (ret)
 			return ret;
 	}
@@ -2237,16 +2237,16 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_bo_init_mm);
+EXPORT_SYMBOL(psb_drm_bo_init_mm);
 
 /*
  * This function is intended to be called on drm driver unload.
  * If you decide to call it from lastclose, you must protect the call
- * from a potentially racing drm_bo_driver_init in firstopen.
+ * from a potentially racing psb_drm_bo_driver_init in firstopen.
  * (This may happen on X server restart).
  */
 
-int drm_bo_driver_finish(struct drm_device *dev)
+int psb_drm_bo_driver_finish(struct drm_device *dev)
 {
 	struct drm_buffer_manager *bm = &dev->bm;
 	int ret = 0;
@@ -2263,7 +2263,7 @@
 		man = &bm->man[i];
 		if (man->has_type) {
 			man->use_type = 0;
-			if ((i != DRM_BO_MEM_LOCAL) && drm_bo_clean_mm(dev, i)) {
+			if ((i != DRM_BO_MEM_LOCAL) && psb_drm_bo_clean_mm(dev, i)) {
 				ret = -EBUSY;
 				DRM_ERROR("DRM memory manager type %d "
 					  "is not clean.\n", i);
@@ -2299,16 +2299,16 @@
 	mutex_unlock(&dev->struct_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(drm_bo_driver_finish);
+EXPORT_SYMBOL(psb_drm_bo_driver_finish);
 
 /*
  * This function is intended to be called on drm driver load.
  * If you decide to call it from firstopen, you must protect the call
- * from a potentially racing drm_bo_driver_finish in lastclose.
+ * from a potentially racing psb_drm_bo_driver_finish in lastclose.
  * (This may happen on X server restart).
  */
 
-int drm_bo_driver_init(struct drm_device *dev)
+int psb_drm_bo_driver_init(struct drm_device *dev)
 {
 	struct drm_bo_driver *driver = dev->driver->bo_driver;
 	struct drm_buffer_manager *bm = &dev->bm;
@@ -2334,7 +2334,7 @@
 	 * Initialize the system memory buffer type.
 	 * Other types need to be driver / IOCTL initialized.
 	 */
-	ret = drm_bo_init_mm(dev, DRM_BO_MEM_LOCAL, 0, 0);
+	ret = psb_drm_bo_init_mm(dev, DRM_BO_MEM_LOCAL, 0, 0);
 	if (ret)
 		goto out_unlock;
 
@@ -2353,7 +2353,7 @@
 	mutex_unlock(&dev->struct_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(drm_bo_driver_init);
+EXPORT_SYMBOL(psb_drm_bo_driver_init);
 
 int drm_mm_init_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
@@ -2393,7 +2393,7 @@
 		DRM_ERROR("System memory buffers already initialized.\n");
 		goto out;
 	}
-	ret = drm_bo_init_mm(dev, arg->mem_type,
+	ret = psb_drm_bo_init_mm(dev, arg->mem_type,
 			     arg->p_offset, arg->p_size);
 
 out:
@@ -2433,7 +2433,7 @@
 		goto out;
 	}
 	ret = 0;
-	if (drm_bo_clean_mm(dev, arg->mem_type)) {
+	if (psb_drm_bo_clean_mm(dev, arg->mem_type)) {
 		DRM_ERROR("Memory manager type %d not clean. "
 			  "Delaying takedown\n", arg->mem_type);
 	}
@@ -2506,7 +2506,7 @@
  * buffer object vm functions.
  */
 
-int drm_mem_reg_is_pci(struct drm_device *dev, struct drm_bo_mem_reg *mem)
+int psb_drm_mem_reg_is_pci(struct drm_device *dev, struct drm_bo_mem_reg *mem)
 {
 	struct drm_buffer_manager *bm = &dev->bm;
 	struct drm_mem_type_manager *man = &bm->man[mem->mem_type];
@@ -2523,7 +2523,7 @@
 	}
 	return 1;
 }
-EXPORT_SYMBOL(drm_mem_reg_is_pci);
+EXPORT_SYMBOL(psb_drm_mem_reg_is_pci);
 
 /**
  * \c Get the PCI offset for the buffer object memory.
@@ -2551,7 +2551,7 @@
 	if (!(man->flags & _DRM_FLAG_MEMTYPE_MAPPABLE))
 		return -EINVAL;
 
-	if (drm_mem_reg_is_pci(dev, mem)) {
+	if (psb_drm_mem_reg_is_pci(dev, mem)) {
 		*bus_offset = mem->mm_node->start << PAGE_SHIFT;
 		*bus_size = mem->num_pages << PAGE_SHIFT;
 		*bus_base = man->io_offset;
@@ -2596,7 +2596,7 @@
 		list->user_token = 0;
 	}
 	if (list->file_offset_node) {
-		drm_mm_put_block(list->file_offset_node);
+		psb_drm_mm_put_block(list->file_offset_node);
 		list->file_offset_node = NULL;
 	}
 
@@ -2604,10 +2604,10 @@
 	if (!map)
 		return;
 
-	drm_free(map, sizeof(*map), DRM_MEM_BUFOBJ);
+	psb_drm_free(map, sizeof(*map), DRM_MEM_BUFOBJ);
 	list->map = NULL;
 	list->user_token = 0ULL;
-	drm_bo_usage_deref_locked(&bo);
+	psb_drm_bo_usage_deref_locked(&bo);
 }
 
 static int drm_bo_setup_vm_locked(struct drm_buffer_object *bo)
@@ -2617,7 +2617,7 @@
 	struct drm_device *dev = bo->dev;
 
 	DRM_ASSERT_LOCKED(&dev->struct_mutex);
-	list->map = drm_calloc(1, sizeof(*map), DRM_MEM_BUFOBJ);
+	list->map = psb_drm_calloc(1, sizeof(*map), DRM_MEM_BUFOBJ);
 	if (!list->map)
 		return -ENOMEM;
 
diff -urNad psb-kernel-source-4.41.2/drm_bo_lock.c psb-kernel-source-4.41.2.drm_psb/drm_bo_lock.c
--- psb-kernel-source-4.41.2/drm_bo_lock.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_bo_lock.c	2010-05-02 10:13:42.523193905 +0200
@@ -66,14 +66,14 @@
 	atomic_set(&lock->readers, 0);
 }
 
-void drm_bo_read_unlock(struct drm_bo_lock *lock)
+void psb_drm_bo_read_unlock(struct drm_bo_lock *lock)
 {
 	if (atomic_dec_and_test(&lock->readers))
 		wake_up_all(&lock->queue);
 }
-EXPORT_SYMBOL(drm_bo_read_unlock);
+EXPORT_SYMBOL(psb_drm_bo_read_unlock);
 
-int drm_bo_read_lock(struct drm_bo_lock *lock, int interruptible)
+int psb_drm_bo_read_lock(struct drm_bo_lock *lock, int interruptible)
 {
 	while (unlikely(atomic_read(&lock->write_lock_pending) != 0)) {
 		int ret;
@@ -103,7 +103,7 @@
 	}
 	return 0;
 }
-EXPORT_SYMBOL(drm_bo_read_lock);
+EXPORT_SYMBOL(psb_drm_bo_read_lock);
 
 static int __drm_bo_write_unlock(struct drm_bo_lock *lock)
 {
@@ -157,7 +157,7 @@
 		wake_up_all(&lock->queue);
 	dev = file_priv->head->dev;
 	mutex_lock(&dev->struct_mutex);
-	ret = drm_add_user_object(file_priv, &lock->base, 0);
+	ret = psb_drm_add_user_object(file_priv, &lock->base, 0);
 	lock->base.remove = &drm_bo_write_lock_remove;
 	lock->base.type = drm_lock_type;
 	if (ret)
@@ -179,9 +179,9 @@
 		mutex_unlock(&dev->struct_mutex);
 		return -EINVAL;
 	}
-	ro = drm_lookup_ref_object(file_priv, &lock->base, _DRM_REF_USE);
+	ro = psb_drm_lookup_ref_object(file_priv, &lock->base, _DRM_REF_USE);
 	BUG_ON(!ro);
-	drm_remove_ref_object(file_priv, ro);
+	psb_drm_remove_ref_object(file_priv, ro);
 	lock->base.owner = NULL;
 
 	mutex_unlock(&dev->struct_mutex);
diff -urNad psb-kernel-source-4.41.2/drm_bo_move.c psb-kernel-source-4.41.2.drm_psb/drm_bo_move.c
--- psb-kernel-source-4.41.2/drm_bo_move.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_bo_move.c	2010-05-02 10:13:42.951191661 +0200
@@ -41,13 +41,13 @@
 
 	if (old_mem->mm_node && (old_mem->mm_node != bo->pinned_node)) {
 		mutex_lock(&bo->dev->struct_mutex);
-		drm_mm_put_block(old_mem->mm_node);
+		psb_drm_mm_put_block(old_mem->mm_node);
 		mutex_unlock(&bo->dev->struct_mutex);
 	}
 	old_mem->mm_node = NULL;
 }
 
-int drm_bo_move_ttm(struct drm_buffer_object *bo,
+int psb_drm_bo_move_ttm(struct drm_buffer_object *bo,
 		    int evict, int no_wait, struct drm_bo_mem_reg *new_mem)
 {
 	struct drm_ttm *ttm = bo->ttm;
@@ -70,7 +70,7 @@
 		save_flags = old_mem->flags;
 	}
 	if (new_mem->mem_type != DRM_BO_MEM_LOCAL) {
-		ret = drm_bind_ttm(ttm, new_mem);
+		ret = psb_drm_bind_ttm(ttm, new_mem);
 		if (ret)
 			return ret;
 	}
@@ -81,7 +81,7 @@
 	DRM_FLAG_MASKED(save_flags, new_mem->flags, DRM_BO_MASK_MEMTYPE);
 	return 0;
 }
-EXPORT_SYMBOL(drm_bo_move_ttm);
+EXPORT_SYMBOL(psb_drm_bo_move_ttm);
 
 /**
  * \c Return a kernel virtual address to the buffer object PCI memory.
@@ -98,7 +98,7 @@
  * Call bo->mutex locked.
  */
 
-int drm_mem_reg_ioremap(struct drm_device *dev, struct drm_bo_mem_reg *mem,
+int psb_drm_mem_reg_ioremap(struct drm_device *dev, struct drm_bo_mem_reg *mem,
 			void **virtual)
 {
 	struct drm_buffer_manager *bm = &dev->bm;
@@ -124,7 +124,7 @@
 	*virtual = addr;
 	return 0;
 }
-EXPORT_SYMBOL(drm_mem_reg_ioremap);
+EXPORT_SYMBOL(psb_drm_mem_reg_ioremap);
 
 /**
  * \c Unmap mapping obtained using drm_bo_ioremap
@@ -134,7 +134,7 @@
  * Call bo->mutex locked.
  */
 
-void drm_mem_reg_iounmap(struct drm_device *dev, struct drm_bo_mem_reg *mem,
+void psb_drm_mem_reg_iounmap(struct drm_device *dev, struct drm_bo_mem_reg *mem,
 			 void *virtual)
 {
 	struct drm_buffer_manager *bm;
@@ -146,7 +146,7 @@
 	if (virtual && (man->flags & _DRM_FLAG_NEEDS_IOREMAP))
 		iounmap(virtual);
 }
-EXPORT_SYMBOL(drm_mem_reg_iounmap);
+EXPORT_SYMBOL(psb_drm_mem_reg_iounmap);
 
 static int drm_copy_io_page(void *dst, void *src, unsigned long page)
 {
@@ -164,7 +164,7 @@
 static int drm_copy_io_ttm_page(struct drm_ttm *ttm, void *src,
 				unsigned long page)
 {
-	struct page *d = drm_ttm_get_page(ttm, page);
+	struct page *d = psb_drm_ttm_get_page(ttm, page);
 	void *dst;
 
 	if (!d)
@@ -182,7 +182,7 @@
 
 static int drm_copy_ttm_io_page(struct drm_ttm *ttm, void *dst, unsigned long page)
 {
-	struct page *s = drm_ttm_get_page(ttm, page);
+	struct page *s = psb_drm_ttm_get_page(ttm, page);
 	void *src;
 
 	if (!s)
@@ -198,7 +198,7 @@
 	return 0;
 }
 
-int drm_bo_move_memcpy(struct drm_buffer_object *bo,
+int psb_drm_bo_move_memcpy(struct drm_buffer_object *bo,
 		       int evict, int no_wait, struct drm_bo_mem_reg *new_mem)
 {
 	struct drm_device *dev = bo->dev;
@@ -216,10 +216,10 @@
 	unsigned long add = 0;
 	int dir;
 
-	ret = drm_mem_reg_ioremap(dev, old_mem, &old_iomap);
+	ret = psb_drm_mem_reg_ioremap(dev, old_mem, &old_iomap);
 	if (ret)
 		return ret;
-	ret = drm_mem_reg_ioremap(dev, new_mem, &new_iomap);
+	ret = psb_drm_mem_reg_ioremap(dev, new_mem, &new_iomap);
 	if (ret)
 		goto out;
 
@@ -265,12 +265,12 @@
 	}
 
 out1:
-	drm_mem_reg_iounmap(dev, new_mem, new_iomap);
+	psb_drm_mem_reg_iounmap(dev, new_mem, new_iomap);
 out:
-	drm_mem_reg_iounmap(dev, &old_copy, old_iomap);
+	psb_drm_mem_reg_iounmap(dev, &old_copy, old_iomap);
 	return ret;
 }
-EXPORT_SYMBOL(drm_bo_move_memcpy);
+EXPORT_SYMBOL(psb_drm_bo_move_memcpy);
 
 /*
  * Transfer a buffer object's memory and LRU status to a newly
@@ -285,7 +285,7 @@
 	struct drm_device *dev = bo->dev;
 	struct drm_buffer_manager *bm = &dev->bm;
 
-	fbo = drm_calloc(1, sizeof(*fbo), DRM_MEM_BUFOBJ);
+	fbo = psb_drm_calloc(1, sizeof(*fbo), DRM_MEM_BUFOBJ);
 	if (!fbo)
 		return -ENOMEM;
 
@@ -320,7 +320,7 @@
  * We cannot restart until it has finished.
  */
 
-int drm_bo_move_accel_cleanup(struct drm_buffer_object *bo,
+int psb_drm_bo_move_accel_cleanup(struct drm_buffer_object *bo,
 			      int evict, int no_wait, uint32_t fence_class,
 			      uint32_t fence_type, uint32_t fence_flags,
 			      struct drm_bo_mem_reg *new_mem)
@@ -334,8 +334,8 @@
 	struct drm_buffer_object *old_obj;
 
 	if (bo->fence)
-		drm_fence_usage_deref_unlocked(&bo->fence);
-	ret = drm_fence_object_create(dev, fence_class, fence_type,
+		psb_drm_fence_usage_deref_unlocked(&bo->fence);
+	ret = psb_drm_fence_object_create(dev, fence_class, fence_type,
 				      fence_flags | DRM_FENCE_FLAG_EMIT,
 				      &bo->fence);
 	bo->fence_type = fence_type;
@@ -357,7 +357,7 @@
 		      bo->mem.mm_node != NULL))
 #endif
 	{
-		ret = drm_bo_wait(bo, 0, 1, 0);
+		ret = psb_drm_bo_wait(bo, 0, 1, 0);
 		if (ret)
 			return ret;
 
@@ -392,7 +392,7 @@
 		DRM_FLAG_MASKED(bo->priv_flags, 0, _DRM_BO_FLAG_UNFENCED);
 		drm_bo_add_to_lru(old_obj);
 
-		drm_bo_usage_deref_locked(&old_obj);
+		psb_drm_bo_usage_deref_locked(&old_obj);
 		mutex_unlock(&dev->struct_mutex);
 
 	}
@@ -403,22 +403,22 @@
 	DRM_FLAG_MASKED(save_flags, new_mem->flags, DRM_BO_MASK_MEMTYPE);
 	return 0;
 }
-EXPORT_SYMBOL(drm_bo_move_accel_cleanup);
+EXPORT_SYMBOL(psb_drm_bo_move_accel_cleanup);
 
-int drm_bo_same_page(unsigned long offset,
+int psb_drm_bo_same_page(unsigned long offset,
 		     unsigned long offset2)
 {
 	return (offset & PAGE_MASK) == (offset2 & PAGE_MASK);
 }
-EXPORT_SYMBOL(drm_bo_same_page);
+EXPORT_SYMBOL(psb_drm_bo_same_page);
 
-unsigned long drm_bo_offset_end(unsigned long offset,
+unsigned long psb_drm_bo_offset_end(unsigned long offset,
 				unsigned long end)
 {
 	offset = (offset + PAGE_SIZE) & PAGE_MASK;
 	return (end < offset) ? end : offset;
 }
-EXPORT_SYMBOL(drm_bo_offset_end);
+EXPORT_SYMBOL(psb_drm_bo_offset_end);
 
 static pgprot_t drm_kernel_io_prot(uint32_t map_type)
 {
@@ -490,7 +490,7 @@
 		 */
 
 		map->bo_kmap_type = bo_map_kmap;
-		map->page = drm_ttm_get_page(ttm, start_page);
+		map->page = psb_drm_ttm_get_page(ttm, start_page);
 		map->virtual = kmap(map->page);
 	} else {
 		/*
@@ -498,7 +498,7 @@
 		 */
 
 		for (i = start_page; i < start_page + num_pages; ++i) {
-			d = drm_ttm_get_page(ttm, i);
+			d = psb_drm_ttm_get_page(ttm, i);
 			if (!d)
 				return -ENOMEM;
 		}
@@ -537,7 +537,7 @@
  * processes from consuming all vmalloc space.
  */
 
-int drm_bo_kmap(struct drm_buffer_object *bo, unsigned long start_page,
+int psb_drm_bo_kmap(struct drm_buffer_object *bo, unsigned long start_page,
 		unsigned long num_pages, struct drm_bo_kmap_obj *map)
 {
 	int ret;
@@ -569,9 +569,9 @@
 		return drm_bo_ioremap(bo, bus_base, bus_offset, bus_size, map);
 	}
 }
-EXPORT_SYMBOL(drm_bo_kmap);
+EXPORT_SYMBOL(psb_drm_bo_kmap);
 
-void drm_bo_kunmap(struct drm_bo_kmap_obj *map)
+void psb_drm_bo_kunmap(struct drm_bo_kmap_obj *map)
 {
 	if (!map->virtual)
 		return;
@@ -594,4 +594,4 @@
 	map->virtual = NULL;
 	map->page = NULL;
 }
-EXPORT_SYMBOL(drm_bo_kunmap);
+EXPORT_SYMBOL(psb_drm_bo_kunmap);
diff -urNad psb-kernel-source-4.41.2/drm_bufs.c psb-kernel-source-4.41.2.drm_psb/drm_bufs.c
--- psb-kernel-source-4.41.2/drm_bufs.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_bufs.c	2010-05-02 10:13:42.199193505 +0200
@@ -36,19 +36,19 @@
 #include <linux/vmalloc.h>
 #include "drmP.h"
 
-unsigned long drm_get_resource_start(struct drm_device *dev, unsigned int resource)
+unsigned long psb_drm_get_resource_start(struct drm_device *dev, unsigned int resource)
 {
 	return pci_resource_start(dev->pdev, resource);
 }
-EXPORT_SYMBOL(drm_get_resource_start);
+EXPORT_SYMBOL(psb_drm_get_resource_start);
 
-unsigned long drm_get_resource_len(struct drm_device *dev, unsigned int resource)
+unsigned long psb_drm_get_resource_len(struct drm_device *dev, unsigned int resource)
 {
 	return pci_resource_len(dev->pdev, resource);
 }
-EXPORT_SYMBOL(drm_get_resource_len);
+EXPORT_SYMBOL(psb_drm_get_resource_len);
 
-struct drm_map_list *drm_find_matching_map(struct drm_device *dev, drm_local_map_t *map)
+struct drm_map_list *psb_drm_find_matching_map(struct drm_device *dev, drm_local_map_t *map)
 {
 	struct drm_map_list *entry;
 	list_for_each_entry(entry, &dev->maplist, head) {
@@ -61,7 +61,7 @@
 
 	return NULL;
 }
-EXPORT_SYMBOL(drm_find_matching_map);
+EXPORT_SYMBOL(psb_drm_find_matching_map);
 
 static int drm_map_handle(struct drm_device *dev, struct drm_hash_item *hash,
 			  unsigned long user_token, int hashed_handle)
@@ -112,7 +112,7 @@
 	unsigned long user_token;
 	int ret;
 
-	map = drm_alloc(sizeof(*map), DRM_MEM_MAPS);
+	map = psb_drm_alloc(sizeof(*map), DRM_MEM_MAPS);
 	if (!map)
 		return -ENOMEM;
 
@@ -126,13 +126,13 @@
 	 * when processes fork.
 	 */
 	if ((map->flags & _DRM_REMOVABLE) && map->type != _DRM_SHM) {
-		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
 	DRM_DEBUG("offset = 0x%08lx, size = 0x%08lx, type = %d\n",
 		  map->offset, map->size, map->type);
 	if ((map->offset & (~PAGE_MASK)) || (map->size & (~PAGE_MASK))) {
-		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
 	map->mtrr = -1;
@@ -144,7 +144,7 @@
 #if !defined(__sparc__) && !defined(__alpha__) && !defined(__ia64__) && !defined(__powerpc64__) && !defined(__x86_64__)
 		if (map->offset + (map->size - 1) < map->offset ||
 		    map->offset < virt_to_phys(high_memory)) {
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -EINVAL;
 		}
 #endif
@@ -155,7 +155,7 @@
 		 * needing to be aware of it.  Therefore, we just return success
 		 * when the server tries to create a duplicate map.
 		 */
-		list = drm_find_matching_map(dev, map);
+		list = psb_drm_find_matching_map(dev, map);
 		if (list != NULL) {
 			if (list->map->size != map->size) {
 				DRM_DEBUG("Matching maps of type %d with "
@@ -165,7 +165,7 @@
 				list->map->size = map->size;
 			}
 
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			*maplist = list;
 			return 0;
 		}
@@ -180,13 +180,13 @@
 		if (map->type == _DRM_REGISTERS) {
 			map->handle = ioremap(map->offset, map->size);
 			if (!map->handle) {
-				drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+				psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 				return -ENOMEM;
 			}
 		}
 		break;
 	case _DRM_SHM:
-		list = drm_find_matching_map(dev, map);
+		list = psb_drm_find_matching_map(dev, map);
 		if (list != NULL) {
 			if(list->map->size != map->size) {
 				DRM_DEBUG("Matching maps of type %d with "
@@ -195,15 +195,15 @@
 				list->map->size = map->size;
 			}
 
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			*maplist = list;
 			return 0;
 		}
 		map->handle = vmalloc_user(map->size);
 		DRM_DEBUG("%lu %d %p\n",
-			  map->size, drm_order(map->size), map->handle);
+			  map->size, psb_drm_order(map->size), map->handle);
 		if (!map->handle) {
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -ENOMEM;
 		}
 		map->offset = (unsigned long)map->handle;
@@ -211,7 +211,7 @@
 			/* Prevent a 2nd X Server from creating a 2nd lock */
 			if (dev->lock.hw_lock != NULL) {
 				vfree(map->handle);
-				drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+				psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 				return -EBUSY;
 			}
 			dev->sigdata.lock = dev->lock.hw_lock = map->handle;	/* Pointer to lock */
@@ -222,7 +222,7 @@
 		int valid = 0;
 
 		if (!drm_core_has_AGP(dev)) {
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -EINVAL;
 		}
 #ifdef __alpha__
@@ -255,7 +255,7 @@
 			}
 		}
 		if (!list_empty(&dev->agp->memory) && !valid) {
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -EPERM;
 		}
 		DRM_DEBUG("AGP offset = 0x%08lx, size = 0x%08lx\n", map->offset, map->size);
@@ -263,7 +263,7 @@
 	}
 	case _DRM_SCATTER_GATHER:
 		if (!dev->sg) {
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -EINVAL;
 		}
 		map->offset += (unsigned long)dev->sg->virtual;
@@ -273,9 +273,9 @@
 		 * As we're limiting the address to 2^32-1 (or less),
 		 * casting it down to 32 bits is no problem, but we
 		 * need to point to a 64bit variable first. */
-		dmah = drm_pci_alloc(dev, map->size, map->size, 0xffffffffUL);
+		dmah = psb_drm_pci_alloc(dev, map->size, map->size, 0xffffffffUL);
 		if (!dmah) {
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 			return -ENOMEM;
 		}
 		map->handle = dmah->vaddr;
@@ -283,15 +283,15 @@
 		kfree(dmah);
 		break;
 	default:
-		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
 
-	list = drm_alloc(sizeof(*list), DRM_MEM_MAPS);
+	list = psb_drm_alloc(sizeof(*list), DRM_MEM_MAPS);
 	if (!list) {
 		if (map->type == _DRM_REGISTERS)
 			iounmap(map->handle);
-		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		return -EINVAL;
 	}
 	memset(list, 0, sizeof(*list));
@@ -309,8 +309,8 @@
 	if (ret) {
 		if (map->type == _DRM_REGISTERS)
 			iounmap(map->handle);
-		drm_free(map, sizeof(*map), DRM_MEM_MAPS);
-		drm_free(list, sizeof(*list), DRM_MEM_MAPS);
+		psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+		psb_drm_free(list, sizeof(*list), DRM_MEM_MAPS);
 		mutex_unlock(&dev->struct_mutex);
 		return ret;
 	}
@@ -322,7 +322,7 @@
 	return 0;
 }
 
-int drm_addmap(struct drm_device *dev, unsigned int offset,
+int psb_drm_addmap(struct drm_device *dev, unsigned int offset,
 	       unsigned int size, enum drm_map_type type,
 	       enum drm_map_flags flags, drm_local_map_t ** map_ptr)
 {
@@ -335,7 +335,7 @@
 	return rc;
 }
 
-EXPORT_SYMBOL(drm_addmap);
+EXPORT_SYMBOL(psb_drm_addmap);
 
 int drm_addmap_ioctl(struct drm_device *dev, void *data,
 		     struct drm_file *file_priv)
@@ -372,9 +372,9 @@
  * its being used, and free any associate resource (such as MTRR's) if it's not
  * being on use.
  *
- * \sa drm_addmap
+ * \sa psb_drm_addmap
  */
-int drm_rmmap_locked(struct drm_device *dev, drm_local_map_t *map)
+int psb_drm_rmmap_locked(struct drm_device *dev, drm_local_map_t *map)
 {
 	struct drm_map_list *r_list = NULL, *list_t;
 	drm_dma_handle_t dmah;
@@ -386,7 +386,7 @@
 			list_del(&r_list->head);
 			drm_ht_remove_key(&dev->map_hash,
 					  r_list->user_token >> PAGE_SHIFT);
-			drm_free(r_list, sizeof(*r_list), DRM_MEM_MAPS);
+			psb_drm_free(r_list, sizeof(*r_list), DRM_MEM_MAPS);
 			found = 1;
 			break;
 		}
@@ -426,23 +426,23 @@
 	case _DRM_TTM:
 		BUG_ON(1);
 	}
-	drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+	psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_rmmap_locked);
+EXPORT_SYMBOL(psb_drm_rmmap_locked);
 
-int drm_rmmap(struct drm_device *dev, drm_local_map_t *map)
+int psb_drm_rmmap(struct drm_device *dev, drm_local_map_t *map)
 {
 	int ret;
 
 	mutex_lock(&dev->struct_mutex);
-	ret = drm_rmmap_locked(dev, map);
+	ret = psb_drm_rmmap_locked(dev, map);
 	mutex_unlock(&dev->struct_mutex);
 
 	return ret;
 }
-EXPORT_SYMBOL(drm_rmmap);
+EXPORT_SYMBOL(psb_drm_rmmap);
 
 /* The rmmap ioctl appears to be unnecessary.  All mappings are torn down on
  * the last close of the device, and this is necessary for cleanup when things
@@ -485,7 +485,7 @@
 		return 0;
 	}
 
-	ret = drm_rmmap_locked(dev, map);
+	ret = psb_drm_rmmap_locked(dev, map);
 
 	mutex_unlock(&dev->struct_mutex);
 
@@ -508,10 +508,10 @@
 	if (entry->seg_count) {
 		for (i = 0; i < entry->seg_count; i++) {
 			if (entry->seglist[i]) {
-				drm_pci_free(dev, entry->seglist[i]);
+				psb_drm_pci_free(dev, entry->seglist[i]);
 			}
 		}
-		drm_free(entry->seglist,
+		psb_drm_free(entry->seglist,
 			 entry->seg_count *
 			 sizeof(*entry->seglist), DRM_MEM_SEGS);
 
@@ -521,12 +521,12 @@
 	if (entry->buf_count) {
 		for (i = 0; i < entry->buf_count; i++) {
 			if (entry->buflist[i].dev_private) {
-				drm_free(entry->buflist[i].dev_private,
+				psb_drm_free(entry->buflist[i].dev_private,
 					 entry->buflist[i].dev_priv_size,
 					 DRM_MEM_BUFS);
 			}
 		}
-		drm_free(entry->buflist,
+		psb_drm_free(entry->buflist,
 			 entry->buf_count *
 			 sizeof(*entry->buflist), DRM_MEM_BUFS);
 
@@ -546,7 +546,7 @@
  * reallocates the buffer list of the same size order to accommodate the new
  * buffers.
  */
-int drm_addbufs_agp(struct drm_device *dev, struct drm_buf_desc *request)
+int psb_drm_addbufs_agp(struct drm_device *dev, struct drm_buf_desc *request)
 {
 	struct drm_device_dma *dma = dev->dma;
 	struct drm_buf_entry *entry;
@@ -568,7 +568,7 @@
 		return -EINVAL;
 
 	count = request->count;
-	order = drm_order(request->size);
+	order = psb_drm_order(request->size);
 	size = 1 << order;
 
 	alignment = (request->flags & _DRM_PAGE_ALIGN)
@@ -627,7 +627,7 @@
 		return -EINVAL;
 	}
 
-	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+	entry->buflist = psb_drm_alloc(count * sizeof(*entry->buflist),
 				   DRM_MEM_BUFS);
 	if (!entry->buflist) {
 		mutex_unlock(&dev->struct_mutex);
@@ -658,7 +658,7 @@
 		buf->file_priv = NULL;
 
 		buf->dev_priv_size = dev->driver->dev_priv_size;
-		buf->dev_private = drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
+		buf->dev_private = psb_drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
 		if (!buf->dev_private) {
 			/* Set count correctly so we free the proper amount. */
 			entry->buf_count = count;
@@ -678,7 +678,7 @@
 
 	DRM_DEBUG("byte_count: %d\n", byte_count);
 
-	temp_buflist = drm_realloc(dma->buflist,
+	temp_buflist = psb_drm_realloc(dma->buflist,
 				   dma->buf_count * sizeof(*dma->buflist),
 				   (dma->buf_count + entry->buf_count)
 				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
@@ -713,10 +713,10 @@
 	atomic_dec(&dev->buf_alloc);
 	return 0;
 }
-EXPORT_SYMBOL(drm_addbufs_agp);
+EXPORT_SYMBOL(psb_drm_addbufs_agp);
 #endif				/* __OS_HAS_AGP */
 
-int drm_addbufs_pci(struct drm_device *dev, struct drm_buf_desc *request)
+int psb_drm_addbufs_pci(struct drm_device *dev, struct drm_buf_desc *request)
 {
 	struct drm_device_dma *dma = dev->dma;
 	int count;
@@ -745,7 +745,7 @@
 		return -EPERM;
 
 	count = request->count;
-	order = drm_order(request->size);
+	order = psb_drm_order(request->size);
 	size = 1 << order;
 
 	DRM_DEBUG("count=%d, size=%d (%d), order=%d, queue_count=%d\n",
@@ -783,7 +783,7 @@
 		return -EINVAL;
 	}
 
-	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+	entry->buflist = psb_drm_alloc(count * sizeof(*entry->buflist),
 				   DRM_MEM_BUFS);
 	if (!entry->buflist) {
 		mutex_unlock(&dev->struct_mutex);
@@ -792,10 +792,10 @@
 	}
 	memset(entry->buflist, 0, count * sizeof(*entry->buflist));
 
-	entry->seglist = drm_alloc(count * sizeof(*entry->seglist),
+	entry->seglist = psb_drm_alloc(count * sizeof(*entry->seglist),
 				   DRM_MEM_SEGS);
 	if (!entry->seglist) {
-		drm_free(entry->buflist,
+		psb_drm_free(entry->buflist,
 			 count * sizeof(*entry->buflist), DRM_MEM_BUFS);
 		mutex_unlock(&dev->struct_mutex);
 		atomic_dec(&dev->buf_alloc);
@@ -806,12 +806,12 @@
 	/* Keep the original pagelist until we know all the allocations
 	 * have succeeded
 	 */
-	temp_pagelist = drm_alloc((dma->page_count + (count << page_order))
+	temp_pagelist = psb_drm_alloc((dma->page_count + (count << page_order))
 				  * sizeof(*dma->pagelist), DRM_MEM_PAGES);
 	if (!temp_pagelist) {
-		drm_free(entry->buflist,
+		psb_drm_free(entry->buflist,
 			 count * sizeof(*entry->buflist), DRM_MEM_BUFS);
-		drm_free(entry->seglist,
+		psb_drm_free(entry->seglist,
 			 count * sizeof(*entry->seglist), DRM_MEM_SEGS);
 		mutex_unlock(&dev->struct_mutex);
 		atomic_dec(&dev->buf_alloc);
@@ -829,14 +829,14 @@
 
 	while (entry->buf_count < count) {
 
-		dmah = drm_pci_alloc(dev, PAGE_SIZE << page_order, 0x1000, 0xfffffffful);
+		dmah = psb_drm_pci_alloc(dev, PAGE_SIZE << page_order, 0x1000, 0xfffffffful);
 
 		if (!dmah) {
 			/* Set count correctly so we free the proper amount. */
 			entry->buf_count = count;
 			entry->seg_count = count;
 			drm_cleanup_buf_error(dev, entry);
-			drm_free(temp_pagelist,
+			psb_drm_free(temp_pagelist,
 				 (dma->page_count + (count << page_order))
 				 * sizeof(*dma->pagelist), DRM_MEM_PAGES);
 			mutex_unlock(&dev->struct_mutex);
@@ -869,14 +869,14 @@
 			buf->file_priv = NULL;
 
 			buf->dev_priv_size = dev->driver->dev_priv_size;
-			buf->dev_private = drm_alloc(buf->dev_priv_size,
+			buf->dev_private = psb_drm_alloc(buf->dev_priv_size,
 						     DRM_MEM_BUFS);
 			if (!buf->dev_private) {
 				/* Set count correctly so we free the proper amount. */
 				entry->buf_count = count;
 				entry->seg_count = count;
 				drm_cleanup_buf_error(dev, entry);
-				drm_free(temp_pagelist,
+				psb_drm_free(temp_pagelist,
 					 (dma->page_count +
 					  (count << page_order))
 					 * sizeof(*dma->pagelist),
@@ -893,14 +893,14 @@
 		byte_count += PAGE_SIZE << page_order;
 	}
 
-	temp_buflist = drm_realloc(dma->buflist,
+	temp_buflist = psb_drm_realloc(dma->buflist,
 				   dma->buf_count * sizeof(*dma->buflist),
 				   (dma->buf_count + entry->buf_count)
 				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
 	if (!temp_buflist) {
 		/* Free the entry because it isn't valid */
 		drm_cleanup_buf_error(dev, entry);
-		drm_free(temp_pagelist,
+		psb_drm_free(temp_pagelist,
 			 (dma->page_count + (count << page_order))
 			 * sizeof(*dma->pagelist), DRM_MEM_PAGES);
 		mutex_unlock(&dev->struct_mutex);
@@ -917,7 +917,7 @@
 	 * with the new one.
 	 */
 	if (dma->page_count) {
-		drm_free(dma->pagelist,
+		psb_drm_free(dma->pagelist,
 			 dma->page_count * sizeof(*dma->pagelist),
 			 DRM_MEM_PAGES);
 	}
@@ -940,7 +940,7 @@
 	return 0;
 
 }
-EXPORT_SYMBOL(drm_addbufs_pci);
+EXPORT_SYMBOL(psb_drm_addbufs_pci);
 
 static int drm_addbufs_sg(struct drm_device *dev, struct drm_buf_desc *request)
 {
@@ -969,7 +969,7 @@
 		return -EPERM;
 
 	count = request->count;
-	order = drm_order(request->size);
+	order = psb_drm_order(request->size);
 	size = 1 << order;
 
 	alignment = (request->flags & _DRM_PAGE_ALIGN)
@@ -1015,7 +1015,7 @@
 		return -EINVAL;
 	}
 
-	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+	entry->buflist = psb_drm_alloc(count * sizeof(*entry->buflist),
 				   DRM_MEM_BUFS);
 	if (!entry->buflist) {
 		mutex_unlock(&dev->struct_mutex);
@@ -1047,7 +1047,7 @@
 		buf->file_priv = NULL;
 
 		buf->dev_priv_size = dev->driver->dev_priv_size;
-		buf->dev_private = drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
+		buf->dev_private = psb_drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
 		if (!buf->dev_private) {
 			/* Set count correctly so we free the proper amount. */
 			entry->buf_count = count;
@@ -1068,7 +1068,7 @@
 
 	DRM_DEBUG("byte_count: %d\n", byte_count);
 
-	temp_buflist = drm_realloc(dma->buflist,
+	temp_buflist = psb_drm_realloc(dma->buflist,
 				   dma->buf_count * sizeof(*dma->buflist),
 				   (dma->buf_count + entry->buf_count)
 				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
@@ -1104,7 +1104,7 @@
 	return 0;
 }
 
-int drm_addbufs_fb(struct drm_device *dev, struct drm_buf_desc *request)
+int psb_drm_addbufs_fb(struct drm_device *dev, struct drm_buf_desc *request)
 {
 	struct drm_device_dma *dma = dev->dma;
 	struct drm_buf_entry *entry;
@@ -1131,7 +1131,7 @@
 		return -EPERM;
 
 	count = request->count;
-	order = drm_order(request->size);
+	order = psb_drm_order(request->size);
 	size = 1 << order;
 
 	alignment = (request->flags & _DRM_PAGE_ALIGN)
@@ -1177,7 +1177,7 @@
 		return -EINVAL;
 	}
 
-	entry->buflist = drm_alloc(count * sizeof(*entry->buflist),
+	entry->buflist = psb_drm_alloc(count * sizeof(*entry->buflist),
 				   DRM_MEM_BUFS);
 	if (!entry->buflist) {
 		mutex_unlock(&dev->struct_mutex);
@@ -1208,7 +1208,7 @@
 		buf->file_priv = NULL;
 
 		buf->dev_priv_size = dev->driver->dev_priv_size;
-		buf->dev_private = drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
+		buf->dev_private = psb_drm_alloc(buf->dev_priv_size, DRM_MEM_BUFS);
 		if (!buf->dev_private) {
 			/* Set count correctly so we free the proper amount. */
 			entry->buf_count = count;
@@ -1228,7 +1228,7 @@
 
 	DRM_DEBUG("byte_count: %d\n", byte_count);
 
-	temp_buflist = drm_realloc(dma->buflist,
+	temp_buflist = psb_drm_realloc(dma->buflist,
 				   dma->buf_count * sizeof(*dma->buflist),
 				   (dma->buf_count + entry->buf_count)
 				   * sizeof(*dma->buflist), DRM_MEM_BUFS);
@@ -1263,7 +1263,7 @@
 	atomic_dec(&dev->buf_alloc);
 	return 0;
 }
-EXPORT_SYMBOL(drm_addbufs_fb);
+EXPORT_SYMBOL(psb_drm_addbufs_fb);
 
 
 /**
@@ -1291,15 +1291,15 @@
 
 #if __OS_HAS_AGP
 	if (request->flags & _DRM_AGP_BUFFER)
-		ret = drm_addbufs_agp(dev, request);
+		ret = psb_drm_addbufs_agp(dev, request);
 	else
 #endif
 	if (request->flags & _DRM_SG_BUFFER)
 		ret = drm_addbufs_sg(dev, request);
 	else if (request->flags & _DRM_FB_BUFFER)
-		ret = drm_addbufs_fb(dev, request);
+		ret = psb_drm_addbufs_fb(dev, request);
 	else
-		ret = drm_addbufs_pci(dev, request);
+		ret = psb_drm_addbufs_pci(dev, request);
 
 	return ret;
 }
@@ -1416,7 +1416,7 @@
 
 	DRM_DEBUG("%d, %d, %d\n",
 		  request->size, request->low_mark, request->high_mark);
-	order = drm_order(request->size);
+	order = psb_drm_order(request->size);
 	if (order < DRM_MIN_ORDER || order > DRM_MAX_ORDER)
 		return -EINVAL;
 	entry = &dma->bufs[order];
@@ -1491,7 +1491,7 @@
  *
  * Maps the AGP, SG or PCI buffer region with do_mmap(), and copies information
  * about each buffer into user space. For PCI buffers, it calls do_mmap() with
- * offset equal to 0, which drm_mmap() interpretes as PCI buffers and calls
+ * offset equal to 0, which psb_drm_mmap() interpretes as PCI buffers and calls
  * drm_mmap_dma().
  */
 int drm_mapbufs(struct drm_device *dev, void *data,
@@ -1594,7 +1594,7 @@
  *
  * \todo Can be made faster.
  */
-int drm_order(unsigned long size)
+int psb_drm_order(unsigned long size)
 {
 	int order;
 	unsigned long tmp;
@@ -1606,4 +1606,4 @@
 
 	return order;
 }
-EXPORT_SYMBOL(drm_order);
+EXPORT_SYMBOL(psb_drm_order);
diff -urNad psb-kernel-source-4.41.2/drm_context.c psb-kernel-source-4.41.2.drm_psb/drm_context.c
--- psb-kernel-source-4.41.2/drm_context.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_context.c	2010-05-02 10:13:41.887191552 +0200
@@ -341,7 +341,7 @@
 			}
 	}
 
-	ctx_entry = drm_alloc(sizeof(*ctx_entry), DRM_MEM_CTXLIST);
+	ctx_entry = psb_drm_alloc(sizeof(*ctx_entry), DRM_MEM_CTXLIST);
 	if (!ctx_entry) {
 		DRM_DEBUG("out of memory\n");
 		return -ENOMEM;
@@ -459,7 +459,7 @@
 		list_for_each_entry_safe(pos, n, &dev->ctxlist, head) {
 			if (pos->handle == ctx->handle) {
 				list_del(&pos->head);
-				drm_free(pos, sizeof(*pos), DRM_MEM_CTXLIST);
+				psb_drm_free(pos, sizeof(*pos), DRM_MEM_CTXLIST);
 				--dev->ctx_count;
 			}
 		}
diff -urNad psb-kernel-source-4.41.2/drm_crtc.c psb-kernel-source-4.41.2.drm_psb/drm_crtc.c
--- psb-kernel-source-4.41.2/drm_crtc.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_crtc.c	2010-05-02 10:13:44.375193313 +0200
@@ -106,7 +106,7 @@
 }
 
 /**
- * drm_framebuffer_create - create a new framebuffer object
+ * psb_drm_framebuffer_create - create a new framebuffer object
  * @dev: DRM device
  *
  * LOCKING:
@@ -117,7 +117,7 @@
  * RETURNS:
  * Pointer to new framebuffer or NULL on error.
  */
-struct drm_framebuffer *drm_framebuffer_create(struct drm_device *dev)
+struct drm_framebuffer *psb_drm_framebuffer_create(struct drm_device *dev)
 {
 	struct drm_framebuffer *fb;
 
@@ -139,10 +139,10 @@
 
 	return fb;
 }
-EXPORT_SYMBOL(drm_framebuffer_create);
+EXPORT_SYMBOL(psb_drm_framebuffer_create);
 
 /**
- * drm_framebuffer_destroy - remove a framebuffer object
+ * psb_drm_framebuffer_destroy - remove a framebuffer object
  * @fb: framebuffer to remove
  *
  * LOCKING:
@@ -151,7 +151,7 @@
  * Scans all the CRTCs in @dev's mode_config.  If they're using @fb, removes
  * it, setting it to NULL.
  */
-void drm_framebuffer_destroy(struct drm_framebuffer *fb)
+void psb_drm_framebuffer_destroy(struct drm_framebuffer *fb)
 {
 	struct drm_device *dev = fb->dev;
 	struct drm_crtc *crtc;
@@ -168,10 +168,10 @@
 
 	kfree(fb);
 }
-EXPORT_SYMBOL(drm_framebuffer_destroy);
+EXPORT_SYMBOL(psb_drm_framebuffer_destroy);
 
 /**
- * drm_crtc_create - create a new CRTC object
+ * psb_drm_crtc_create - create a new CRTC object
  * @dev: DRM device
  * @funcs: callbacks for the new CRTC
  *
@@ -183,7 +183,7 @@
  * RETURNS:
  * Pointer to new CRTC object or NULL on error.
  */
-struct drm_crtc *drm_crtc_create(struct drm_device *dev,
+struct drm_crtc *psb_drm_crtc_create(struct drm_device *dev,
 				 const struct drm_crtc_funcs *funcs)
 {
 	struct drm_crtc *crtc;
@@ -202,10 +202,10 @@
 
 	return crtc;
 }
-EXPORT_SYMBOL(drm_crtc_create);
+EXPORT_SYMBOL(psb_drm_crtc_create);
 
 /**
- * drm_crtc_destroy - remove a CRTC object
+ * psb_drm_crtc_destroy - remove a CRTC object
  * @crtc: CRTC to remove
  *
  * LOCKING:
@@ -214,7 +214,7 @@
  * Cleanup @crtc.  Calls @crtc's cleanup function, then removes @crtc from
  * its associated DRM device's mode_config.  Frees it afterwards.
  */
-void drm_crtc_destroy(struct drm_crtc *crtc)
+void psb_drm_crtc_destroy(struct drm_crtc *crtc)
 {
 	struct drm_device *dev = crtc->dev;
 
@@ -226,10 +226,10 @@
 	dev->mode_config.num_crtc--;
 	kfree(crtc);
 }
-EXPORT_SYMBOL(drm_crtc_destroy);
+EXPORT_SYMBOL(psb_drm_crtc_destroy);
 
 /**
- * drm_crtc_in_use - check if a given CRTC is in a mode_config
+ * psb_drm_crtc_in_use - check if a given CRTC is in a mode_config
  * @crtc: CRTC to check
  *
  * LOCKING:
@@ -240,7 +240,7 @@
  * RETURNS:
  * True if @crtc is part of the mode_config, false otherwise.
  */
-bool drm_crtc_in_use(struct drm_crtc *crtc)
+bool psb_drm_crtc_in_use(struct drm_crtc *crtc)
 {
 	struct drm_output *output;
 	struct drm_device *dev = crtc->dev;
@@ -250,7 +250,7 @@
 			return true;
 	return false;
 }
-EXPORT_SYMBOL(drm_crtc_in_use);
+EXPORT_SYMBOL(psb_drm_crtc_in_use);
 
 /*
  * Detailed mode info for a standard 640x480@60Hz monitor
@@ -262,7 +262,7 @@
 };
 
 /**
- * drm_crtc_probe_output_modes - get complete set of display modes
+ * psb_drm_crtc_probe_output_modes - get complete set of display modes
  * @dev: DRM device
  * @maxX: max width for modes
  * @maxY: max height for modes
@@ -280,7 +280,7 @@
  *
  * FIXME: take into account monitor limits
  */
-void drm_crtc_probe_output_modes(struct drm_device *dev, int maxX, int maxY)
+void psb_drm_crtc_probe_output_modes(struct drm_device *dev, int maxX, int maxY)
 {
 	struct drm_output *output;
 	struct drm_display_mode *mode, *t;
@@ -309,7 +309,7 @@
 		}
 
 		if (maxX && maxY)
-			drm_mode_validate_size(dev, &output->modes, maxX,
+			psb_drm_mode_validate_size(dev, &output->modes, maxX,
 					       maxY, 0);
 		list_for_each_entry_safe(mode, t, &output->modes, head) {
 			if (mode->status == MODE_OK)
@@ -329,8 +329,8 @@
 			 * here and bailed in the past, now we add a standard
 			 * 640x480@60Hz mode and carry on.
 			 */
-			stdmode = drm_mode_duplicate(dev, &std_mode[0]);
-			drm_mode_probed_add(output, stdmode);
+			stdmode = psb_drm_mode_duplicate(dev, &std_mode[0]);
+			psb_drm_mode_probed_add(output, stdmode);
 			drm_mode_list_concat(&output->probed_modes,
 					     &output->modes);
 
@@ -342,17 +342,17 @@
 
 		DRM_DEBUG("Probed modes for %s\n", output->name);
 		list_for_each_entry_safe(mode, t, &output->modes, head) {
-			mode->vrefresh = drm_mode_vrefresh(mode);
+			mode->vrefresh = psb_drm_mode_vrefresh(mode);
 
-			drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
-			drm_mode_debug_printmodeline(dev, mode);
+			psb_drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
+			psb_drm_mode_debug_printmodeline(dev, mode);
 		}
 	}
 }
-EXPORT_SYMBOL(drm_crtc_probe_output_modes);
+EXPORT_SYMBOL(psb_drm_crtc_probe_output_modes);
 
 /**
- * drm_crtc_set_mode - set a mode
+ * psb_drm_crtc_set_mode - set a mode
  * @crtc: CRTC to program
  * @mode: mode to use
  * @x: width of mode
@@ -367,7 +367,7 @@
  * RETURNS:
  * True if the mode was set successfully, or false otherwise.
  */
-bool drm_crtc_set_mode(struct drm_crtc *crtc, struct drm_display_mode *mode,
+bool psb_drm_crtc_set_mode(struct drm_crtc *crtc, struct drm_display_mode *mode,
 		       int x, int y)
 {
 	struct drm_device *dev = crtc->dev;
@@ -377,9 +377,9 @@
 	bool ret = false;
 	struct drm_output *output;
 
-	adjusted_mode = drm_mode_duplicate(dev, mode);
+	adjusted_mode = psb_drm_mode_duplicate(dev, mode);
 
-	crtc->enabled = drm_crtc_in_use(crtc);
+	crtc->enabled = psb_drm_crtc_in_use(crtc);
 
 	if (!crtc->enabled) {
 		return true;
@@ -462,7 +462,7 @@
 	}
 	
 	/* XXX free adjustedmode */
-	drm_mode_destroy(dev, adjusted_mode);
+	psb_drm_mode_destroy(dev, adjusted_mode);
 	ret = TRUE;
 	/* TODO */
 //	if (scrn->pScreen)
@@ -480,10 +480,10 @@
 	
 	return ret;
 }
-EXPORT_SYMBOL(drm_crtc_set_mode);
+EXPORT_SYMBOL(psb_drm_crtc_set_mode);
 
 /**
- * drm_disable_unused_functions - disable unused objects
+ * psb_drm_disable_unused_functions - disable unused objects
  * @dev: DRM device
  *
  * LOCKING:
@@ -492,7 +492,7 @@
  * If an output or CRTC isn't part of @dev's mode_config, it can be disabled
  * by calling its dpms function, which should power it off.
  */
-void drm_disable_unused_functions(struct drm_device *dev)
+void psb_drm_disable_unused_functions(struct drm_device *dev)
 {
 	struct drm_output *output;
 	struct drm_crtc *crtc;
@@ -507,10 +507,10 @@
 			crtc->funcs->dpms(crtc, DPMSModeOff);
 	}
 }
-EXPORT_SYMBOL(drm_disable_unused_functions);
+EXPORT_SYMBOL(psb_drm_disable_unused_functions);
 
 /**
- * drm_mode_probed_add - add a mode to the specified output's probed mode list
+ * psb_drm_mode_probed_add - add a mode to the specified output's probed mode list
  * @output: output the new mode
  * @mode: mode data
  *
@@ -519,15 +519,15 @@
  * 
  * Add @mode to @output's mode list for later use.
  */
-void drm_mode_probed_add(struct drm_output *output,
+void psb_drm_mode_probed_add(struct drm_output *output,
 			 struct drm_display_mode *mode)
 {
 	list_add(&mode->head, &output->probed_modes);
 }
-EXPORT_SYMBOL(drm_mode_probed_add);
+EXPORT_SYMBOL(psb_drm_mode_probed_add);
 
 /**
- * drm_mode_remove - remove and free a mode
+ * psb_drm_mode_remove - remove and free a mode
  * @output: output list to modify
  * @mode: mode to remove
  *
@@ -536,15 +536,15 @@
  * 
  * Remove @mode from @output's mode list, then free it.
  */
-void drm_mode_remove(struct drm_output *output, struct drm_display_mode *mode)
+void psb_drm_mode_remove(struct drm_output *output, struct drm_display_mode *mode)
 {
 	list_del(&mode->head);
 	kfree(mode);
 }
-EXPORT_SYMBOL(drm_mode_remove);
+EXPORT_SYMBOL(psb_drm_mode_remove);
 
 /**
- * drm_output_create - create a new output
+ * psb_drm_output_create - create a new output
  * @dev: DRM device
  * @funcs: callbacks for this output
  * @name: user visible name of the output
@@ -558,7 +558,7 @@
  * RETURNS:
  * Pointer to the new output or NULL on error.
  */
-struct drm_output *drm_output_create(struct drm_device *dev,
+struct drm_output *psb_drm_output_create(struct drm_device *dev,
 				     const struct drm_output_funcs *funcs,
 				     const char *name)
 {
@@ -590,10 +590,10 @@
 	return output;
 
 }
-EXPORT_SYMBOL(drm_output_create);
+EXPORT_SYMBOL(psb_drm_output_create);
 
 /**
- * drm_output_destroy - remove an output
+ * psb_drm_output_destroy - remove an output
  * @output: output to remove
  *
  * LOCKING:
@@ -602,7 +602,7 @@
  * Call @output's cleanup function, then remove the output from the DRM
  * mode_config after freeing @output's modes.
  */
-void drm_output_destroy(struct drm_output *output)
+void psb_drm_output_destroy(struct drm_output *output)
 {
 	struct drm_device *dev = output->dev;
 	struct drm_display_mode *mode, *t;
@@ -611,10 +611,10 @@
 		(*output->funcs->cleanup)(output);
 
 	list_for_each_entry_safe(mode, t, &output->probed_modes, head)
-		drm_mode_remove(output, mode);
+		psb_drm_mode_remove(output, mode);
 
 	list_for_each_entry_safe(mode, t, &output->modes, head)
-		drm_mode_remove(output, mode);
+		psb_drm_mode_remove(output, mode);
 
 	mutex_lock(&dev->mode_config.mutex);
 	drm_idr_put(dev, output->id);
@@ -622,10 +622,10 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	kfree(output);
 }
-EXPORT_SYMBOL(drm_output_destroy);
+EXPORT_SYMBOL(psb_drm_output_destroy);
 
 /**
- * drm_output_rename - rename an output
+ * psb_drm_output_rename - rename an output
  * @output: output to rename
  * @name: new user visible name
  *
@@ -637,7 +637,7 @@
  * RETURNS:
  * True if the name was changed, false otherwise.
  */
-bool drm_output_rename(struct drm_output *output, const char *name)
+bool psb_drm_output_rename(struct drm_output *output, const char *name)
 {
 	if (!name)
 		return false;
@@ -652,10 +652,10 @@
 
 	return TRUE;
 }
-EXPORT_SYMBOL(drm_output_rename);
+EXPORT_SYMBOL(psb_drm_output_rename);
 
 /**
- * drm_mode_create - create a new display mode
+ * psb_drm_mode_create - create a new display mode
  * @dev: DRM device
  *
  * LOCKING:
@@ -666,7 +666,7 @@
  * RETURNS:
  * Pointer to new mode on success, NULL on error.
  */
-struct drm_display_mode *drm_mode_create(struct drm_device *dev)
+struct drm_display_mode *psb_drm_mode_create(struct drm_device *dev)
 {
 	struct drm_display_mode *nmode;
 
@@ -677,10 +677,10 @@
 	nmode->mode_id = drm_idr_get(dev, nmode);
 	return nmode;
 }
-EXPORT_SYMBOL(drm_mode_create);
+EXPORT_SYMBOL(psb_drm_mode_create);
 
 /**
- * drm_mode_destroy - remove a mode
+ * psb_drm_mode_destroy - remove a mode
  * @dev: DRM device
  * @mode: mode to remove
  *
@@ -689,16 +689,16 @@
  *
  * Free @mode's unique identifier, then free it.
  */
-void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)
+void psb_drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)
 {
 	drm_idr_put(dev, mode->mode_id);
 
 	kfree(mode);
 }
-EXPORT_SYMBOL(drm_mode_destroy);
+EXPORT_SYMBOL(psb_drm_mode_destroy);
 
 /**
- * drm_mode_config_init - initialize DRM mode_configuration structure
+ * psb_drm_mode_config_init - initialize DRM mode_configuration structure
  * @dev: DRM device
  *
  * LOCKING:
@@ -707,7 +707,7 @@
  * Initialize @dev's mode_config structure, used for tracking the graphics
  * configuration of @dev.
  */
-void drm_mode_config_init(struct drm_device *dev)
+void psb_drm_mode_config_init(struct drm_device *dev)
 {
 	mutex_init(&dev->mode_config.mutex);
 	INIT_LIST_HEAD(&dev->mode_config.fb_list);
@@ -717,7 +717,7 @@
 	INIT_LIST_HEAD(&dev->mode_config.usermode_list);
 	idr_init(&dev->mode_config.crtc_idr);
 }
-EXPORT_SYMBOL(drm_mode_config_init);
+EXPORT_SYMBOL(psb_drm_mode_config_init);
 
 /**
  * drm_get_buffer_object - find the buffer object for a given handle
@@ -763,21 +763,21 @@
 	return ret;
 }
 
-char drm_init_mode[32];
-int drm_init_xres;
-int drm_init_yres;
-EXPORT_SYMBOL(drm_init_mode);
-EXPORT_SYMBOL(drm_init_xres);
-EXPORT_SYMBOL(drm_init_yres);
+char psb_drm_init_mode[32];
+int psb_drm_init_xres;
+int psb_drm_init_yres;
+EXPORT_SYMBOL(psb_drm_init_mode);
+EXPORT_SYMBOL(psb_drm_init_xres);
+EXPORT_SYMBOL(psb_drm_init_yres);
 
 /**
- * drm_pick_crtcs - pick crtcs for output devices
+ * psb_drm_pick_crtcs - pick crtcs for output devices
  * @dev: DRM device
  *
  * LOCKING:
  * Caller must hold mode config lock.
  */
-static void drm_pick_crtcs (struct drm_device *dev)
+static void psb_drm_pick_crtcs (struct drm_device *dev)
 {
 	int c, o, assigned;
 	struct drm_output *output, *output_equal;
@@ -805,9 +805,9 @@
 
 		des_mode = NULL;
 		list_for_each_entry(des_mode, &output->modes, head) {
-			if (/* !strcmp(des_mode->name, drm_init_mode) ||  */
-			    des_mode->hdisplay==drm_init_xres
-			    && des_mode->vdisplay==drm_init_yres) {
+			if (/* !strcmp(des_mode->name, psb_drm_init_mode) ||  */
+			    des_mode->hdisplay==psb_drm_init_xres
+			    && des_mode->vdisplay==psb_drm_init_yres) {
 				des_mode->type |= DRM_MODE_TYPE_USERPREF;
 				break;
 			}
@@ -861,7 +861,7 @@
 
 				list_for_each_entry(modes, &output->modes, head) {
 					list_for_each_entry(modes_equal, &output_equal->modes, head) {
-						if (drm_mode_equal (modes, modes_equal)) {
+						if (psb_drm_mode_equal (modes, modes_equal)) {
 							if ((output->possible_clones & output_equal->possible_clones) && (output_equal->crtc == crtc)) {
 								printk("Cloning %s (0x%lx) to %s (0x%lx)\n",output->name,output->possible_clones,output_equal->name,output_equal->possible_clones);
 								assigned = 0;
@@ -887,10 +887,10 @@
     		}
 	}
 }
-EXPORT_SYMBOL(drm_pick_crtcs);
+EXPORT_SYMBOL(psb_drm_pick_crtcs);
 
 /**
- * drm_initial_config - setup a sane initial output configuration
+ * psb_drm_initial_config - setup a sane initial output configuration
  * @dev: DRM device
  * @can_grow: this configuration is growable
  *
@@ -904,7 +904,7 @@
  * RETURNS:
  * Zero if everything went ok, nonzero otherwise.
  */
-bool drm_initial_config(struct drm_device *dev, bool can_grow)
+bool psb_drm_initial_config(struct drm_device *dev, bool can_grow)
 {
 	struct drm_output *output;
 	struct drm_crtc *crtc;
@@ -912,9 +912,9 @@
 
 	mutex_lock(&dev->mode_config.mutex);
 
-	drm_crtc_probe_output_modes(dev, 2048, 2048);
+	psb_drm_crtc_probe_output_modes(dev, 2048, 2048);
 
-	drm_pick_crtcs(dev);
+	psb_drm_pick_crtcs(dev);
 
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
 
@@ -940,18 +940,18 @@
 
 		/* and needs an attached fb */
 		if (output->crtc->fb)
-			drm_crtc_set_mode(output->crtc, output->crtc->desired_mode, 0, 0);
+			psb_drm_crtc_set_mode(output->crtc, output->crtc->desired_mode, 0, 0);
 	}
 
-	drm_disable_unused_functions(dev);
+	psb_drm_disable_unused_functions(dev);
 
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
-EXPORT_SYMBOL(drm_initial_config);
+EXPORT_SYMBOL(psb_drm_initial_config);
 
 /**
- * drm_mode_config_cleanup - free up DRM mode_config info
+ * psb_drm_mode_config_cleanup - free up DRM mode_config info
  * @dev: DRM device
  *
  * LOCKING:
@@ -962,7 +962,7 @@
  *
  * FIXME: cleanup any dangling user buffer objects too
  */
-void drm_mode_config_cleanup(struct drm_device *dev)
+void psb_drm_mode_config_cleanup(struct drm_device *dev)
 {
 	struct drm_output *output, *ot;
 	struct drm_crtc *crtc, *ct;
@@ -971,30 +971,30 @@
 	struct drm_property *property, *pt;
 
 	list_for_each_entry_safe(output, ot, &dev->mode_config.output_list, head) {
-		drm_output_destroy(output);
+		psb_drm_output_destroy(output);
 	}
 
 	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list, head) {
-		drm_property_destroy(dev, property);
+		psb_drm_property_destroy(dev, property);
 	}
 
 	list_for_each_entry_safe(mode, mt, &dev->mode_config.usermode_list, head) {
-		drm_mode_destroy(dev, mode);
+		psb_drm_mode_destroy(dev, mode);
 	}
 
 	list_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {
 		if (fb->bo->type != drm_bo_type_kernel)
-			drm_framebuffer_destroy(fb);
+			psb_drm_framebuffer_destroy(fb);
 		else
 			dev->driver->fb_remove(dev, drm_crtc_from_fb(dev, fb));
 	}
 
 	list_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {
-		drm_crtc_destroy(crtc);
+		psb_drm_crtc_destroy(crtc);
 	}
 
 }
-EXPORT_SYMBOL(drm_mode_config_cleanup);
+EXPORT_SYMBOL(psb_drm_mode_config_cleanup);
 
 /**
  * drm_crtc_set_config - set a new config from userspace
@@ -1058,8 +1058,8 @@
 		crtc->enabled = (new_mode != NULL);
 		if (new_mode != NULL) {
 			DRM_DEBUG("attempting to set mode from userspace\n");
-			drm_mode_debug_printmodeline(dev, new_mode);
-			if (!drm_crtc_set_mode(crtc, new_mode, crtc_info->x,
+			psb_drm_mode_debug_printmodeline(dev, new_mode);
+			if (!psb_drm_crtc_set_mode(crtc, new_mode, crtc_info->x,
 					       crtc_info->y)) {
 				crtc->enabled = save_enabled;
 				count = 0;
@@ -1072,7 +1072,7 @@
 			crtc->desired_y = crtc_info->y;
 			crtc->desired_mode = new_mode;
 		}
-		drm_disable_unused_functions(dev);
+		psb_drm_disable_unused_functions(dev);
 	}
 	kfree(save_crtcs);
 	return 0;
@@ -1198,7 +1198,7 @@
 
 	if (card_res->count_modes == 0) {
 		DRM_DEBUG("probing modes %dx%d\n", dev->mode_config.max_width, dev->mode_config.max_height);
-		drm_crtc_probe_output_modes(dev, dev->mode_config.max_width, dev->mode_config.max_height);
+		psb_drm_crtc_probe_output_modes(dev, dev->mode_config.max_width, dev->mode_config.max_height);
 		mode_count = 0;
 		list_for_each_entry(output, &dev->mode_config.output_list, head) {
 			list_for_each(lh, &output->modes)
@@ -1497,7 +1497,7 @@
 					    head) {
 				list_for_each_entry(mode, &output->modes,
 						    head) {
-					drm_mode_debug_printmodeline(dev, 
+					psb_drm_mode_debug_printmodeline(dev, 
 								     mode);
 				}
 			}
@@ -1601,7 +1601,7 @@
 	/* TODO check buffer is sufficently large */
 	/* TODO setup destructor callback */
 
-	fb = drm_framebuffer_create(dev);
+	fb = psb_drm_framebuffer_create(dev);
 	if (!fb) {
 		ret = -EINVAL;
 		goto out;
@@ -1669,7 +1669,7 @@
 	/* TODO unhock the destructor from the buffer object */
 
 	if (fb->bo->type != drm_bo_type_kernel)
-		drm_framebuffer_destroy(fb);
+		psb_drm_framebuffer_destroy(fb);
 	else
 		dev->driver->fb_remove(dev, drm_crtc_from_fb(dev, fb));
 
@@ -1746,7 +1746,7 @@
 	list_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {
 		list_del(&fb->filp_head);
 		if (fb->bo->type != drm_bo_type_kernel)
-			drm_framebuffer_destroy(fb);
+			psb_drm_framebuffer_destroy(fb);
 		else
 			dev->driver->fb_remove(dev, drm_crtc_from_fb(dev, fb));
 	}
@@ -1756,30 +1756,30 @@
 /*
  *
  */
-void drm_mode_addmode(struct drm_device *dev, struct drm_display_mode *user_mode)
+void psb_drm_mode_addmode(struct drm_device *dev, struct drm_display_mode *user_mode)
 {
 	user_mode->type |= DRM_MODE_TYPE_USERDEF;
 
 	user_mode->output_count = 0;
 	list_add(&user_mode->head, &dev->mode_config.usermode_list);
 }
-EXPORT_SYMBOL(drm_mode_addmode);
+EXPORT_SYMBOL(psb_drm_mode_addmode);
 
-int drm_mode_rmmode(struct drm_device *dev, struct drm_display_mode *mode)
+int psb_drm_mode_rmmode(struct drm_device *dev, struct drm_display_mode *mode)
 {
 	struct drm_display_mode *t;
 	int ret = -EINVAL;
 	list_for_each_entry(t, &dev->mode_config.usermode_list, head) {
 		if (t == mode) {
 			list_del(&mode->head);
-			drm_mode_destroy(dev, mode);
+			psb_drm_mode_destroy(dev, mode);
 			ret = 0;
 			break;
 		}
 	}
 	return ret;
 }
-EXPORT_SYMBOL(drm_mode_rmmode);
+EXPORT_SYMBOL(psb_drm_mode_rmmode);
 
 static int drm_mode_attachmode(struct drm_device *dev,
 			       struct drm_output *output,
@@ -1802,7 +1802,7 @@
 	return ret;
 }
 
-int drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,
+int psb_drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,
 			     struct drm_display_mode *mode)
 {
 	struct drm_output *output;
@@ -1812,7 +1812,7 @@
 			drm_mode_attachmode(dev, output, mode);
 	}
 }
-EXPORT_SYMBOL(drm_mode_attachmode_crtc);
+EXPORT_SYMBOL(psb_drm_mode_attachmode_crtc);
 
 static int drm_mode_detachmode(struct drm_device *dev,
 			       struct drm_output *output,
@@ -1835,7 +1835,7 @@
 	return ret;
 }
 
-int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)
+int psb_drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)
 {
 	struct drm_output *output;
 
@@ -1844,7 +1844,7 @@
 	}
 	return 0;
 }
-EXPORT_SYMBOL(drm_mode_detachmode_crtc);
+EXPORT_SYMBOL(psb_drm_mode_detachmode_crtc);
 
 /**
  * drm_fb_addmode - adds a user defined mode
@@ -1869,7 +1869,7 @@
 	int ret = 0;
 
 	mutex_lock(&dev->mode_config.mutex);
-	user_mode = drm_mode_create(dev);
+	user_mode = psb_drm_mode_create(dev);
 	if (!user_mode) {
 		ret = -ENOMEM;
 		goto out;
@@ -1877,7 +1877,7 @@
 
 	drm_crtc_convert_umode(user_mode, new_mode);
 
-	drm_mode_addmode(dev, user_mode);
+	psb_drm_mode_addmode(dev, user_mode);
 	new_mode->id = user_mode->mode_id;
 
 out:
@@ -1920,7 +1920,7 @@
 		goto out;
 	}
 
-	ret = drm_mode_rmmode(dev, mode);
+	ret = psb_drm_mode_rmmode(dev, mode);
 
 out:
 	mutex_unlock(&dev->mode_config.mutex);
@@ -2010,7 +2010,7 @@
 	return ret;
 }
 
-struct drm_property *drm_property_create(struct drm_device *dev, int flags,
+struct drm_property *psb_drm_property_create(struct drm_device *dev, int flags,
 					 const char *name, int num_values)
 {
 	struct drm_property *property = NULL;
@@ -2037,9 +2037,9 @@
 	kfree(property);
 	return NULL;
 }
-EXPORT_SYMBOL(drm_property_create);
+EXPORT_SYMBOL(psb_drm_property_create);
 
-int drm_property_add_enum(struct drm_property *property, int index,
+int psb_drm_property_add_enum(struct drm_property *property, int index,
 			  uint32_t value, const char *name)
 {
 	struct drm_property_enum *prop_enum;
@@ -2069,9 +2069,9 @@
 	list_add_tail(&prop_enum->head, &property->enum_list);
 	return 0;
 }
-EXPORT_SYMBOL(drm_property_add_enum);
+EXPORT_SYMBOL(psb_drm_property_add_enum);
 
-void drm_property_destroy(struct drm_device *dev, struct drm_property *property)
+void psb_drm_property_destroy(struct drm_device *dev, struct drm_property *property)
 {
 	struct drm_property_enum *prop_enum, *pt;
 
@@ -2085,10 +2085,10 @@
 	list_del(&property->head);
 	kfree(property);	
 }
-EXPORT_SYMBOL(drm_property_destroy);
+EXPORT_SYMBOL(psb_drm_property_destroy);
 
 
-int drm_output_attach_property(struct drm_output *output,
+int psb_drm_output_attach_property(struct drm_output *output,
 			       struct drm_property *property, int init_val)
 {
 	int i;
@@ -2105,7 +2105,7 @@
 		return -EINVAL;
 	return 0;
 }
-EXPORT_SYMBOL(drm_output_attach_property);
+EXPORT_SYMBOL(psb_drm_output_attach_property);
 
 int drm_mode_getproperty_ioctl(struct drm_device *dev,
 			       void *data, struct drm_file *file_priv)
diff -urNad psb-kernel-source-4.41.2/drm_crtc.h psb-kernel-source-4.41.2.drm_psb/drm_crtc.h
--- psb-kernel-source-4.41.2/drm_crtc.h	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_crtc.h	2010-05-02 10:13:44.931192960 +0200
@@ -350,7 +350,7 @@
 	/* RRCrtcPtr randr_crtc? */
 };
 
-extern struct drm_crtc *drm_crtc_create(struct drm_device *dev,
+extern struct drm_crtc *psb_drm_crtc_create(struct drm_device *dev,
 					const struct drm_crtc_funcs *funcs);
 
 /**
@@ -496,69 +496,69 @@
 	unsigned long fb_base;
 };
 
-struct drm_output *drm_output_create(struct drm_device *dev,
+struct drm_output *psb_drm_output_create(struct drm_device *dev,
 				     const struct drm_output_funcs *funcs,
 				     const char *name);
-extern void drm_output_destroy(struct drm_output *output);
-extern bool drm_output_rename(struct drm_output *output, const char *name);
+extern void psb_drm_output_destroy(struct drm_output *output);
+extern bool psb_drm_output_rename(struct drm_output *output, const char *name);
 extern void drm_fb_release(struct file *filp);
 
-extern struct edid *drm_get_edid(struct drm_output *output,
+extern struct edid *psb_drm_get_edid(struct drm_output *output,
 				 struct i2c_adapter *adapter);
-extern int drm_add_edid_modes(struct drm_output *output, struct edid *edid);
-extern void drm_mode_probed_add(struct drm_output *output, struct drm_display_mode *mode);
-extern void drm_mode_remove(struct drm_output *output, struct drm_display_mode *mode);
-extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
+extern int psb_drm_add_edid_modes(struct drm_output *output, struct edid *edid);
+extern void psb_drm_mode_probed_add(struct drm_output *output, struct drm_display_mode *mode);
+extern void psb_drm_mode_remove(struct drm_output *output, struct drm_display_mode *mode);
+extern struct drm_display_mode *psb_drm_mode_duplicate(struct drm_device *dev,
 						   struct drm_display_mode *mode);
-extern void drm_mode_debug_printmodeline(struct drm_device *dev,
+extern void psb_drm_mode_debug_printmodeline(struct drm_device *dev,
 					 struct drm_display_mode *mode);
-extern void drm_mode_config_init(struct drm_device *dev);
-extern void drm_mode_config_cleanup(struct drm_device *dev);
-extern void drm_mode_set_name(struct drm_display_mode *mode);
-extern bool drm_mode_equal(struct drm_display_mode *mode1, struct drm_display_mode *mode2);
-extern void drm_disable_unused_functions(struct drm_device *dev);
+extern void psb_drm_mode_config_init(struct drm_device *dev);
+extern void psb_drm_mode_config_cleanup(struct drm_device *dev);
+extern void psb_drm_mode_set_name(struct drm_display_mode *mode);
+extern bool psb_drm_mode_equal(struct drm_display_mode *mode1, struct drm_display_mode *mode2);
+extern void psb_drm_disable_unused_functions(struct drm_device *dev);
 
-extern void drm_mode_addmode(struct drm_device *dev, struct drm_display_mode *user_mode);
-extern int drm_mode_rmmode(struct drm_device *dev, struct drm_display_mode *mode);
+extern void psb_drm_mode_addmode(struct drm_device *dev, struct drm_display_mode *user_mode);
+extern int psb_drm_mode_rmmode(struct drm_device *dev, struct drm_display_mode *mode);
 
 /* for us by fb module */
-extern int drm_mode_attachmode_crtc(struct drm_device *dev,
+extern int psb_drm_mode_attachmode_crtc(struct drm_device *dev,
 				    struct drm_crtc *crtc,
 				    struct drm_display_mode *mode);
-extern int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode);
+extern int psb_drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode);
 
-extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);
-extern void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
+extern struct drm_display_mode *psb_drm_mode_create(struct drm_device *dev);
+extern void psb_drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
 extern void drm_mode_list_concat(struct list_head *head,
 				 struct list_head *new);
-extern void drm_mode_validate_size(struct drm_device *dev,
+extern void psb_drm_mode_validate_size(struct drm_device *dev,
 				   struct list_head *mode_list,
 				   int maxX, int maxY, int maxPitch);
 extern void drm_mode_prune_invalid(struct drm_device *dev,
 				   struct list_head *mode_list, bool verbose);
 extern void drm_mode_sort(struct list_head *mode_list);
-extern int drm_mode_vrefresh(struct drm_display_mode *mode);
-extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
+extern int psb_drm_mode_vrefresh(struct drm_display_mode *mode);
+extern void psb_drm_mode_set_crtcinfo(struct drm_display_mode *p,
 				  int adjust_flags);
 extern void drm_mode_output_list_update(struct drm_output *output);
 
 extern struct drm_display_mode *drm_crtc_mode_create(struct drm_device *dev);
-extern bool drm_initial_config(struct drm_device *dev, bool cangrow);
+extern bool psb_drm_initial_config(struct drm_device *dev, bool cangrow);
 extern void drm_framebuffer_set_object(struct drm_device *dev,
 				       unsigned long handle);
-extern struct drm_framebuffer *drm_framebuffer_create(struct drm_device *dev);
-extern void drm_framebuffer_destroy(struct drm_framebuffer *fb);
-extern int drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
-extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
-extern bool drm_crtc_set_mode(struct drm_crtc *crtc, struct drm_display_mode *mode,
+extern struct drm_framebuffer *psb_drm_framebuffer_create(struct drm_device *dev);
+extern void psb_drm_framebuffer_destroy(struct drm_framebuffer *fb);
+extern int psb_drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
+extern int psb_drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
+extern bool psb_drm_crtc_set_mode(struct drm_crtc *crtc, struct drm_display_mode *mode,
 		       int x, int y);
 
-extern int drm_output_attach_property(struct drm_output *output,
+extern int psb_drm_output_attach_property(struct drm_output *output,
 				      struct drm_property *property, int init_val);
-extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
+extern struct drm_property *psb_drm_property_create(struct drm_device *dev, int flags,
 						const char *name, int num_values);
-extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
-extern int drm_property_add_enum(struct drm_property *property, int index, 
+extern void psb_drm_property_destroy(struct drm_device *dev, struct drm_property *property);
+extern int psb_drm_property_add_enum(struct drm_property *property, int index, 
 				 uint32_t value, const char *name);
 
 /* IOCTLs */
diff -urNad psb-kernel-source-4.41.2/drm_dma.c psb-kernel-source-4.41.2.drm_psb/drm_dma.c
--- psb-kernel-source-4.41.2/drm_dma.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_dma.c	2010-05-02 10:13:44.007193755 +0200
@@ -47,7 +47,7 @@
 {
 	int i;
 
-	dev->dma = drm_alloc(sizeof(*dev->dma), DRM_MEM_DRIVER);
+	dev->dma = psb_drm_alloc(sizeof(*dev->dma), DRM_MEM_DRIVER);
 	if (!dev->dma)
 		return -ENOMEM;
 
@@ -85,39 +85,39 @@
 				  dma->bufs[i].seg_count);
 			for (j = 0; j < dma->bufs[i].seg_count; j++) {
 				if (dma->bufs[i].seglist[j]) {
-					drm_pci_free(dev, dma->bufs[i].seglist[j]);
+					psb_drm_pci_free(dev, dma->bufs[i].seglist[j]);
 				}
 			}
-			drm_free(dma->bufs[i].seglist,
+			psb_drm_free(dma->bufs[i].seglist,
 				 dma->bufs[i].seg_count
 				 * sizeof(*dma->bufs[0].seglist), DRM_MEM_SEGS);
 		}
 		if (dma->bufs[i].buf_count) {
 			for (j = 0; j < dma->bufs[i].buf_count; j++) {
 				if (dma->bufs[i].buflist[j].dev_private) {
-					drm_free(dma->bufs[i].buflist[j].
+					psb_drm_free(dma->bufs[i].buflist[j].
 						 dev_private,
 						 dma->bufs[i].buflist[j].
 						 dev_priv_size, DRM_MEM_BUFS);
 				}
 			}
-			drm_free(dma->bufs[i].buflist,
+			psb_drm_free(dma->bufs[i].buflist,
 				 dma->bufs[i].buf_count *
 				 sizeof(*dma->bufs[0].buflist), DRM_MEM_BUFS);
 		}
 	}
 
 	if (dma->buflist) {
-		drm_free(dma->buflist,
+		psb_drm_free(dma->buflist,
 			 dma->buf_count * sizeof(*dma->buflist), DRM_MEM_BUFS);
 	}
 
 	if (dma->pagelist) {
-		drm_free(dma->pagelist,
+		psb_drm_free(dma->pagelist,
 			 dma->page_count * sizeof(*dma->pagelist),
 			 DRM_MEM_PAGES);
 	}
-	drm_free(dev->dma, sizeof(*dev->dma), DRM_MEM_DRIVER);
+	psb_drm_free(dev->dma, sizeof(*dev->dma), DRM_MEM_DRIVER);
 	dev->dma = NULL;
 }
 
@@ -152,7 +152,7 @@
  *
  * Frees each buffer associated with \p file_priv not already on the hardware.
  */
-void drm_core_reclaim_buffers(struct drm_device *dev,
+void psb_drm_core_reclaim_buffers(struct drm_device *dev,
 			      struct drm_file *file_priv)
 {
 	struct drm_device_dma *dma = dev->dma;
@@ -176,4 +176,4 @@
 		}
 	}
 }
-EXPORT_SYMBOL(drm_core_reclaim_buffers);
+EXPORT_SYMBOL(psb_drm_core_reclaim_buffers);
diff -urNad psb-kernel-source-4.41.2/drm_drawable.c psb-kernel-source-4.41.2.drm_psb/drm_drawable.c
--- psb-kernel-source-4.41.2/drm_drawable.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_drawable.c	2010-05-02 10:13:44.111193291 +0200
@@ -79,7 +79,7 @@
 
 	spin_lock_irqsave(&dev->drw_lock, irqflags);
 
-	drm_free(drm_get_drawable_info(dev, draw->handle),
+	psb_drm_free(psb_drm_get_drawable_info(dev, draw->handle),
 		 sizeof(struct drm_drawable_info), DRM_MEM_BUFS);
 
 	idr_remove(&dev->drw_idr, draw->handle);
@@ -99,12 +99,12 @@
 
 	info = idr_find(&dev->drw_idr, update->handle);
 	if (!info) {
-		info = drm_calloc(1, sizeof(*info), DRM_MEM_BUFS);
+		info = psb_drm_calloc(1, sizeof(*info), DRM_MEM_BUFS);
 		if (!info)
 			return -ENOMEM;
 		if (IS_ERR(idr_replace(&dev->drw_idr, info, update->handle))) {
 			DRM_ERROR("No such drawable %d\n", update->handle);
-			drm_free(info, sizeof(*info), DRM_MEM_BUFS);
+			psb_drm_free(info, sizeof(*info), DRM_MEM_BUFS);
 			return -EINVAL;
 		}
 	}
@@ -112,7 +112,7 @@
 	switch (update->type) {
 	case DRM_DRAWABLE_CLIPRECTS:
 		if (update->num != info->num_rects) {
-			rects = drm_alloc(update->num * sizeof(struct drm_clip_rect),
+			rects = psb_drm_alloc(update->num * sizeof(struct drm_clip_rect),
 					 DRM_MEM_BUFS);
 		} else
 			rects = info->rects;
@@ -136,7 +136,7 @@
 		spin_lock_irqsave(&dev->drw_lock, irqflags);
 
 		if (rects != info->rects) {
-			drm_free(info->rects, info->num_rects *
+			psb_drm_free(info->rects, info->num_rects *
 				 sizeof(struct drm_clip_rect), DRM_MEM_BUFS);
 		}
 
@@ -157,7 +157,7 @@
 
 error:
 	if (rects != info->rects)
-		drm_free(rects, update->num * sizeof(struct drm_clip_rect),
+		psb_drm_free(rects, update->num * sizeof(struct drm_clip_rect),
 			 DRM_MEM_BUFS);
 
 	return err;
@@ -166,20 +166,20 @@
 /**
  * Caller must hold the drawable spinlock!
  */
-struct drm_drawable_info *drm_get_drawable_info(struct drm_device *dev, drm_drawable_t id)
+struct drm_drawable_info *psb_drm_get_drawable_info(struct drm_device *dev, drm_drawable_t id)
 {
 	return idr_find(&dev->drw_idr, id);
 }
-EXPORT_SYMBOL(drm_get_drawable_info);
+EXPORT_SYMBOL(psb_drm_get_drawable_info);
 
 static int drm_drawable_free(int idr, void *p, void *data)
 {
 	struct drm_drawable_info *info = p;
 
 	if (info) {
-		drm_free(info->rects, info->num_rects *
+		psb_drm_free(info->rects, info->num_rects *
 			 sizeof(struct drm_clip_rect), DRM_MEM_BUFS);
-		drm_free(info, sizeof(*info), DRM_MEM_BUFS);
+		psb_drm_free(info, sizeof(*info), DRM_MEM_BUFS);
 	}
 
 	return 0;
diff -urNad psb-kernel-source-4.41.2/drm_drv.c psb-kernel-source-4.41.2.drm_psb/drm_drv.c
--- psb-kernel-source-4.41.2/drm_drv.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_drv.c	2010-05-02 10:13:45.431191982 +0200
@@ -185,13 +185,13 @@
 	DRM_DEBUG("driver lastclose completed\n");
 
 	if (dev->unique) {
-		drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
+		psb_drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
 		dev->unique = NULL;
 		dev->unique_len = 0;
 	}
 
 	if (dev->irq_enabled)
-		drm_irq_uninstall(dev);
+		psb_drm_irq_uninstall(dev);
 
 	/* Free drawable information memory */
 	mutex_lock(&dev->struct_mutex);
@@ -200,7 +200,7 @@
 	del_timer(&dev->timer);
 
 	if (dev->unique) {
-		drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
+		psb_drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
 		dev->unique = NULL;
 		dev->unique_len = 0;
 	}
@@ -209,7 +209,7 @@
 		list_for_each_entry_safe(pt, next, &dev->magicfree, head) {
 			list_del(&pt->head);
 			drm_ht_remove_item(&dev->magiclist, &pt->hash_item);
-			drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
+			psb_drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
 		}
 		drm_ht_remove(&dev->magiclist);
 	}
@@ -225,30 +225,30 @@
 			if (entry->bound)
 				drm_unbind_agp(entry->memory);
 			drm_free_agp(entry->memory, entry->pages);
-			drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
+			psb_drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
 		}
 		INIT_LIST_HEAD(&dev->agp->memory);
 
 		if (dev->agp->acquired)
-			drm_agp_release(dev);
+			psb_drm_agp_release(dev);
 
 		dev->agp->acquired = 0;
 		dev->agp->enabled = 0;
 	}
 	if (drm_core_check_feature(dev, DRIVER_SG) && dev->sg) {
-		drm_sg_cleanup(dev->sg);
+		psb_drm_sg_cleanup(dev->sg);
 		dev->sg = NULL;
 	}
 
 	/* Clear vma list (only built for debugging) */
 	list_for_each_entry_safe(vma, vma_temp, &dev->vmalist, head) {
 		list_del(&vma->head);
-		drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
+		psb_drm_free(vma, sizeof(*vma), DRM_MEM_VMAS);
 	}
 
 	list_for_each_entry_safe(r_list, list_t, &dev->maplist, head) {
 		if (!(r_list->map->flags & _DRM_DRIVER)) {
-			drm_rmmap_locked(dev, r_list->map);
+			psb_drm_rmmap_locked(dev, r_list->map);
 			r_list = NULL;
 		}
 	}
@@ -257,13 +257,13 @@
 		for (i = 0; i < dev->queue_count; i++) {
 
 			if (dev->queuelist[i]) {
-				drm_free(dev->queuelist[i],
+				psb_drm_free(dev->queuelist[i],
 					 sizeof(*dev->queuelist[0]),
 					 DRM_MEM_QUEUES);
 				dev->queuelist[i] = NULL;
 			}
 		}
-		drm_free(dev->queuelist,
+		psb_drm_free(dev->queuelist,
 			 dev->queue_slots * sizeof(*dev->queuelist),
 			 DRM_MEM_QUEUES);
 		dev->queuelist = NULL;
@@ -285,7 +285,7 @@
 	return 0;
 }
 
-void drm_cleanup_pci(struct pci_dev *pdev)
+void psb_drm_cleanup_pci(struct pci_dev *pdev)
 {
 	struct drm_device *dev = pci_get_drvdata(pdev);
 
@@ -294,7 +294,7 @@
 	if (dev)
 		drm_cleanup(dev);
 }
-EXPORT_SYMBOL(drm_cleanup_pci);
+EXPORT_SYMBOL(psb_drm_cleanup_pci);
 
 /**
  * Module initialization. Called via init_module at module load time, or via
@@ -309,7 +309,7 @@
  * Expands the \c DRIVER_PREINIT and \c DRIVER_POST_INIT macros before and
  * after the initialization for driver customization.
  */
-int drm_init(struct drm_driver *driver,
+int psb_drm_init(struct drm_driver *driver,
 		       struct pci_device_id *pciidlist)
 {
 	struct pci_dev *pdev;
@@ -364,7 +364,7 @@
 				}
 				/* stealth mode requires a manual probe */
 				pci_dev_get(pdev);
-				if ((rc = drm_get_dev(pdev, &pciidlist[i], driver))) {
+				if ((rc = psb_drm_get_dev(pdev, &pciidlist[i], driver))) {
 					pci_dev_put(pdev);
 					return rc;
 				}
@@ -374,14 +374,14 @@
 	}
 	return 0;
 }
-EXPORT_SYMBOL(drm_init);
+EXPORT_SYMBOL(psb_drm_init);
 
 /**
  * Called via cleanup_module() at module unload time.
  *
  * Cleans up all DRM device, calling drm_lastclose().
  *
- * \sa drm_init
+ * \sa psb_drm_init
  */
 static void drm_cleanup(struct drm_device * dev)
 {
@@ -407,15 +407,15 @@
 	if (dev->driver->unload)
 		dev->driver->unload(dev);
         
-	drm_bo_driver_finish(dev);
+	psb_drm_bo_driver_finish(dev);
 	drm_fence_manager_takedown(dev);
 
 	drm_ht_remove(&dev->map_hash);
-	drm_mm_takedown(&dev->offset_manager);
+	psb_drm_mm_takedown(&dev->offset_manager);
 	drm_ht_remove(&dev->object_hash);
 
 	if (drm_core_has_AGP(dev) && dev->agp) {
-		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
+		psb_drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
 		dev->agp = NULL;
 	}
 
@@ -427,7 +427,7 @@
 		DRM_ERROR("Cannot unload module\n");
 }
 
-void drm_exit(struct drm_driver *driver)
+void psb_drm_exit(struct drm_driver *driver)
 {
 	int i;
 	struct drm_device *dev = NULL;
@@ -458,7 +458,7 @@
 #endif
 	DRM_INFO("Module unloaded\n");
 }
-EXPORT_SYMBOL(drm_exit);
+EXPORT_SYMBOL(psb_drm_exit);
 
 /** File operations structure */
 static const struct file_operations drm_stub_fops = {
@@ -500,7 +500,7 @@
 	ret = -ENOMEM;
 	drm_cards_limit =
 	    (drm_cards_limit < DRM_MAX_MINOR + 1 ? drm_cards_limit : DRM_MAX_MINOR + 1);
-	drm_heads = drm_calloc(drm_cards_limit, sizeof(*drm_heads), DRM_MEM_STUB);
+	drm_heads = psb_drm_calloc(drm_cards_limit, sizeof(*drm_heads), DRM_MEM_STUB);
 	if (!drm_heads)
 		goto err_p1;
 
@@ -531,7 +531,7 @@
 	drm_sysfs_destroy();
 err_p2:
 	unregister_chrdev(DRM_MAJOR, "drm");
-	drm_free(drm_heads, sizeof(*drm_heads) * drm_cards_limit, DRM_MEM_STUB);
+	psb_drm_free(drm_heads, sizeof(*drm_heads) * drm_cards_limit, DRM_MEM_STUB);
 err_p1:
 	return ret;
 }
@@ -543,7 +543,7 @@
 
 	unregister_chrdev(DRM_MAJOR, "drm");
 
-	drm_free(drm_heads, sizeof(*drm_heads) * drm_cards_limit, DRM_MEM_STUB);
+	psb_drm_free(drm_heads, sizeof(*drm_heads) * drm_cards_limit, DRM_MEM_STUB);
 }
 
 module_init(drm_core_init);
@@ -593,14 +593,14 @@
  * byte stack buffer to store the ioctl arguments in kernel space.  Should we
  * ever need much larger ioctl arguments, we may need to allocate memory.
  */
-int drm_ioctl(struct inode *inode, struct file *filp,
+int psb_drm_ioctl(struct inode *inode, struct file *filp,
 	      unsigned int cmd, unsigned long arg)
 {
-	return drm_unlocked_ioctl(filp, cmd, arg);
+	return psb_drm_unlocked_ioctl(filp, cmd, arg);
 }
-EXPORT_SYMBOL(drm_ioctl);
+EXPORT_SYMBOL(psb_drm_ioctl);
 
-long drm_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+long psb_drm_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct drm_file *file_priv = filp->private_data;
 	struct drm_device *dev = file_priv->head->dev;
@@ -678,9 +678,9 @@
 		DRM_DEBUG("ret = %d\n", retcode);
 	return retcode;
 }
-EXPORT_SYMBOL(drm_unlocked_ioctl);
+EXPORT_SYMBOL(psb_drm_unlocked_ioctl);
 
-drm_local_map_t *drm_getsarea(struct drm_device *dev)
+drm_local_map_t *psb_drm_getsarea(struct drm_device *dev)
 {
 	struct drm_map_list *entry;
 
@@ -692,4 +692,4 @@
 	}
 	return NULL;
 }
-EXPORT_SYMBOL(drm_getsarea);
+EXPORT_SYMBOL(psb_drm_getsarea);
diff -urNad psb-kernel-source-4.41.2/drm_edid.c psb-kernel-source-4.41.2.drm_psb/drm_edid.c
--- psb-kernel-source-4.41.2/drm_edid.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_edid.c	2010-05-02 10:13:42.791193110 +0200
@@ -2,7 +2,7 @@
  * Copyright (c) 2007 Intel Corporation
  *   Jesse Barnes <jesse.barnes@intel.com>
  *
- * DDC probing routines (drm_ddc_read & drm_do_probe_ddc_edid) originally from
+ * DDC probing routines (psb_drm_ddc_read & drm_do_probe_ddc_edid) originally from
  * FB layer.
  *   Copyright (C) 2006 Dennis Munsie <dmunsie@cecropia.com>
  */
@@ -15,7 +15,7 @@
 /* Valid EDID header has these bytes */
 static u8 edid_header[] = { 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };
 
-int drm_get_acpi_edid(char *method, char *edid, ssize_t length)
+int psb_drm_get_acpi_edid(char *method, char *edid, ssize_t length)
 {
 	int status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -46,7 +46,7 @@
 
 	return status;
 }
-EXPORT_SYMBOL(drm_get_acpi_edid);
+EXPORT_SYMBOL(psb_drm_get_acpi_edid);
 
 /**
  * edid_valid - sanity check EDID data
@@ -100,7 +100,7 @@
 	struct drm_display_mode *mode;
 	int hsize = t->hsize * 8 + 248, vsize;
 
-	mode = drm_mode_create(dev);
+	mode = psb_drm_mode_create(dev);
 	if (!mode)
 		return NULL;
 
@@ -113,7 +113,7 @@
 	else
 		vsize = (hsize * 9) / 16;
 
-	drm_mode_set_name(mode);
+	psb_drm_mode_set_name(mode);
 
 	return mode;
 }
@@ -143,7 +143,7 @@
 		return NULL;
 	}
 
-	mode = drm_mode_create(dev);
+	mode = psb_drm_mode_create(dev);
 	if (!mode)
 		return NULL;
 
@@ -166,7 +166,7 @@
 		 pt->vsync_pulse_width_lo);
 	mode->vtotal = mode->vdisplay + ((pt->vblank_hi << 8) | pt->vblank_lo);
 
-	drm_mode_set_name(mode);
+	psb_drm_mode_set_name(mode);
 
 	if (pt->interlaced)
 		mode->flags |= V_INTERLACE;
@@ -256,8 +256,8 @@
 	for (i = 0; i <= EDID_EST_TIMINGS; i++)
 		if (est_bits & (1<<i)) {
 			struct drm_display_mode *newmode;
-			newmode = drm_mode_duplicate(dev, &edid_est_modes[i]);
-			drm_mode_probed_add(output, newmode);
+			newmode = psb_drm_mode_duplicate(dev, &edid_est_modes[i]);
+			psb_drm_mode_probed_add(output, newmode);
 			modes++;
 		}
 
@@ -285,7 +285,7 @@
 			continue;
 
 		newmode = drm_mode_std(dev, &edid->standard_timings[i]);
-		drm_mode_probed_add(output, newmode);
+		psb_drm_mode_probed_add(output, newmode);
 		modes++;
 	}
 
@@ -319,7 +319,7 @@
 			/* First detailed mode is preferred */
 			if (i == 0 && edid->preferred_timing)
 				newmode->type |= DRM_MODE_TYPE_PREFERRED;
-			drm_mode_probed_add(output, newmode);
+			psb_drm_mode_probed_add(output, newmode);
 				     
 			modes++;
 			continue;
@@ -346,7 +346,7 @@
 
 				std = &data->data.timings[j];
 				newmode = drm_mode_std(dev, std);
-				drm_mode_probed_add(output, newmode);
+				psb_drm_mode_probed_add(output, newmode);
 				modes++;
 			}
 			break;
@@ -391,7 +391,7 @@
 	return NULL;
 }
 
-unsigned char *drm_ddc_read(struct i2c_adapter *adapter)
+unsigned char *psb_drm_ddc_read(struct i2c_adapter *adapter)
 {
 	struct i2c_algo_bit_data *algo_data = adapter->algo_data;
 	unsigned char *edid = NULL;
@@ -458,10 +458,10 @@
 
 	return edid;
 }
-EXPORT_SYMBOL(drm_ddc_read);
+EXPORT_SYMBOL(psb_drm_ddc_read);
 
 /**
- * drm_get_edid - get EDID data, if available
+ * psb_drm_get_edid - get EDID data, if available
  * @output: output we're probing
  * @adapter: i2c adapter to use for DDC
  *
@@ -469,12 +469,12 @@
  * 
  * Return edid data or NULL if we couldn't find any.
  */
-struct edid *drm_get_edid(struct drm_output *output,
+struct edid *psb_drm_get_edid(struct drm_output *output,
 			  struct i2c_adapter *adapter)
 {
 	struct edid *edid;
 
-	edid = (struct edid *)drm_ddc_read(adapter);
+	edid = (struct edid *)psb_drm_ddc_read(adapter);
 	if (!edid) {
 		dev_warn(&output->dev->pdev->dev, "%s: no EDID data\n",
 			 output->name);
@@ -488,10 +488,10 @@
 	}
 	return edid;
 }
-EXPORT_SYMBOL(drm_get_edid);
+EXPORT_SYMBOL(psb_drm_get_edid);
 
 /**
- * drm_add_edid_modes - add modes from EDID data, if available
+ * psb_drm_add_edid_modes - add modes from EDID data, if available
  * @output: output we're probing
  * @edid: edid data
  *
@@ -499,7 +499,7 @@
  *
  * Return number of modes added or 0 if we couldn't find any.
  */
-int drm_add_edid_modes(struct drm_output *output, struct edid *edid)
+int psb_drm_add_edid_modes(struct drm_output *output, struct edid *edid)
 {
 	int num_modes = 0;
 
@@ -516,4 +516,4 @@
 	num_modes += add_detailed_info(output, edid);
 	return num_modes;
 }
-EXPORT_SYMBOL(drm_add_edid_modes);
+EXPORT_SYMBOL(psb_drm_add_edid_modes);
diff -urNad psb-kernel-source-4.41.2/drm_edid.h psb-kernel-source-4.41.2.drm_psb/drm_edid.h
--- psb-kernel-source-4.41.2/drm_edid.h	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_edid.h	2010-05-02 10:13:42.967193625 +0200
@@ -173,7 +173,7 @@
 	u8 checksum;
 } __attribute__((packed));
 
-extern unsigned char *drm_ddc_read(struct i2c_adapter *adapter);
-extern int drm_get_acpi_edid(char *method, char *edid, ssize_t length);
+extern unsigned char *psb_drm_ddc_read(struct i2c_adapter *adapter);
+extern int psb_drm_get_acpi_edid(char *method, char *edid, ssize_t length);
 
 #endif /* __DRM_EDID_H__ */
diff -urNad psb-kernel-source-4.41.2/drm_fb.c psb-kernel-source-4.41.2.drm_psb/drm_fb.c
--- psb-kernel-source-4.41.2/drm_fb.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_fb.c	2010-05-02 10:13:41.923191660 +0200
@@ -247,7 +247,7 @@
 		    break;
 	}
 #else
-	drm_mode = drm_mode_create(dev);
+	drm_mode = psb_drm_mode_create(dev);
 	drm_mode->hdisplay = var->xres;
 	drm_mode->hsync_start = drm_mode->hdisplay + var->right_margin;
 	drm_mode->hsync_end = drm_mode->hsync_start + var->hsync_len;
@@ -257,19 +257,19 @@
 	drm_mode->vsync_end = drm_mode->vsync_start + var->vsync_len;
 	drm_mode->vtotal = drm_mode->vsync_end + var->upper_margin;
 	drm_mode->clock = PICOS2KHZ(var->pixclock);
-	drm_mode->vrefresh = drm_mode_vrefresh(drm_mode);
-	drm_mode_set_name(drm_mode);
-	drm_mode_set_crtcinfo(drm_mode, CRTC_INTERLACE_HALVE_V);
+	drm_mode->vrefresh = psb_drm_mode_vrefresh(drm_mode);
+	psb_drm_mode_set_name(drm_mode);
+	psb_drm_mode_set_crtcinfo(drm_mode, CRTC_INTERLACE_HALVE_V);
 #endif
 
-	if (!drm_crtc_set_mode(par->crtc, drm_mode, 0, 0))
+	if (!psb_drm_crtc_set_mode(par->crtc, drm_mode, 0, 0))
 		return -EINVAL;
 
 	/* Have to destroy our created mode if we're not searching the mode
 	 * list for it.
 	 */
 #if 1 
-	drm_mode_destroy(dev, drm_mode);
+	psb_drm_mode_destroy(dev, drm_mode);
 #endif
 
 	return 0;
@@ -290,7 +290,7 @@
 	.fb_imageblit = cfb_imageblit,
 };
 
-int drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc)
+int psb_drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc)
 {
 	struct fb_info *info;
 	struct drm_framebuffer *fb = crtc->fb;
@@ -325,7 +325,7 @@
 
 	info->flags = FBINFO_DEFAULT;
 
-	ret = drm_bo_kmap(fb->bo, 0, fb->bo->num_pages, &fb->kmap);
+	ret = psb_drm_bo_kmap(fb->bo, 0, fb->bo->num_pages, &fb->kmap);
 	if (ret)
 		DRM_ERROR("error mapping fb: %d\n", ret);
 
@@ -417,9 +417,9 @@
 	       info->fix.id);
 	return 0;
 }
-EXPORT_SYMBOL(drmfb_probe);
+EXPORT_SYMBOL(psb_drmfb_probe);
 
-int drmfb_remove(struct drm_device *dev, struct drm_crtc *crtc)
+int psb_drmfb_remove(struct drm_device *dev, struct drm_crtc *crtc)
 {
 	struct fb_info *info = fb->fbdev;
 	struct drm_framebuffer *fb = crtc->fb;
@@ -427,10 +427,10 @@
 	if (info) {
 		unregister_framebuffer(info);
 		framebuffer_release(info);
-		drm_bo_kunmap(&fb->kmap);
-                drm_bo_usage_deref_unlocked(fb->bo);
+		psb_drm_bo_kunmap(&fb->kmap);
+                psb_drm_bo_usage_deref_unlocked(fb->bo);
 	}
 	return 0;
 }
-EXPORT_SYMBOL(drmfb_remove);
+EXPORT_SYMBOL(psb_drmfb_remove);
 MODULE_LICENSE("GPL");
diff -urNad psb-kernel-source-4.41.2/drm_fence.c psb-kernel-source-4.41.2.drm_psb/drm_fence.c
--- psb-kernel-source-4.41.2/drm_fence.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_fence.c	2010-05-02 10:13:44.467194114 +0200
@@ -36,7 +36,7 @@
  * need polling.
  */
 
-int drm_fence_wait_polling(struct drm_fence_object *fence, int lazy,
+int psb_drm_fence_wait_polling(struct drm_fence_object *fence, int lazy,
 			   int interruptible, uint32_t mask, 
 			   unsigned long end_jiffies)
 {
@@ -55,7 +55,7 @@
 		__set_current_state((interruptible) ? 
 				    TASK_INTERRUPTIBLE :
 				    TASK_UNINTERRUPTIBLE);
-		if (drm_fence_object_signaled(fence, mask))
+		if (psb_drm_fence_object_signaled(fence, mask))
 			break;
 		if (time_after_eq(jiffies, end_jiffies)) {
 			ret = -EBUSY;
@@ -79,13 +79,13 @@
 	remove_wait_queue(&fc->fence_queue, &entry);
 	return ret;
 }
-EXPORT_SYMBOL(drm_fence_wait_polling);
+EXPORT_SYMBOL(psb_drm_fence_wait_polling);
 
 /*
  * Typically called by the IRQ handler.
  */
 
-void drm_fence_handler(struct drm_device *dev, uint32_t fence_class,
+void psb_drm_fence_handler(struct drm_device *dev, uint32_t fence_class,
 		       uint32_t sequence, uint32_t type, uint32_t error)
 {
 	int wake = 0;
@@ -174,7 +174,7 @@
 	if (wake) 
 		wake_up_all(&fc->fence_queue);
 }
-EXPORT_SYMBOL(drm_fence_handler);
+EXPORT_SYMBOL(psb_drm_fence_handler);
 
 static void drm_fence_unring(struct drm_device *dev, struct list_head *ring)
 {
@@ -186,7 +186,7 @@
 	write_unlock_irqrestore(&fm->lock, flags);
 }
 
-void drm_fence_usage_deref_locked(struct drm_fence_object **fence)
+void psb_drm_fence_usage_deref_locked(struct drm_fence_object **fence)
 {
 	struct drm_fence_object *tmp_fence = *fence;
 	struct drm_device *dev = tmp_fence->dev;
@@ -203,9 +203,9 @@
 		drm_ctl_free(tmp_fence, sizeof(*tmp_fence), DRM_MEM_FENCE);
 	}
 }
-EXPORT_SYMBOL(drm_fence_usage_deref_locked);
+EXPORT_SYMBOL(psb_drm_fence_usage_deref_locked);
 
-void drm_fence_usage_deref_unlocked(struct drm_fence_object **fence)
+void psb_drm_fence_usage_deref_unlocked(struct drm_fence_object **fence)
 {
 	struct drm_fence_object *tmp_fence = *fence;
 	struct drm_device *dev = tmp_fence->dev;
@@ -223,7 +223,7 @@
 		mutex_unlock(&dev->struct_mutex);
 	}
 }
-EXPORT_SYMBOL(drm_fence_usage_deref_unlocked);
+EXPORT_SYMBOL(psb_drm_fence_usage_deref_unlocked);
 
 struct drm_fence_object
 *drm_fence_reference_locked(struct drm_fence_object *src)
@@ -234,7 +234,7 @@
 	return src;
 }
 
-void drm_fence_reference_unlocked(struct drm_fence_object **dst,
+void psb_drm_fence_reference_unlocked(struct drm_fence_object **dst,
 				  struct drm_fence_object *src)
 {
 	mutex_lock(&src->dev->struct_mutex);
@@ -242,7 +242,7 @@
 	atomic_inc(&src->usage);
 	mutex_unlock(&src->dev->struct_mutex);
 }
-EXPORT_SYMBOL(drm_fence_reference_unlocked);
+EXPORT_SYMBOL(psb_drm_fence_reference_unlocked);
 
 static void drm_fence_object_destroy(struct drm_file *priv,
 				     struct drm_user_object *base)
@@ -250,10 +250,10 @@
 	struct drm_fence_object *fence =
 	    drm_user_object_entry(base, struct drm_fence_object, base);
 
-	drm_fence_usage_deref_locked(&fence);
+	psb_drm_fence_usage_deref_locked(&fence);
 }
 
-int drm_fence_object_signaled(struct drm_fence_object *fence, uint32_t mask)
+int psb_drm_fence_object_signaled(struct drm_fence_object *fence, uint32_t mask)
 {
 	unsigned long flags;
 	int signaled;
@@ -274,10 +274,10 @@
 	}
 	return signaled;
 }
-EXPORT_SYMBOL(drm_fence_object_signaled);
+EXPORT_SYMBOL(psb_drm_fence_object_signaled);
 
 
-int drm_fence_object_flush(struct drm_fence_object *fence,
+int psb_drm_fence_object_flush(struct drm_fence_object *fence,
 			   uint32_t type)
 {
 	struct drm_device *dev = fence->dev;
@@ -326,14 +326,14 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_fence_object_flush);
+EXPORT_SYMBOL(psb_drm_fence_object_flush);
 
 /*
  * Make sure old fence objects are signaled before their fence sequences are
  * wrapped around and reused.
  */
 
-void drm_fence_flush_old(struct drm_device *dev, uint32_t fence_class,
+void psb_drm_fence_flush_old(struct drm_device *dev, uint32_t fence_class,
 			 uint32_t sequence)
 {
 	struct drm_fence_manager *fm = &dev->fm;
@@ -373,9 +373,9 @@
 	 */
 
 }
-EXPORT_SYMBOL(drm_fence_flush_old);
+EXPORT_SYMBOL(psb_drm_fence_flush_old);
 
-int drm_fence_object_wait(struct drm_fence_object *fence,
+int psb_drm_fence_object_wait(struct drm_fence_object *fence,
 			  int lazy, int ignore_signals, uint32_t mask)
 {
 	struct drm_device *dev = fence->dev;
@@ -396,17 +396,17 @@
 		return driver->wait(fence, lazy, !ignore_signals, mask);
 
 
-	drm_fence_object_flush(fence, mask);
+	psb_drm_fence_object_flush(fence, mask);
 	if (driver->has_irq(dev, fence->fence_class, mask)) {
 		if (!ignore_signals)
 			ret = wait_event_interruptible_timeout
 				(fc->fence_queue, 
-				 drm_fence_object_signaled(fence, mask), 
+				 psb_drm_fence_object_signaled(fence, mask), 
 				 3 * DRM_HZ);
 		else 
 			ret = wait_event_timeout
 				(fc->fence_queue, 
-				 drm_fence_object_signaled(fence, mask), 
+				 psb_drm_fence_object_signaled(fence, mask), 
 				 3 * DRM_HZ);
 
 		if (unlikely(ret == -ERESTARTSYS))
@@ -418,14 +418,14 @@
 		return 0;
 	}
 
-	return drm_fence_wait_polling(fence, lazy, !ignore_signals, mask,
+	return psb_drm_fence_wait_polling(fence, lazy, !ignore_signals, mask,
 				      _end);
 }
-EXPORT_SYMBOL(drm_fence_object_wait);
+EXPORT_SYMBOL(psb_drm_fence_object_wait);
 
 
 
-int drm_fence_object_emit(struct drm_fence_object *fence, uint32_t fence_flags,
+int psb_drm_fence_object_emit(struct drm_fence_object *fence, uint32_t fence_flags,
 			  uint32_t fence_class, uint32_t type)
 {
 	struct drm_device *dev = fence->dev;
@@ -458,7 +458,7 @@
 	write_unlock_irqrestore(&fm->lock, flags);
 	return 0;
 }
-EXPORT_SYMBOL(drm_fence_object_emit);
+EXPORT_SYMBOL(psb_drm_fence_object_emit);
 
 static int drm_fence_object_init(struct drm_device *dev, uint32_t fence_class,
 				 uint32_t type,
@@ -490,20 +490,20 @@
 	fence->dev = dev;
 	write_unlock_irqrestore(&fm->lock, flags);
 	if (fence_flags & DRM_FENCE_FLAG_EMIT) {
-		ret = drm_fence_object_emit(fence, fence_flags,
+		ret = psb_drm_fence_object_emit(fence, fence_flags,
 					    fence->fence_class, type);
 	}
 	return ret;
 }
 
-int drm_fence_add_user_object(struct drm_file *priv,
+int psb_drm_fence_add_user_object(struct drm_file *priv,
 			      struct drm_fence_object *fence, int shareable)
 {
 	struct drm_device *dev = priv->head->dev;
 	int ret;
 
 	mutex_lock(&dev->struct_mutex);
-	ret = drm_add_user_object(priv, &fence->base, shareable);
+	ret = psb_drm_add_user_object(priv, &fence->base, shareable);
 	if (ret)
 		goto out;
 	atomic_inc(&fence->usage);
@@ -514,9 +514,9 @@
 	mutex_unlock(&dev->struct_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(drm_fence_add_user_object);
+EXPORT_SYMBOL(psb_drm_fence_add_user_object);
 
-int drm_fence_object_create(struct drm_device *dev, uint32_t fence_class,
+int psb_drm_fence_object_create(struct drm_device *dev, uint32_t fence_class,
 			    uint32_t type, unsigned flags,
 			    struct drm_fence_object **c_fence)
 {
@@ -531,7 +531,7 @@
 	}
 	ret = drm_fence_object_init(dev, fence_class, type, flags, fence);
 	if (ret) {
-		drm_fence_usage_deref_unlocked(&fence);
+		psb_drm_fence_usage_deref_unlocked(&fence);
 		return ret;
 	}
 	*c_fence = fence;
@@ -539,7 +539,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_fence_object_create);
+EXPORT_SYMBOL(psb_drm_fence_object_create);
 
 void drm_fence_manager_init(struct drm_device *dev)
 {
@@ -572,7 +572,7 @@
 	write_unlock_irqrestore(&fm->lock, flags);
 }
 
-void drm_fence_fill_arg(struct drm_fence_object *fence,
+void psb_drm_fence_fill_arg(struct drm_fence_object *fence,
 			struct drm_fence_arg *arg)
 {
 	struct drm_device *dev = fence->dev;
@@ -588,7 +588,7 @@
 	arg->sequence = fence->sequence;
 	read_unlock_irqrestore(&fm->lock, irq_flags);
 }
-EXPORT_SYMBOL(drm_fence_fill_arg);
+EXPORT_SYMBOL(psb_drm_fence_fill_arg);
 
 void drm_fence_manager_takedown(struct drm_device *dev)
 {
@@ -602,7 +602,7 @@
 	struct drm_fence_object *fence;
 
 	mutex_lock(&dev->struct_mutex);
-	uo = drm_lookup_user_object(priv, handle);
+	uo = psb_drm_lookup_user_object(priv, handle);
 	if (!uo || (uo->type != drm_fence_type)) {
 		mutex_unlock(&dev->struct_mutex);
 		return NULL;
@@ -627,15 +627,15 @@
 
 	if (arg->flags & DRM_FENCE_FLAG_EMIT)
 		LOCK_TEST_WITH_RETURN(dev, file_priv);
-	ret = drm_fence_object_create(dev, arg->fence_class,
+	ret = psb_drm_fence_object_create(dev, arg->fence_class,
 				      arg->type, arg->flags, &fence);
 	if (ret)
 		return ret;
-	ret = drm_fence_add_user_object(file_priv, fence,
+	ret = psb_drm_fence_add_user_object(file_priv, fence,
 					arg->flags &
 					DRM_FENCE_FLAG_SHAREABLE);
 	if (ret) {
-		drm_fence_usage_deref_unlocked(&fence);
+		psb_drm_fence_usage_deref_unlocked(&fence);
 		return ret;
 	}
 
@@ -645,8 +645,8 @@
 
 	arg->handle = fence->base.hash.key;
 
-	drm_fence_fill_arg(fence, arg);
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_fill_arg(fence, arg);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 
 	return ret;
 }
@@ -669,8 +669,8 @@
 	if (ret)
 		return ret;
 	fence = drm_lookup_fence_object(file_priv, arg->handle);
-	drm_fence_fill_arg(fence, arg);
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_fill_arg(fence, arg);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 
 	return ret;
 }
@@ -708,8 +708,8 @@
 	if (!fence)
 		return -EINVAL;
 
-	drm_fence_fill_arg(fence, arg);
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_fill_arg(fence, arg);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 
 	return ret;
 }
@@ -730,10 +730,10 @@
 	fence = drm_lookup_fence_object(file_priv, arg->handle);
 	if (!fence)
 		return -EINVAL;
-	ret = drm_fence_object_flush(fence, arg->type);
+	ret = psb_drm_fence_object_flush(fence, arg->type);
 
-	drm_fence_fill_arg(fence, arg);
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_fill_arg(fence, arg);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 
 	return ret;
 }
@@ -755,12 +755,12 @@
 	fence = drm_lookup_fence_object(file_priv, arg->handle);
 	if (!fence)
 		return -EINVAL;
-	ret = drm_fence_object_wait(fence,
+	ret = psb_drm_fence_object_wait(fence,
 				    arg->flags & DRM_FENCE_FLAG_WAIT_LAZY,
 				    0, arg->type);
 
-	drm_fence_fill_arg(fence, arg);
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_fill_arg(fence, arg);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 
 	return ret;
 }
@@ -783,11 +783,11 @@
 	fence = drm_lookup_fence_object(file_priv, arg->handle);
 	if (!fence)
 		return -EINVAL;
-	ret = drm_fence_object_emit(fence, arg->flags, arg->fence_class,
+	ret = psb_drm_fence_object_emit(fence, arg->flags, arg->fence_class,
 				    arg->type);
 
-	drm_fence_fill_arg(fence, arg);
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_fill_arg(fence, arg);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 
 	return ret;
 }
@@ -810,13 +810,13 @@
 		return -EINVAL;
 	}
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
-	ret = drm_fence_buffer_objects(dev, NULL, arg->flags,
+	ret = psb_drm_fence_buffer_objects(dev, NULL, arg->flags,
 				       NULL, &fence);
 	if (ret)
 		return ret;
 
 	if (!(arg->flags & DRM_FENCE_FLAG_NO_USER)) {
-		ret = drm_fence_add_user_object(file_priv, fence,
+		ret = psb_drm_fence_add_user_object(file_priv, fence,
 						arg->flags &
 						DRM_FENCE_FLAG_SHAREABLE);
 		if (ret)
@@ -825,8 +825,8 @@
 
 	arg->handle = fence->base.hash.key;
 
-	drm_fence_fill_arg(fence, arg);
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_fill_arg(fence, arg);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 
 	return ret;
 }
diff -urNad psb-kernel-source-4.41.2/drm_fops.c psb-kernel-source-4.41.2.drm_psb/drm_fops.c
--- psb-kernel-source-4.41.2/drm_fops.c	2009-08-11 20:18:30.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_fops.c	2010-05-02 10:13:45.279193401 +0200
@@ -58,7 +58,7 @@
 
 	/* prebuild the SAREA */
 	sareapage = max(SAREA_MAX, PAGE_SIZE);
-	i = drm_addmap(dev, 0, sareapage, _DRM_SHM, _DRM_CONTAINS_LOCK, &map);
+	i = psb_drm_addmap(dev, 0, sareapage, _DRM_SHM, _DRM_CONTAINS_LOCK, &map);
 	if (i != 0)
 		return i;
 
@@ -125,7 +125,7 @@
  * increments the device open count. If the open count was previous at zero,
  * i.e., it's the first that the device is open, then calls setup().
  */
-int drm_open(struct inode *inode, struct file *filp)
+int psb_drm_open(struct inode *inode, struct file *filp)
 {
 	struct drm_device *dev = NULL;
 	int minor = iminor(inode);
@@ -162,7 +162,7 @@
 
 	return retcode;
 }
-EXPORT_SYMBOL(drm_open);
+EXPORT_SYMBOL(psb_drm_open);
 
 /**
  * File \c open operation.
@@ -245,7 +245,7 @@
 
 	DRM_DEBUG("pid = %d, minor = %d\n", current->pid, minor);
 
-	priv = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
+	priv = psb_drm_alloc(sizeof(*priv), DRM_MEM_FILES);
 	if (!priv)
 		return -ENOMEM;
 
@@ -312,13 +312,13 @@
 
 	return 0;
       out_free:
-	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
+	psb_drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
 	filp->private_data = NULL;
 	return ret;
 }
 
 /** No-op. */
-int drm_fasync(int fd, struct file *filp, int on)
+int psb_drm_fasync(int fd, struct file *filp, int on)
 {
 	struct drm_file *priv = filp->private_data;
 	struct drm_device *dev = priv->head->dev;
@@ -331,7 +331,7 @@
 		return retcode;
 	return 0;
 }
-EXPORT_SYMBOL(drm_fasync);
+EXPORT_SYMBOL(psb_drm_fasync);
 
 static void drm_object_release(struct file *filp)
 {
@@ -345,14 +345,14 @@
 	 * list_for_each() here, as the struct_mutex may be temporarily
 	 * released by the remove_() functions, and thus the lists may be
 	 * altered.
-	 * Also, a drm_remove_ref_object() will not remove it
+	 * Also, a psb_drm_remove_ref_object() will not remove it
 	 * from the list unless its refcount is 1.
 	 */
 
 	head = &priv->refd_objects;
 	while (head->next != head) {
 		ref_object = list_entry(head->next, struct drm_ref_object, list);
-		drm_remove_ref_object(priv, ref_object);
+		psb_drm_remove_ref_object(priv, ref_object);
 		head = &priv->refd_objects;
 	}
 
@@ -372,7 +372,7 @@
  * data from its list and free it. Decreases the open count and if it reaches
  * zero calls drm_lastclose().
  */
-int drm_release(struct inode *inode, struct file *filp)
+int psb_drm_release(struct inode *inode, struct file *filp)
 {
 	struct drm_file *file_priv = filp->private_data;
 	struct drm_device *dev = file_priv->head->dev;
@@ -386,7 +386,7 @@
 		dev->driver->preclose(dev, file_priv);
 
 	/* ========================================================
-	 * Begin inline drm_release
+	 * Begin inline psb_drm_release
 	 */
 
 	DRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",
@@ -394,13 +394,13 @@
 		  dev->open_count);
 
 	if (dev->driver->reclaim_buffers_locked && dev->lock.hw_lock) {
-		if (drm_i_have_hw_lock(dev, file_priv)) {
+		if (psb_drm_i_have_hw_lock(dev, file_priv)) {
 			dev->driver->reclaim_buffers_locked(dev, file_priv);
 		} else {
 			unsigned long _end=jiffies + 3*DRM_HZ;
 			int locked = 0;
 
-			drm_idlelock_take(&dev->lock);
+			psb_drm_idlelock_take(&dev->lock);
 
 			/*
 			 * Wait for a while.
@@ -422,19 +422,19 @@
 			}
 
 			dev->driver->reclaim_buffers_locked(dev, file_priv);
-			drm_idlelock_release(&dev->lock);
+			psb_drm_idlelock_release(&dev->lock);
 		}
 	}
 
 	if (dev->driver->reclaim_buffers_idlelocked && dev->lock.hw_lock) {
 
-		drm_idlelock_take(&dev->lock);
+		psb_drm_idlelock_take(&dev->lock);
 		dev->driver->reclaim_buffers_idlelocked(dev, file_priv);
-		drm_idlelock_release(&dev->lock);
+		psb_drm_idlelock_release(&dev->lock);
 
 	}
 
-	if (drm_i_have_hw_lock(dev, file_priv)) {
+	if (psb_drm_i_have_hw_lock(dev, file_priv)) {
 		DRM_DEBUG("File %p released, freeing lock for context %d\n",
 			  filp, _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
 
@@ -448,7 +448,7 @@
 		dev->driver->reclaim_buffers(dev, file_priv);
 	}
 
-	drm_fasync(-1, filp, 0);
+	psb_drm_fasync(-1, filp, 0);
 
 	mutex_lock(&dev->ctxlist_mutex);
 
@@ -465,7 +465,7 @@
 				drm_ctxbitmap_free(dev, pos->handle);
 
 				list_del(&pos->head);
-				drm_free(pos, sizeof(*pos), DRM_MEM_CTXLIST);
+				psb_drm_free(pos, sizeof(*pos), DRM_MEM_CTXLIST);
 				--dev->ctx_count;
 			}
 		}
@@ -486,10 +486,10 @@
 
 	if (dev->driver->postclose)
 		dev->driver->postclose(dev, file_priv);
-	drm_free(file_priv, sizeof(*file_priv), DRM_MEM_FILES);
+	psb_drm_free(file_priv, sizeof(*file_priv), DRM_MEM_FILES);
 
 	/* ========================================================
-	 * End inline drm_release
+	 * End inline psb_drm_release
 	 */
 
 	atomic_inc(&dev->counts[_DRM_STAT_CLOSES]);
@@ -512,7 +512,7 @@
 
 	return retcode;
 }
-EXPORT_SYMBOL(drm_release);
+EXPORT_SYMBOL(psb_drm_release);
 
 /** No-op. */
 /* This is to deal with older X servers that believe 0 means data is
@@ -523,9 +523,9 @@
  * http://freedesktop.org/bugzilla/show_bug.cgi?id=1505 if you try
  * to return the correct response.
  */
-unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait)
+unsigned int psb_drm_poll(struct file *filp, struct poll_table_struct *wait)
 {
 	/* return (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM); */
 	return 0;
 }
-EXPORT_SYMBOL(drm_poll);
+EXPORT_SYMBOL(psb_drm_poll);
diff -urNad psb-kernel-source-4.41.2/drm.h psb-kernel-source-4.41.2.drm_psb/drm.h
--- psb-kernel-source-4.41.2/drm.h	2009-04-16 05:25:02.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm.h	2010-05-02 10:13:43.055191200 +0200
@@ -593,7 +593,7 @@
  * drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),
  * drmAgpVendorId() and drmAgpDeviceId().
  */
-struct drm_agp_info {
+struct psb_drm_agp_info {
 	int agp_version_major;
 	int agp_version_minor;
 	unsigned long mode;
@@ -1076,7 +1076,7 @@
 #define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)
 #define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)
 #define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)
-#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)
+#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct psb_drm_agp_info)
 #define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)
 #define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)
 #define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)
@@ -1179,7 +1179,7 @@
 typedef enum drm_vblank_seq_type drm_vblank_seq_type_t;
 typedef struct drm_agp_buffer drm_agp_buffer_t;
 typedef struct drm_agp_binding drm_agp_binding_t;
-typedef struct drm_agp_info drm_agp_info_t;
+typedef struct psb_drm_agp_info drm_agp_info_t;
 typedef struct drm_scatter_gather drm_scatter_gather_t;
 typedef struct drm_set_version drm_set_version_t;
 
diff -urNad psb-kernel-source-4.41.2/drm_hashtab.c psb-kernel-source-4.41.2.drm_psb/drm_hashtab.c
--- psb-kernel-source-4.41.2/drm_hashtab.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_hashtab.c	2010-05-02 10:13:41.971194130 +0200
@@ -46,7 +46,7 @@
 	ht->table = NULL;
 	ht->use_vmalloc = ((ht->size * sizeof(*ht->table)) > PAGE_SIZE);
 	if (!ht->use_vmalloc) {
-		ht->table = drm_calloc(ht->size, sizeof(*ht->table),
+		ht->table = psb_drm_calloc(ht->size, sizeof(*ht->table),
 				       DRM_MEM_HASHTAB);
 	}
 	if (!ht->table) {
@@ -195,7 +195,7 @@
 		if (ht->use_vmalloc)
 			vfree(ht->table);
 		else
-			drm_free(ht->table, ht->size * sizeof(*ht->table),
+			psb_drm_free(ht->table, ht->size * sizeof(*ht->table),
 				 DRM_MEM_HASHTAB);
 		ht->table = NULL;
 	}
diff -urNad psb-kernel-source-4.41.2/drm_ioc32.c psb-kernel-source-4.41.2.drm_psb/drm_ioc32.c
--- psb-kernel-source-4.41.2/drm_ioc32.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_ioc32.c	2010-05-02 10:13:42.907192982 +0200
@@ -102,7 +102,7 @@
 			  &version->desc))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_VERSION, (unsigned long)version);
 	if (err)
 		return err;
@@ -143,7 +143,7 @@
 			  &u->unique))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_GET_UNIQUE, (unsigned long)u);
 	if (err)
 		return err;
@@ -172,7 +172,7 @@
 			  &u->unique))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_SET_UNIQUE, (unsigned long)u);
 }
 
@@ -203,7 +203,7 @@
 	if (__put_user(idx, &map->offset))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_GET_MAP, (unsigned long)map);
 	if (err)
 		return err;
@@ -244,7 +244,7 @@
 	    || __put_user(m32.flags, &map->flags))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_ADD_MAP, (unsigned long)map);
 	if (err)
 		return err;
@@ -282,7 +282,7 @@
 	if (__put_user((void *)(unsigned long)handle, &map->handle))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_RM_MAP, (unsigned long)map);
 }
 
@@ -312,7 +312,7 @@
 	if (__put_user(idx, &client->idx))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_GET_CLIENT, (unsigned long)client);
 	if (err)
 		return err;
@@ -349,7 +349,7 @@
 	if (!access_ok(VERIFY_WRITE, stats, sizeof(*stats)))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_GET_STATS, (unsigned long)stats);
 	if (err)
 		return err;
@@ -393,7 +393,7 @@
 	    || __put_user(agp_start, &buf->agp_start))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_ADD_BUFS, (unsigned long)buf);
 	if (err)
 		return err;
@@ -425,7 +425,7 @@
 	    || __put_user(b32.high_mark, &buf->high_mark))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_MARK_BUFS, (unsigned long)buf);
 }
 
@@ -467,7 +467,7 @@
 	    || __put_user(list, &request->list))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_INFO_BUFS, (unsigned long)request);
 	if (err)
 		return err;
@@ -529,7 +529,7 @@
 	    || __put_user(list, &request->list))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_MAP_BUFS, (unsigned long)request);
 	if (err)
 		return err;
@@ -576,7 +576,7 @@
 			  &request->list))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_FREE_BUFS, (unsigned long)request);
 }
 
@@ -603,7 +603,7 @@
 			  &request->handle))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_SET_SAREA_CTX, (unsigned long)request);
 }
 
@@ -626,7 +626,7 @@
 	if (__put_user(ctx_id, &request->ctx_id))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_GET_SAREA_CTX, (unsigned long)request);
 	if (err)
 		return err;
@@ -662,7 +662,7 @@
 			  &res->contexts))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_RES_CTX, (unsigned long)res);
 	if (err)
 		return err;
@@ -716,7 +716,7 @@
 			  &d->request_sizes))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_DMA, (unsigned long)d);
 	if (err)
 		return err;
@@ -749,7 +749,7 @@
 	if (put_user(m32.mode, &mode->mode))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_AGP_ENABLE, (unsigned long)mode);
 }
 
@@ -772,14 +772,14 @@
 {
 	drm_agp_info32_t __user *argp = (void __user *)arg;
 	drm_agp_info32_t i32;
-	struct drm_agp_info __user *info;
+	struct psb_drm_agp_info __user *info;
 	int err;
 
 	info = compat_alloc_user_space(sizeof(*info));
 	if (!access_ok(VERIFY_WRITE, info, sizeof(*info)))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_AGP_INFO, (unsigned long)info);
 	if (err)
 		return err;
@@ -825,7 +825,7 @@
 	    || __put_user(req32.type, &request->type))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_AGP_ALLOC, (unsigned long)request);
 	if (err)
 		return err;
@@ -833,7 +833,7 @@
 	if (__get_user(req32.handle, &request->handle)
 	    || __get_user(req32.physical, &request->physical)
 	    || copy_to_user(argp, &req32, sizeof(req32))) {
-		drm_ioctl(file->f_dentry->d_inode, file,
+		psb_drm_ioctl(file->f_dentry->d_inode, file,
 			  DRM_IOCTL_AGP_FREE, (unsigned long)request);
 		return -EFAULT;
 	}
@@ -854,7 +854,7 @@
 	    || __put_user(handle, &request->handle))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_AGP_FREE, (unsigned long)request);
 }
 
@@ -879,7 +879,7 @@
 	    || __put_user(req32.offset, &request->offset))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_AGP_BIND, (unsigned long)request);
 }
 
@@ -896,7 +896,7 @@
 	    || __put_user(handle, &request->handle))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_AGP_UNBIND, (unsigned long)request);
 }
 #endif				/* __OS_HAS_AGP */
@@ -921,7 +921,7 @@
 	    || __put_user(x, &request->size))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_SG_ALLOC, (unsigned long)request);
 	if (err)
 		return err;
@@ -948,7 +948,7 @@
 	    || __put_user(x << PAGE_SHIFT, &request->handle))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_SG_FREE, (unsigned long)request);
 }
 
@@ -988,7 +988,7 @@
 	    || __put_user(req32.request.signal, &request->request.signal))
 		return -EFAULT;
 
-	err = drm_ioctl(file->f_dentry->d_inode, file,
+	err = psb_drm_ioctl(file->f_dentry->d_inode, file,
 			DRM_IOCTL_WAIT_VBLANK, (unsigned long)request);
 	if (err)
 		return err;
@@ -1045,7 +1045,7 @@
  * \param arg user argument.
  * \return zero on success or negative number on failure.
  */
-long drm_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+long psb_drm_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	unsigned int nr = DRM_IOCTL_NR(cmd);
 	drm_ioctl_compat_t *fn;
@@ -1057,7 +1057,7 @@
 	 * than always failing.
 	 */
 	if (nr >= DRM_ARRAY_SIZE(drm_compat_ioctls))
-		return drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+		return psb_drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
 
 	fn = drm_compat_ioctls[nr];
 
@@ -1065,9 +1065,9 @@
 	if (fn != NULL)
 		ret = (*fn)(filp, cmd, arg);
 	else
-		ret = drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+		ret = psb_drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
 	unlock_kernel();
 
 	return ret;
 }
-EXPORT_SYMBOL(drm_compat_ioctl);
+EXPORT_SYMBOL(psb_drm_compat_ioctl);
diff -urNad psb-kernel-source-4.41.2/drm_ioctl.c psb-kernel-source-4.41.2.drm_psb/drm_ioctl.c
--- psb-kernel-source-4.41.2/drm_ioctl.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_ioctl.c	2010-05-02 10:13:44.991191091 +0200
@@ -1,5 +1,5 @@
 /**
- * \file drm_ioctl.c
+ * \file psb_drm_ioctl.c
  * IOCTL processing for DRM
  *
  * \author Rickard E. (Rik) Faith <faith@valinux.com>
@@ -90,7 +90,7 @@
 		return -EINVAL;
 
 	dev->unique_len = u->unique_len;
-	dev->unique = drm_alloc(u->unique_len + 1, DRM_MEM_DRIVER);
+	dev->unique = psb_drm_alloc(u->unique_len + 1, DRM_MEM_DRIVER);
 	if (!dev->unique)
 		return -ENOMEM;
 	if (copy_from_user(dev->unique, u->unique, dev->unique_len))
@@ -98,7 +98,7 @@
 
 	dev->unique[dev->unique_len] = '\0';
 
-	dev->devname = drm_alloc(strlen(dev->driver->pci_driver.name) + strlen(dev->unique) + 2,
+	dev->devname = psb_drm_alloc(strlen(dev->driver->pci_driver.name) + strlen(dev->unique) + 2,
 				 DRM_MEM_DRIVER);
 	if (!dev->devname)
 		return -ENOMEM;
@@ -130,7 +130,7 @@
 		return -EBUSY;
 
 	dev->unique_len = 40;
-	dev->unique = drm_alloc(dev->unique_len + 1, DRM_MEM_DRIVER);
+	dev->unique = psb_drm_alloc(dev->unique_len + 1, DRM_MEM_DRIVER);
 	if (dev->unique == NULL)
 		return -ENOMEM;
 
@@ -142,7 +142,7 @@
 	if (len > dev->unique_len)
 		DRM_ERROR("buffer overflow");
 
-	dev->devname = drm_alloc(strlen(dev->driver->pci_driver.name) + dev->unique_len + 2,
+	dev->devname = psb_drm_alloc(strlen(dev->driver->pci_driver.name) + dev->unique_len + 2,
 				 DRM_MEM_DRIVER);
 	if (dev->devname == NULL)
 		return -ENOMEM;
diff -urNad psb-kernel-source-4.41.2/drm_irq.c psb-kernel-source-4.41.2.drm_psb/drm_irq.c
--- psb-kernel-source-4.41.2/drm_irq.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_irq.c	2010-05-02 10:13:44.967192787 +0200
@@ -80,7 +80,7 @@
  * \c drm_driver_irq_preinstall() and \c drm_driver_irq_postinstall() functions
  * before and after the installation.
  */
-int drm_irq_install(struct drm_device * dev)
+int psb_drm_irq_install(struct drm_device * dev)
 {
 	int ret;
 	unsigned long sh_flags = 0;
@@ -140,7 +140,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_irq_install);
+EXPORT_SYMBOL(psb_drm_irq_install);
 
 /**
  * Uninstall the IRQ handler.
@@ -149,7 +149,7 @@
  *
  * Calls the driver's \c drm_driver_irq_uninstall() function, and stops the irq.
  */
-int drm_irq_uninstall(struct drm_device * dev)
+int psb_drm_irq_uninstall(struct drm_device * dev)
 {
 	int irq_enabled;
 
@@ -174,7 +174,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_irq_uninstall);
+EXPORT_SYMBOL(psb_drm_irq_uninstall);
 
 /**
  * IRQ control ioctl.
@@ -202,11 +202,11 @@
 		if (dev->if_version < DRM_IF_VERSION(1, 2) &&
 		    ctl->irq != dev->irq)
 			return -EINVAL;
-		return drm_irq_install(dev);
+		return psb_drm_irq_install(dev);
 	case DRM_UNINST_HANDLER:
 		if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
 			return 0;
-		return drm_irq_uninstall(dev);
+		return psb_drm_irq_uninstall(dev);
 	default:
 		return -EINVAL;
 	}
@@ -308,7 +308,7 @@
 
 		if (!
 		    (vbl_sig =
-		     drm_alloc(sizeof(struct drm_vbl_sig), DRM_MEM_DRIVER))) {
+		     psb_drm_alloc(sizeof(struct drm_vbl_sig), DRM_MEM_DRIVER))) {
 			return -ENOMEM;
 		}
 
@@ -355,7 +355,7 @@
  *
  * If a signal is not requested, then calls vblank_wait().
  */
-void drm_vbl_send_signals(struct drm_device * dev)
+void psb_drm_vbl_send_signals(struct drm_device * dev)
 {
 	unsigned long flags;
 	int i;
@@ -376,7 +376,7 @@
 
 				list_del(&vbl_sig->head);
 
-				drm_free(vbl_sig, sizeof(*vbl_sig),
+				psb_drm_free(vbl_sig, sizeof(*vbl_sig),
 					 DRM_MEM_DRIVER);
 
 				dev->vbl_pending--;
@@ -386,7 +386,7 @@
 
 	spin_unlock_irqrestore(&dev->vbl_lock, flags);
 }
-EXPORT_SYMBOL(drm_vbl_send_signals);
+EXPORT_SYMBOL(psb_drm_vbl_send_signals);
 
 /**
  * Tasklet wrapper function.
@@ -436,7 +436,7 @@
  * context, it must not make any assumptions about this. Also, the HW lock will
  * be held with the kernel context or any client context.
  */
-void drm_locked_tasklet(struct drm_device *dev, void (*func)(struct drm_device *))
+void psb_drm_locked_tasklet(struct drm_device *dev, void (*func)(struct drm_device *))
 {
 	unsigned long irqflags;
 	static DECLARE_TASKLET(drm_tasklet, drm_locked_tasklet_func, 0);
@@ -460,4 +460,4 @@
 
 	tasklet_hi_schedule(&drm_tasklet);
 }
-EXPORT_SYMBOL(drm_locked_tasklet);
+EXPORT_SYMBOL(psb_drm_locked_tasklet);
diff -urNad psb-kernel-source-4.41.2/drm_lock.c psb-kernel-source-4.41.2.drm_psb/drm_lock.c
--- psb-kernel-source-4.41.2/drm_lock.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_lock.c	2010-05-02 10:13:44.855193354 +0200
@@ -342,7 +342,7 @@
  * having to worry about starvation.
  */
 
-void drm_idlelock_take(struct drm_lock_data *lock_data)
+void psb_drm_idlelock_take(struct drm_lock_data *lock_data)
 {
 	int ret = 0;
 
@@ -359,9 +359,9 @@
 	}
 	spin_unlock(&lock_data->spinlock);
 }
-EXPORT_SYMBOL(drm_idlelock_take);
+EXPORT_SYMBOL(psb_drm_idlelock_take);
 
-void drm_idlelock_release(struct drm_lock_data *lock_data)
+void psb_drm_idlelock_release(struct drm_lock_data *lock_data)
 {
 	unsigned int old, prev;
 	volatile unsigned int *lock = &lock_data->hw_lock->lock;
@@ -379,10 +379,10 @@
 	}
 	spin_unlock(&lock_data->spinlock);
 }
-EXPORT_SYMBOL(drm_idlelock_release);
+EXPORT_SYMBOL(psb_drm_idlelock_release);
 
 
-int drm_i_have_hw_lock(struct drm_device *dev, struct drm_file *file_priv)
+int psb_drm_i_have_hw_lock(struct drm_device *dev, struct drm_file *file_priv)
 {
 
 	return (file_priv->lock_count && dev->lock.hw_lock &&
@@ -390,4 +390,4 @@
 		dev->lock.file_priv == file_priv);
 }
 
-EXPORT_SYMBOL(drm_i_have_hw_lock);
+EXPORT_SYMBOL(psb_drm_i_have_hw_lock);
diff -urNad psb-kernel-source-4.41.2/drm_memory.c psb-kernel-source-4.41.2.drm_psb/drm_memory.c
--- psb-kernel-source-4.41.2/drm_memory.c	2009-08-11 20:18:30.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_memory.c	2010-05-02 10:13:41.855193909 +0200
@@ -75,7 +75,7 @@
 	return ret;
 }
 
-void drm_free_memctl(size_t size)
+void psb_drm_free_memctl(size_t size)
 {
 	unsigned long a_size = drm_size_align(size);
 
@@ -90,9 +90,9 @@
 	drm_memctl.cur_used -= a_size;
 	spin_unlock(&drm_memctl.lock);
 }
-EXPORT_SYMBOL(drm_free_memctl);
+EXPORT_SYMBOL(psb_drm_free_memctl);
 
-void drm_query_memctl(uint64_t *cur_used,
+void psb_drm_query_memctl(uint64_t *cur_used,
 		      uint64_t *emer_used,
 		      uint64_t *low_threshold,
 		      uint64_t *high_threshold,
@@ -106,7 +106,7 @@
 	*emer_threshold = drm_memctl.emer_threshold;
 	spin_unlock(&drm_memctl.lock);
 }
-EXPORT_SYMBOL(drm_query_memctl);
+EXPORT_SYMBOL(psb_drm_query_memctl);
 
 void drm_init_memctl(size_t p_low_threshold,
 		     size_t p_high_threshold,
@@ -150,14 +150,14 @@
 }
 
 /** Wrapper around kmalloc() */
-void *drm_calloc(size_t nmemb, size_t size, int area)
+void *psb_drm_calloc(size_t nmemb, size_t size, int area)
 {
 	return kcalloc(nmemb, size, GFP_KERNEL);
 }
-EXPORT_SYMBOL(drm_calloc);
+EXPORT_SYMBOL(psb_drm_calloc);
 
 /** Wrapper around kmalloc() and kfree() */
-void *drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
+void *psb_drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
 {
 	void *pt;
 
@@ -295,7 +295,7 @@
 /** Wrapper around agp_bind_memory() */
 int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start)
 {
-	return drm_agp_bind_memory(handle, start);
+	return psb_drm_agp_bind_memory(handle, start);
 }
 
 /** Wrapper around agp_unbind_memory() */
@@ -319,7 +319,7 @@
 }
 #endif				/* debug_memory */
 
-void drm_core_ioremap(struct drm_map *map, struct drm_device *dev)
+void psb_drm_core_ioremap(struct drm_map *map, struct drm_device *dev)
 {
 	if (drm_core_has_AGP(dev) &&
 	    dev->agp && dev->agp->cant_use_aperture && map->type == _DRM_AGP)
@@ -327,9 +327,9 @@
 	else
 		map->handle = ioremap(map->offset, map->size);
 }
-EXPORT_SYMBOL_GPL(drm_core_ioremap);
+EXPORT_SYMBOL_GPL(psb_drm_core_ioremap);
 
-void drm_core_ioremapfree(struct drm_map *map, struct drm_device *dev)
+void psb_drm_core_ioremapfree(struct drm_map *map, struct drm_device *dev)
 {
 	if (!map->handle || !map->size)
 		return;
@@ -340,4 +340,4 @@
 	else
 		iounmap(map->handle);
 }
-EXPORT_SYMBOL_GPL(drm_core_ioremapfree);
+EXPORT_SYMBOL_GPL(psb_drm_core_ioremapfree);
diff -urNad psb-kernel-source-4.41.2/drm_memory_debug.c psb-kernel-source-4.41.2.drm_psb/drm_memory_debug.c
--- psb-kernel-source-4.41.2/drm_memory_debug.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_memory_debug.c	2010-05-02 10:13:42.823193266 +0200
@@ -147,7 +147,7 @@
 	return ret;
 }
 
-void *drm_alloc(size_t size, int area)
+void *psb_drm_alloc(size_t size, int area)
 {
 	void *pt;
 
@@ -168,35 +168,35 @@
 	spin_unlock(&drm_mem_lock);
 	return pt;
 }
-EXPORT_SYMBOL(drm_alloc);
+EXPORT_SYMBOL(psb_drm_alloc);
 
-void *drm_calloc(size_t nmemb, size_t size, int area)
+void *psb_drm_calloc(size_t nmemb, size_t size, int area)
 {
 	void *addr;
 
-	addr = drm_alloc(nmemb * size, area);
+	addr = psb_drm_alloc(nmemb * size, area);
 	if (addr != NULL)
 		memset((void *)addr, 0, size * nmemb);
 
 	return addr;
 }
-EXPORT_SYMBOL(drm_calloc);
+EXPORT_SYMBOL(psb_drm_calloc);
 
-void *drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
+void *psb_drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
 {
 	void *pt;
 
-	if (!(pt = drm_alloc(size, area)))
+	if (!(pt = psb_drm_alloc(size, area)))
 		return NULL;
 	if (oldpt && oldsize) {
 		memcpy(pt, oldpt, oldsize);
-		drm_free(oldpt, oldsize, area);
+		psb_drm_free(oldpt, oldsize, area);
 	}
 	return pt;
 }
-EXPORT_SYMBOL(drm_realloc);
+EXPORT_SYMBOL(psb_drm_realloc);
 
-void drm_free(void *pt, size_t size, int area)
+void psb_drm_free(void *pt, size_t size, int area)
 {
 	int alloc_count;
 	int free_count;
@@ -215,7 +215,7 @@
 			      free_count, alloc_count);
 	}
 }
-EXPORT_SYMBOL(drm_free);
+EXPORT_SYMBOL(psb_drm_free);
 
 unsigned long drm_alloc_pages(int order, int area)
 {
@@ -357,7 +357,7 @@
 		return retcode;
 	}
 
-	if (!(retcode = drm_agp_bind_memory(handle, start))) {
+	if (!(retcode = psb_drm_agp_bind_memory(handle, start))) {
 		spin_lock(&drm_mem_lock);
 		++drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
 		drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_allocated
diff -urNad psb-kernel-source-4.41.2/drm_memory_debug.h psb-kernel-source-4.41.2.drm_psb/drm_memory_debug.h
--- psb-kernel-source-4.41.2/drm_memory_debug.h	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_memory_debug.h	2010-05-02 10:13:44.799192939 +0200
@@ -143,7 +143,7 @@
 	return ret;
 }
 
-void *drm_alloc (size_t size, int area) {
+void *psb_drm_alloc (size_t size, int area) {
 	void *pt;
 
 	if (!size) {
@@ -164,29 +164,29 @@
 	return pt;
 }
 
-void *drm_calloc (size_t nmemb, size_t size, int area) {
+void *psb_drm_calloc (size_t nmemb, size_t size, int area) {
 	void *addr;
 
-	addr = drm_alloc (nmemb * size, area);
+	addr = psb_drm_alloc (nmemb * size, area);
 	if (addr != NULL)
 		memset((void *)addr, 0, size * nmemb);
 
 	return addr;
 }
 
-void *drm_realloc (void *oldpt, size_t oldsize, size_t size, int area) {
+void *psb_drm_realloc (void *oldpt, size_t oldsize, size_t size, int area) {
 	void *pt;
 
-	if (!(pt = drm_alloc (size, area)))
+	if (!(pt = psb_drm_alloc (size, area)))
 		return NULL;
 	if (oldpt && oldsize) {
 		memcpy(pt, oldpt, oldsize);
-		drm_free (oldpt, oldsize, area);
+		psb_drm_free (oldpt, oldsize, area);
 	}
 	return pt;
 }
 
-void drm_free (void *pt, size_t size, int area) {
+void psb_drm_free (void *pt, size_t size, int area) {
 	int alloc_count;
 	int free_count;
 
@@ -336,7 +336,7 @@
 		return retcode;
 	}
 
-	if (!(retcode = drm_agp_bind_memory (handle, start))) {
+	if (!(retcode = psb_drm_agp_bind_memory (handle, start))) {
 		spin_lock(&drm_mem_lock);
 		++drm_mem_stats[DRM_MEM_BOUNDAGP].succeed_count;
 		drm_mem_stats[DRM_MEM_BOUNDAGP].bytes_allocated
diff -urNad psb-kernel-source-4.41.2/drm_mm.c psb-kernel-source-4.41.2.drm_psb/drm_mm.c
--- psb-kernel-source-4.41.2/drm_mm.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_mm.c	2010-05-02 10:13:45.751192497 +0200
@@ -82,7 +82,7 @@
 	struct drm_mm_node *child;
 
 	child = (struct drm_mm_node *)
-		drm_alloc(sizeof(*child), DRM_MEM_MM);
+		psb_drm_alloc(sizeof(*child), DRM_MEM_MM);
 	if (!child)
 		return -ENOMEM;
 
@@ -118,7 +118,7 @@
 	struct drm_mm_node *child;
 
 	child = (struct drm_mm_node *)
-		drm_alloc(sizeof(*child), DRM_MEM_MM);
+		psb_drm_alloc(sizeof(*child), DRM_MEM_MM);
 	if (!child)
 		return NULL;
 
@@ -163,7 +163,7 @@
 	}
 
 	if (align_splitoff)
-		drm_mm_put_block(align_splitoff);
+		psb_drm_mm_put_block(align_splitoff);
 
 	return child;
 }
@@ -173,7 +173,7 @@
  * Otherwise add to the free stack.
  */
 
-void drm_mm_put_block(struct drm_mm_node * cur)
+void psb_drm_mm_put_block(struct drm_mm_node * cur)
 {
 
 	struct drm_mm *mm = cur->mm;
@@ -198,7 +198,7 @@
 				prev_node->size += next_node->size;
 				list_del(&next_node->ml_entry);
 				list_del(&next_node->fl_entry);
-				drm_free(next_node, sizeof(*next_node),
+				psb_drm_free(next_node, sizeof(*next_node),
 					     DRM_MEM_MM);
 			} else {
 				next_node->size += cur->size;
@@ -212,10 +212,10 @@
 		list_add(&cur->fl_entry, &mm->fl_entry);
 	} else {
 		list_del(&cur->ml_entry);
-		drm_free(cur, sizeof(*cur), DRM_MEM_MM);
+		psb_drm_free(cur, sizeof(*cur), DRM_MEM_MM);
 	}
 }
-EXPORT_SYMBOL(drm_mm_put_block);
+EXPORT_SYMBOL(psb_drm_mm_put_block);
 
 struct drm_mm_node *drm_mm_search_free(const struct drm_mm * mm,
 				  unsigned long size,
@@ -265,7 +265,7 @@
 	return (head->next->next == head);
 }
 
-int drm_mm_init(struct drm_mm * mm, unsigned long start, unsigned long size)
+int psb_drm_mm_init(struct drm_mm * mm, unsigned long start, unsigned long size)
 {
 	INIT_LIST_HEAD(&mm->ml_entry);
 	INIT_LIST_HEAD(&mm->fl_entry);
@@ -273,9 +273,9 @@
 	return drm_mm_create_tail_node(mm, start, size);
 }
 
-EXPORT_SYMBOL(drm_mm_init);
+EXPORT_SYMBOL(psb_drm_mm_init);
 
-void drm_mm_takedown(struct drm_mm * mm)
+void psb_drm_mm_takedown(struct drm_mm * mm)
 {
 	struct list_head *bnode = mm->fl_entry.next;
 	struct drm_mm_node *entry;
@@ -290,7 +290,7 @@
 
 	list_del(&entry->fl_entry);
 	list_del(&entry->ml_entry);
-	drm_free(entry, sizeof(*entry), DRM_MEM_MM);
+	psb_drm_free(entry, sizeof(*entry), DRM_MEM_MM);
 }
 
-EXPORT_SYMBOL(drm_mm_takedown);
+EXPORT_SYMBOL(psb_drm_mm_takedown);
diff -urNad psb-kernel-source-4.41.2/drm_modes.c psb-kernel-source-4.41.2.drm_psb/drm_modes.c
--- psb-kernel-source-4.41.2/drm_modes.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_modes.c	2010-05-02 10:13:45.547191649 +0200
@@ -34,7 +34,7 @@
 #include "drm_crtc.h"
 
 /**
- * drm_mode_debug_printmodeline - debug print a mode
+ * psb_drm_mode_debug_printmodeline - debug print a mode
  * @dev: DRM device
  * @mode: mode to print
  *
@@ -43,7 +43,7 @@
  *
  * Describe @mode using DRM_DEBUG.
  */
-void drm_mode_debug_printmodeline(struct drm_device *dev,
+void psb_drm_mode_debug_printmodeline(struct drm_device *dev,
 				  struct drm_display_mode *mode)
 {
 	DRM_DEBUG("Modeline %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x\n",
@@ -53,10 +53,10 @@
 		  mode->vdisplay, mode->vsync_start,
 		  mode->vsync_end, mode->vtotal, mode->type);
 }
-EXPORT_SYMBOL(drm_mode_debug_printmodeline);
+EXPORT_SYMBOL(psb_drm_mode_debug_printmodeline);
 
 /**
- * drm_mode_set_name - set the name on a mode
+ * psb_drm_mode_set_name - set the name on a mode
  * @mode: name will be set in this mode
  *
  * LOCKING:
@@ -64,12 +64,12 @@
  *
  * Set the name of @mode to a standard format.
  */
-void drm_mode_set_name(struct drm_display_mode *mode)
+void psb_drm_mode_set_name(struct drm_display_mode *mode)
 {
 	snprintf(mode->name, DRM_DISPLAY_MODE_LEN, "%dx%d", mode->hdisplay,
 		 mode->vdisplay);
 }
-EXPORT_SYMBOL(drm_mode_set_name);
+EXPORT_SYMBOL(psb_drm_mode_set_name);
 
 /**
  * drm_mode_list_concat - move modes from one list to another
@@ -92,7 +92,7 @@
 }
 
 /**
- * drm_mode_width - get the width of a mode
+ * psb_drm_mode_width - get the width of a mode
  * @mode: mode
  *
  * LOCKING:
@@ -105,15 +105,15 @@
  * RETURNS:
  * @mode->hdisplay
  */
-int drm_mode_width(struct drm_display_mode *mode)
+int psb_drm_mode_width(struct drm_display_mode *mode)
 {
 	return mode->hdisplay;
 
 }
-EXPORT_SYMBOL(drm_mode_width);
+EXPORT_SYMBOL(psb_drm_mode_width);
 
 /**
- * drm_mode_height - get the height of a mode
+ * psb_drm_mode_height - get the height of a mode
  * @mode: mode
  *
  * LOCKING:
@@ -126,14 +126,14 @@
  * RETURNS:
  * @mode->vdisplay
  */
-int drm_mode_height(struct drm_display_mode *mode)
+int psb_drm_mode_height(struct drm_display_mode *mode)
 {
 	return mode->vdisplay;
 }
-EXPORT_SYMBOL(drm_mode_height);
+EXPORT_SYMBOL(psb_drm_mode_height);
 
 /**
- * drm_mode_vrefresh - get the vrefresh of a mode
+ * psb_drm_mode_vrefresh - get the vrefresh of a mode
  * @mode: mode
  *
  * LOCKING:
@@ -146,7 +146,7 @@
  * RETURNS:
  * Vertical refresh rate of @mode x 1000. For precision reasons.
  */
-int drm_mode_vrefresh(struct drm_display_mode *mode)
+int psb_drm_mode_vrefresh(struct drm_display_mode *mode)
 {
 	int refresh = 0;
 	unsigned int calc_val;
@@ -171,10 +171,10 @@
 	}
 	return refresh;
 }
-EXPORT_SYMBOL(drm_mode_vrefresh);
+EXPORT_SYMBOL(psb_drm_mode_vrefresh);
 	
 /**
- * drm_mode_set_crtcinfo - set CRTC modesetting parameters
+ * psb_drm_mode_set_crtcinfo - set CRTC modesetting parameters
  * @p: mode
  * @adjust_flags: unused? (FIXME)
  *
@@ -183,7 +183,7 @@
  *
  * Setup the CRTC modesetting parameters for @p, adjusting if necessary.
  */
-void drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags)
+void psb_drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags)
 {
 	if ((p == NULL) || ((p->type & DRM_MODE_TYPE_CRTC_C) == DRM_MODE_TYPE_BUILTIN))
 		return;
@@ -231,11 +231,11 @@
 	p->crtc_hadjusted = false;
 	p->crtc_vadjusted = false;
 }
-EXPORT_SYMBOL(drm_mode_set_crtcinfo);
+EXPORT_SYMBOL(psb_drm_mode_set_crtcinfo);
 
 
 /**
- * drm_mode_duplicate - allocate and duplicate an existing mode
+ * psb_drm_mode_duplicate - allocate and duplicate an existing mode
  * @m: mode to duplicate
  *
  * LOCKING:
@@ -244,13 +244,13 @@
  * Just allocate a new mode, copy the existing mode into it, and return
  * a pointer to it.  Used to create new instances of established modes.
  */
-struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
+struct drm_display_mode *psb_drm_mode_duplicate(struct drm_device *dev,
 					    struct drm_display_mode *mode)
 {
 	struct drm_display_mode *nmode;
 	int new_id;
 
-	nmode = drm_mode_create(dev);
+	nmode = psb_drm_mode_create(dev);
 	if (!nmode)
 		return NULL;
 
@@ -260,10 +260,10 @@
 	INIT_LIST_HEAD(&nmode->head);
 	return nmode;
 }
-EXPORT_SYMBOL(drm_mode_duplicate);
+EXPORT_SYMBOL(psb_drm_mode_duplicate);
 
 /**
- * drm_mode_equal - test modes for equality
+ * psb_drm_mode_equal - test modes for equality
  * @mode1: first mode
  * @mode2: second mode
  *
@@ -275,7 +275,7 @@
  * RETURNS:
  * True if the modes are equal, false otherwise.
  */
-bool drm_mode_equal(struct drm_display_mode *mode1, struct drm_display_mode *mode2)
+bool psb_drm_mode_equal(struct drm_display_mode *mode1, struct drm_display_mode *mode2)
 {
 	if (mode1->clock == mode2->clock &&
 	    mode1->hdisplay == mode2->hdisplay &&
@@ -293,10 +293,10 @@
 	
 	return false;
 }
-EXPORT_SYMBOL(drm_mode_equal);
+EXPORT_SYMBOL(psb_drm_mode_equal);
 
 /**
- * drm_mode_validate_size - make sure modes adhere to size constraints
+ * psb_drm_mode_validate_size - make sure modes adhere to size constraints
  * @dev: DRM device
  * @mode_list: list of modes to check
  * @maxX: maximum width
@@ -310,7 +310,7 @@
  * modes we probed for @dev against those limits and set their status as
  * necessary.
  */
-void drm_mode_validate_size(struct drm_device *dev,
+void psb_drm_mode_validate_size(struct drm_device *dev,
 			    struct list_head *mode_list,
 			    int maxX, int maxY, int maxPitch)
 {
@@ -327,10 +327,10 @@
 			mode->status = MODE_VIRTUAL_Y;
 	}
 }
-EXPORT_SYMBOL(drm_mode_validate_size);
+EXPORT_SYMBOL(psb_drm_mode_validate_size);
 
 /**
- * drm_mode_validate_clocks - validate modes against clock limits
+ * psb_drm_mode_validate_clocks - validate modes against clock limits
  * @dev: DRM device
  * @mode_list: list of modes to check
  * @min: minimum clock rate array
@@ -345,7 +345,7 @@
  * sure each mode falls within a given range (defined by @min and @max
  * arrays) and sets @mode->status as needed.
  */
-void drm_mode_validate_clocks(struct drm_device *dev,
+void psb_drm_mode_validate_clocks(struct drm_device *dev,
 			      struct list_head *mode_list,
 			      int *min, int *max, int n_ranges)
 {
@@ -364,7 +364,7 @@
 			mode->status = MODE_CLOCK_RANGE;
 	}
 }
-EXPORT_SYMBOL(drm_mode_validate_clocks);
+EXPORT_SYMBOL(psb_drm_mode_validate_clocks);
 
 /**
  * drm_mode_prune_invalid - remove invalid modes from mode list
@@ -388,7 +388,7 @@
 		if (mode->status != MODE_OK) {
 			list_del(&mode->head);
 			if (verbose) {
-				drm_mode_debug_printmodeline(dev, mode);
+				psb_drm_mode_debug_printmodeline(dev, mode);
 				DRM_DEBUG("Not using %s mode %d\n", mode->name, mode->status);
 			}
 			kfree(mode);
@@ -543,7 +543,7 @@
 		found_it = 0;
 		/* go through current modes checking for the new probed mode */
 		list_for_each_entry(mode, &output->modes, head) {
-			if (drm_mode_equal(pmode, mode)) {
+			if (psb_drm_mode_equal(pmode, mode)) {
 				found_it = 1;
 				/* if equal delete the probed mode */
 				mode->status = pmode->status;
diff -urNad psb-kernel-source-4.41.2/drm_object.c psb-kernel-source-4.41.2.drm_psb/drm_object.c
--- psb-kernel-source-4.41.2/drm_object.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_object.c	2010-05-02 10:13:44.215192746 +0200
@@ -30,7 +30,7 @@
 
 #include "drmP.h"
 
-int drm_add_user_object(struct drm_file *priv, struct drm_user_object *item,
+int psb_drm_add_user_object(struct drm_file *priv, struct drm_user_object *item,
 			int shareable)
 {
 	struct drm_device *dev = priv->head->dev;
@@ -54,9 +54,9 @@
 
 	return ret;
 }
-EXPORT_SYMBOL(drm_add_user_object);
+EXPORT_SYMBOL(psb_drm_add_user_object);
 
-struct drm_user_object *drm_lookup_user_object(struct drm_file *priv, uint32_t key)
+struct drm_user_object *psb_drm_lookup_user_object(struct drm_file *priv, uint32_t key)
 {
 	struct drm_device *dev = priv->head->dev;
 	struct drm_hash_item *hash;
@@ -81,7 +81,7 @@
 	}
 	return item;
 }
-EXPORT_SYMBOL(drm_lookup_user_object);
+EXPORT_SYMBOL(psb_drm_lookup_user_object);
 
 static void drm_deref_user_object(struct drm_file *priv, struct drm_user_object *item)
 {
@@ -134,7 +134,7 @@
 
 	if ((ref_action != _DRM_REF_USE) && priv != referenced_object->owner) {
 		item =
-		    drm_lookup_ref_object(priv, referenced_object,
+		    psb_drm_lookup_ref_object(priv, referenced_object,
 					  _DRM_REF_USE);
 		if (!item) {
 			DRM_ERROR
@@ -145,7 +145,7 @@
 
 	if (NULL !=
 	    (item =
-	     drm_lookup_ref_object(priv, referenced_object, ref_action))) {
+	     psb_drm_lookup_ref_object(priv, referenced_object, ref_action))) {
 		atomic_inc(&item->refcount);
 		return drm_object_ref_action(priv, referenced_object,
 					     ref_action);
@@ -171,7 +171,7 @@
 	return ret;
 }
 
-struct drm_ref_object *drm_lookup_ref_object(struct drm_file *priv,
+struct drm_ref_object *psb_drm_lookup_ref_object(struct drm_file *priv,
 					struct drm_user_object *referenced_object,
 					enum drm_ref_type ref_action)
 {
@@ -186,7 +186,7 @@
 
 	return drm_hash_entry(hash, struct drm_ref_object, hash);
 }
-EXPORT_SYMBOL(drm_lookup_ref_object);
+EXPORT_SYMBOL(psb_drm_lookup_ref_object);
 
 static void drm_remove_other_references(struct drm_file *priv,
 					struct drm_user_object *ro)
@@ -200,12 +200,12 @@
 		ht = &priv->refd_object_hash[i];
 		while (!drm_ht_find_item(ht, (unsigned long)ro, &hash)) {
 			item = drm_hash_entry(hash, struct drm_ref_object, hash);
-			drm_remove_ref_object(priv, item);
+			psb_drm_remove_ref_object(priv, item);
 		}
 	}
 }
 
-void drm_remove_ref_object(struct drm_file *priv, struct drm_ref_object *item)
+void psb_drm_remove_ref_object(struct drm_file *priv, struct drm_ref_object *item)
 {
 	int ret;
 	struct drm_user_object *user_object = (struct drm_user_object *) item->hash.key;
@@ -234,7 +234,7 @@
 	}
 
 }
-EXPORT_SYMBOL(drm_remove_ref_object);
+EXPORT_SYMBOL(psb_drm_remove_ref_object);
 
 int drm_user_object_ref(struct drm_file *priv, uint32_t user_token,
 			enum drm_object_type type, struct drm_user_object **object)
@@ -275,17 +275,17 @@
 	int ret;
 
 	mutex_lock(&dev->struct_mutex);
-	uo = drm_lookup_user_object(priv, user_token);
+	uo = psb_drm_lookup_user_object(priv, user_token);
 	if (!uo || (uo->type != type)) {
 		ret = -EINVAL;
 		goto out_err;
 	}
-	ro = drm_lookup_ref_object(priv, uo, _DRM_REF_USE);
+	ro = psb_drm_lookup_ref_object(priv, uo, _DRM_REF_USE);
 	if (!ro) {
 		ret = -EINVAL;
 		goto out_err;
 	}
-	drm_remove_ref_object(priv, ro);
+	psb_drm_remove_ref_object(priv, ro);
 	mutex_unlock(&dev->struct_mutex);
 	return 0;
 out_err:
diff -urNad psb-kernel-source-4.41.2/drm_objects.h psb-kernel-source-4.41.2.drm_psb/drm_objects.h
--- psb-kernel-source-4.41.2/drm_objects.h	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_objects.h	2010-05-02 10:13:45.731192961 +0200
@@ -94,13 +94,13 @@
  * Must be called with the struct_mutex held.
  */
 
-extern int drm_add_user_object(struct drm_file *priv, struct drm_user_object *item,
+extern int psb_drm_add_user_object(struct drm_file *priv, struct drm_user_object *item,
 			       int shareable);
 /**
  * Must be called with the struct_mutex held.
  */
 
-extern struct drm_user_object *drm_lookup_user_object(struct drm_file *priv,
+extern struct drm_user_object *psb_drm_lookup_user_object(struct drm_file *priv,
 						 uint32_t key);
 
 /*
@@ -115,17 +115,17 @@
  * Must be called with the struct_mutex held.
  */
 
-struct drm_ref_object *drm_lookup_ref_object(struct drm_file *priv,
+struct drm_ref_object *psb_drm_lookup_ref_object(struct drm_file *priv,
 					struct drm_user_object *referenced_object,
 					enum drm_ref_type ref_action);
 /*
  * Must be called with the struct_mutex held.
- * If "item" has been obtained by a call to drm_lookup_ref_object. You may not
- * release the struct_mutex before calling drm_remove_ref_object.
+ * If "item" has been obtained by a call to psb_drm_lookup_ref_object. You may not
+ * release the struct_mutex before calling psb_drm_remove_ref_object.
  * This function may temporarily release the struct_mutex.
  */
 
-extern void drm_remove_ref_object(struct drm_file *priv, struct drm_ref_object *item);
+extern void psb_drm_remove_ref_object(struct drm_file *priv, struct drm_ref_object *item);
 extern int drm_user_object_ref(struct drm_file *priv, uint32_t user_token,
 			       enum drm_object_type type,
 			       struct drm_user_object **object);
@@ -193,7 +193,7 @@
 	 * signal for fc->highest_received_sequence and all preceding sequences.
 	 * Acknowledge by clearing the flags fc->pending_flush.
 	 *
-	 * poll() : Call drm_fence_handler with any new information.
+	 * poll() : Call psb_drm_fence_handler with any new information.
 	 *
 	 * needed_flush() : Given the current state of the fence->type flags and previusly 
 	 * executed or queued flushes, return the type_flags that need flushing.
@@ -215,37 +215,37 @@
 		     int interruptible, uint32_t mask);
 };
 
-extern int drm_fence_wait_polling(struct drm_fence_object *fence, int lazy,
+extern int psb_drm_fence_wait_polling(struct drm_fence_object *fence, int lazy,
 				  int interruptible, uint32_t mask,
 				  unsigned long end_jiffies);
-extern void drm_fence_handler(struct drm_device *dev, uint32_t fence_class,
+extern void psb_drm_fence_handler(struct drm_device *dev, uint32_t fence_class,
 			      uint32_t sequence, uint32_t type,
 			      uint32_t error);
 extern void drm_fence_manager_init(struct drm_device *dev);
 extern void drm_fence_manager_takedown(struct drm_device *dev);
-extern void drm_fence_flush_old(struct drm_device *dev, uint32_t fence_class,
+extern void psb_drm_fence_flush_old(struct drm_device *dev, uint32_t fence_class,
 				uint32_t sequence);
-extern int drm_fence_object_flush(struct drm_fence_object *fence,
+extern int psb_drm_fence_object_flush(struct drm_fence_object *fence,
 				  uint32_t type);
-extern int drm_fence_object_signaled(struct drm_fence_object *fence,
+extern int psb_drm_fence_object_signaled(struct drm_fence_object *fence,
 				     uint32_t type);
-extern void drm_fence_usage_deref_locked(struct drm_fence_object **fence);
-extern void drm_fence_usage_deref_unlocked(struct drm_fence_object **fence);
+extern void psb_drm_fence_usage_deref_locked(struct drm_fence_object **fence);
+extern void psb_drm_fence_usage_deref_unlocked(struct drm_fence_object **fence);
 extern struct drm_fence_object *drm_fence_reference_locked(struct drm_fence_object *src);
-extern void drm_fence_reference_unlocked(struct drm_fence_object **dst,
+extern void psb_drm_fence_reference_unlocked(struct drm_fence_object **dst,
 					 struct drm_fence_object *src);
-extern int drm_fence_object_wait(struct drm_fence_object *fence,
+extern int psb_drm_fence_object_wait(struct drm_fence_object *fence,
 				 int lazy, int ignore_signals, uint32_t mask);
-extern int drm_fence_object_create(struct drm_device *dev, uint32_t type,
+extern int psb_drm_fence_object_create(struct drm_device *dev, uint32_t type,
 				   uint32_t fence_flags, uint32_t fence_class,
 				   struct drm_fence_object **c_fence);
-extern int drm_fence_object_emit(struct drm_fence_object *fence,
+extern int psb_drm_fence_object_emit(struct drm_fence_object *fence,
 				 uint32_t fence_flags, uint32_t class,
 				 uint32_t type);
-extern void drm_fence_fill_arg(struct drm_fence_object *fence,
+extern void psb_drm_fence_fill_arg(struct drm_fence_object *fence,
 			       struct drm_fence_arg *arg);
 
-extern int drm_fence_add_user_object(struct drm_file *priv,
+extern int psb_drm_fence_add_user_object(struct drm_file *priv,
 				     struct drm_fence_object *fence,
 				     int shareable);
 
@@ -326,12 +326,12 @@
 };
 
 extern struct drm_ttm *drm_ttm_init(struct drm_device *dev, unsigned long size);
-extern int drm_bind_ttm(struct drm_ttm *ttm, struct drm_bo_mem_reg *bo_mem);
+extern int psb_drm_bind_ttm(struct drm_ttm *ttm, struct drm_bo_mem_reg *bo_mem);
 extern void drm_ttm_unbind(struct drm_ttm *ttm);
 extern void drm_ttm_evict(struct drm_ttm *ttm);
 extern void drm_ttm_fixup_caching(struct drm_ttm *ttm);
-extern struct page *drm_ttm_get_page(struct drm_ttm *ttm, int index);
-extern void drm_ttm_cache_flush(void);
+extern struct page *psb_drm_ttm_get_page(struct drm_ttm *ttm, int index);
+extern void psb_drm_ttm_cache_flush(void);
 extern int drm_ttm_populate(struct drm_ttm *ttm);
 extern int drm_ttm_set_user(struct drm_ttm *ttm,
 			    struct task_struct *tsk,
@@ -563,73 +563,73 @@
 extern int drm_mm_lock_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);
 extern int drm_mm_unlock_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);
 extern int drm_bo_version_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv);
-extern int drm_bo_driver_finish(struct drm_device *dev);
-extern int drm_bo_driver_init(struct drm_device *dev);
+extern int psb_drm_bo_driver_finish(struct drm_device *dev);
+extern int psb_drm_bo_driver_init(struct drm_device *dev);
 extern int drm_bo_pci_offset(struct drm_device *dev,
 			     struct drm_bo_mem_reg *mem,
 			     unsigned long *bus_base,
 			     unsigned long *bus_offset,
 			     unsigned long *bus_size);
-extern int drm_mem_reg_is_pci(struct drm_device *dev, struct drm_bo_mem_reg *mem);
+extern int psb_drm_mem_reg_is_pci(struct drm_device *dev, struct drm_bo_mem_reg *mem);
 
-extern void drm_bo_usage_deref_locked(struct drm_buffer_object **bo);
-extern void drm_bo_usage_deref_unlocked(struct drm_buffer_object **bo);
-extern void drm_putback_buffer_objects(struct drm_device *dev);
-extern int drm_fence_buffer_objects(struct drm_device *dev,
+extern void psb_drm_bo_usage_deref_locked(struct drm_buffer_object **bo);
+extern void psb_drm_bo_usage_deref_unlocked(struct drm_buffer_object **bo);
+extern void psb_drm_putback_buffer_objects(struct drm_device *dev);
+extern int psb_drm_fence_buffer_objects(struct drm_device *dev,
 				    struct list_head *list,
 				    uint32_t fence_flags,
 				    struct drm_fence_object *fence,
 				    struct drm_fence_object **used_fence);
 extern void drm_bo_add_to_lru(struct drm_buffer_object *bo);
-extern int drm_buffer_object_create(struct drm_device *dev, unsigned long size,
+extern int psb_drm_buffer_object_create(struct drm_device *dev, unsigned long size,
 				    enum drm_bo_type type, uint64_t mask,
 				    uint32_t hint, uint32_t page_alignment,
 				    unsigned long buffer_start,
 				    struct drm_buffer_object **bo);
-extern int drm_bo_wait(struct drm_buffer_object *bo, int lazy, int ignore_signals,
+extern int psb_drm_bo_wait(struct drm_buffer_object *bo, int lazy, int ignore_signals,
 		       int no_wait);
-extern int drm_bo_mem_space(struct drm_buffer_object *bo,
+extern int psb_drm_bo_mem_space(struct drm_buffer_object *bo,
 			    struct drm_bo_mem_reg *mem, int no_wait);
 extern int drm_bo_move_buffer(struct drm_buffer_object *bo,
 			      uint64_t new_mem_flags,
 			      int no_wait, int move_unfenced);
-extern int drm_bo_clean_mm(struct drm_device *dev, unsigned mem_type);
-extern int drm_bo_init_mm(struct drm_device *dev, unsigned type,
+extern int psb_drm_bo_clean_mm(struct drm_device *dev, unsigned mem_type);
+extern int psb_drm_bo_init_mm(struct drm_device *dev, unsigned type,
 			  unsigned long p_offset, unsigned long p_size);
-extern int drm_bo_handle_validate(struct drm_file *file_priv, uint32_t handle,
+extern int psb_drm_bo_handle_validate(struct drm_file *file_priv, uint32_t handle,
 				  uint32_t fence_class, uint64_t flags,
 				  uint64_t mask, uint32_t hint,
 				  int use_old_fence_class,
 				  struct drm_bo_info_rep *rep,
 				  struct drm_buffer_object **bo_rep);
-extern struct drm_buffer_object *drm_lookup_buffer_object(struct drm_file *file_priv,
+extern struct drm_buffer_object *psb_drm_lookup_buffer_object(struct drm_file *file_priv,
 							  uint32_t handle,
 							  int check_owner);
-extern int drm_bo_do_validate(struct drm_buffer_object *bo,
+extern int psb_drm_bo_do_validate(struct drm_buffer_object *bo,
 			      uint64_t flags, uint64_t mask, uint32_t hint,
 			      uint32_t fence_class,
 			      int no_wait,
 			      struct drm_bo_info_rep *rep);
-extern void drm_bo_fill_rep_arg(struct drm_buffer_object *bo,
+extern void psb_drm_bo_fill_rep_arg(struct drm_buffer_object *bo,
 				struct drm_bo_info_rep *rep);
 /*
  * Buffer object memory move- and map helpers.
  * drm_bo_move.c
  */
 
-extern int drm_bo_move_ttm(struct drm_buffer_object *bo,
+extern int psb_drm_bo_move_ttm(struct drm_buffer_object *bo,
 			   int evict, int no_wait,
 			   struct drm_bo_mem_reg *new_mem);
-extern int drm_bo_move_memcpy(struct drm_buffer_object *bo,
+extern int psb_drm_bo_move_memcpy(struct drm_buffer_object *bo,
 			      int evict,
 			      int no_wait, struct drm_bo_mem_reg *new_mem);
-extern int drm_bo_move_accel_cleanup(struct drm_buffer_object *bo,
+extern int psb_drm_bo_move_accel_cleanup(struct drm_buffer_object *bo,
 				     int evict, int no_wait,
 				     uint32_t fence_class, uint32_t fence_type,
 				     uint32_t fence_flags,
 				     struct drm_bo_mem_reg *new_mem);
-extern int drm_bo_same_page(unsigned long offset, unsigned long offset2);
-extern unsigned long drm_bo_offset_end(unsigned long offset,
+extern int psb_drm_bo_same_page(unsigned long offset, unsigned long offset2);
+extern unsigned long psb_drm_bo_offset_end(unsigned long offset,
 				       unsigned long end);
 
 struct drm_bo_kmap_obj {
@@ -649,8 +649,8 @@
 		     map->bo_kmap_type == bo_map_premapped);
 	return map->virtual;
 }
-extern void drm_bo_kunmap(struct drm_bo_kmap_obj *map);
-extern int drm_bo_kmap(struct drm_buffer_object *bo, unsigned long start_page,
+extern void psb_drm_bo_kunmap(struct drm_bo_kmap_obj *map);
+extern int psb_drm_bo_kmap(struct drm_buffer_object *bo, unsigned long start_page,
 		       unsigned long num_pages, struct drm_bo_kmap_obj *map);
 
 
@@ -674,7 +674,7 @@
 	void (*reg_destroy)(struct drm_reg *reg);
 };
 
-extern int drm_regs_alloc(struct drm_reg_manager *manager,
+extern int psb_drm_regs_alloc(struct drm_reg_manager *manager,
 			  const void *data,
 			  uint32_t fence_class,
 			  uint32_t fence_type,
@@ -682,19 +682,19 @@
 			  int no_wait,
 			  struct drm_reg **reg);
 
-extern void drm_regs_fence(struct drm_reg_manager *regs,
+extern void psb_drm_regs_fence(struct drm_reg_manager *regs,
 			   struct drm_fence_object *fence);
 
-extern void drm_regs_free(struct drm_reg_manager *manager);
-extern void drm_regs_add(struct drm_reg_manager *manager, struct drm_reg *reg);
-extern void drm_regs_init(struct drm_reg_manager *manager,
+extern void psb_drm_regs_free(struct drm_reg_manager *manager);
+extern void psb_drm_regs_add(struct drm_reg_manager *manager, struct drm_reg *reg);
+extern void psb_drm_regs_init(struct drm_reg_manager *manager,
 			  int (*reg_reusable)(const struct drm_reg *,
 					      const void *),
 			  void (*reg_destroy)(struct drm_reg *));
 
-extern int drm_mem_reg_ioremap(struct drm_device *dev, struct drm_bo_mem_reg * mem,
+extern int psb_drm_mem_reg_ioremap(struct drm_device *dev, struct drm_bo_mem_reg * mem,
 			       void **virtual);
-extern void drm_mem_reg_iounmap(struct drm_device *dev, struct drm_bo_mem_reg * mem,
+extern void psb_drm_mem_reg_iounmap(struct drm_device *dev, struct drm_bo_mem_reg * mem,
 				void *virtual);
 /*
  * drm_bo_lock.c
@@ -703,8 +703,8 @@
 
 
 extern void drm_bo_init_lock(struct drm_bo_lock *lock);
-extern void drm_bo_read_unlock(struct drm_bo_lock *lock);
-extern int drm_bo_read_lock(struct drm_bo_lock *lock, int interruptible);
+extern void psb_drm_bo_read_unlock(struct drm_bo_lock *lock);
+extern int psb_drm_bo_read_lock(struct drm_bo_lock *lock, int interruptible);
 extern int drm_bo_write_lock(struct drm_bo_lock *lock, int interruptible,
 			     struct drm_file *file_priv);
 
diff -urNad psb-kernel-source-4.41.2/drm_pci.c psb-kernel-source-4.41.2.drm_psb/drm_pci.c
--- psb-kernel-source-4.41.2/drm_pci.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_pci.c	2010-05-02 10:13:41.795192985 +0200
@@ -47,7 +47,7 @@
 /**
  * \brief Allocate a PCI consistent memory block, for DMA.
  */
-drm_dma_handle_t *drm_pci_alloc(struct drm_device * dev, size_t size, size_t align,
+drm_dma_handle_t *psb_drm_pci_alloc(struct drm_device * dev, size_t size, size_t align,
 				dma_addr_t maxaddr)
 {
 	drm_dma_handle_t *dmah;
@@ -116,7 +116,7 @@
 
 	return dmah;
 }
-EXPORT_SYMBOL(drm_pci_alloc);
+EXPORT_SYMBOL(psb_drm_pci_alloc);
 
 /**
  * \brief Free a PCI consistent memory block without freeing its descriptor.
@@ -167,11 +167,11 @@
 /**
  * \brief Free a PCI consistent memory block
  */
-void drm_pci_free(struct drm_device *dev, drm_dma_handle_t *dmah)
+void psb_drm_pci_free(struct drm_device *dev, drm_dma_handle_t *dmah)
 {
 	__drm_pci_free(dev, dmah);
 	kfree(dmah);
 }
-EXPORT_SYMBOL(drm_pci_free);
+EXPORT_SYMBOL(psb_drm_pci_free);
 
 /*@}*/
diff -urNad psb-kernel-source-4.41.2/drmP.h psb-kernel-source-4.41.2.drm_psb/drmP.h
--- psb-kernel-source-4.41.2/drmP.h	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drmP.h	2010-05-02 10:13:43.227192873 +0200
@@ -219,7 +219,7 @@
 #if DRM_DEBUG_CODE
 #define DRM_DEBUG(fmt, arg...)						\
 	do {								\
-		if ( drm_debug )					\
+		if ( psb_drm_debug )					\
 			printk(KERN_DEBUG				\
 			       "[" DRM_NAME ":%s] " fmt ,		\
 			       __FUNCTION__ , ##arg);			\
@@ -318,7 +318,7 @@
 };
 /**
  * Creates a driver or general drm_ioctl_desc array entry for the given
- * ioctl, for use by drm_ioctl().
+ * ioctl, for use by psb_drm_ioctl().
  */
 #define DRM_IOCTL_DEF(ioctl, func, flags) \
 	[DRM_IOCTL_NR(ioctl)] = {ioctl, func, flags}
@@ -812,7 +812,7 @@
 	struct list_head vbl_sigs;		/**< signal list to send on VBLANK */
 	struct list_head vbl_sigs2;	/**< signals to send on secondary VBLANK */
 	unsigned int vbl_pending;
-	spinlock_t tasklet_lock;	/**< For drm_locked_tasklet */
+	spinlock_t tasklet_lock;	/**< For psb_drm_locked_tasklet */
 	void (*locked_tasklet_func)(struct drm_device *dev);
 
 	/*@} */
@@ -940,30 +940,30 @@
 
 				/* Driver support (drm_drv.h) */
 extern int drm_fb_loaded;
-extern int drm_init(struct drm_driver *driver,
+extern int psb_drm_init(struct drm_driver *driver,
 			      struct pci_device_id *pciidlist);
-extern void drm_exit(struct drm_driver *driver);
-extern void drm_cleanup_pci(struct pci_dev *pdev);
-extern int drm_ioctl(struct inode *inode, struct file *filp,
+extern void psb_drm_exit(struct drm_driver *driver);
+extern void psb_drm_cleanup_pci(struct pci_dev *pdev);
+extern int psb_drm_ioctl(struct inode *inode, struct file *filp,
 		     unsigned int cmd, unsigned long arg);
-extern long drm_unlocked_ioctl(struct file *filp,
+extern long psb_drm_unlocked_ioctl(struct file *filp,
 			       unsigned int cmd, unsigned long arg);
-extern long drm_compat_ioctl(struct file *filp,
+extern long psb_drm_compat_ioctl(struct file *filp,
 			     unsigned int cmd, unsigned long arg);
 
 extern int drm_lastclose(struct drm_device *dev);
 
 				/* Device support (drm_fops.h) */
-extern int drm_open(struct inode *inode, struct file *filp);
+extern int psb_drm_open(struct inode *inode, struct file *filp);
 extern int drm_stub_open(struct inode *inode, struct file *filp);
-extern int drm_fasync(int fd, struct file *filp, int on);
-extern int drm_release(struct inode *inode, struct file *filp);
-unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
+extern int psb_drm_fasync(int fd, struct file *filp, int on);
+extern int psb_drm_release(struct inode *inode, struct file *filp);
+unsigned int psb_drm_poll(struct file *filp, struct poll_table_struct *wait);
 
 				/* Mapping support (drm_vm.h) */
-extern int drm_mmap(struct file *filp, struct vm_area_struct *vma);
-extern unsigned long drm_core_get_map_ofs(struct drm_map * map);
-extern unsigned long drm_core_get_reg_ofs(struct drm_device *dev);
+extern int psb_drm_mmap(struct file *filp, struct vm_area_struct *vma);
+extern unsigned long psb_drm_core_get_map_ofs(struct drm_map * map);
+extern unsigned long psb_drm_core_get_reg_ofs(struct drm_device *dev);
 extern pgprot_t drm_io_prot(uint32_t map_type, struct vm_area_struct *vma);
 
 				/* Memory management support (drm_memory.h) */
@@ -971,8 +971,8 @@
 extern void drm_mem_init(void);
 extern int drm_mem_info(char *buf, char **start, off_t offset,
 			int request, int *eof, void *data);
-extern void *drm_calloc(size_t nmemb, size_t size, int area);
-extern void *drm_realloc(void *oldpt, size_t oldsize, size_t size, int area);
+extern void *psb_drm_calloc(size_t nmemb, size_t size, int area);
+extern void *psb_drm_realloc(void *oldpt, size_t oldsize, size_t size, int area);
 extern unsigned long drm_alloc_pages(int order, int area);
 extern void drm_free_pages(unsigned long address, int order, int area);
 extern DRM_AGP_MEM *drm_alloc_agp(struct drm_device *dev, int pages, u32 type);
@@ -980,9 +980,9 @@
 extern int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start);
 extern int drm_unbind_agp(DRM_AGP_MEM * handle);
 
-extern void drm_free_memctl(size_t size);
+extern void psb_drm_free_memctl(size_t size);
 extern int drm_alloc_memctl(size_t size);
-extern void drm_query_memctl(uint64_t *cur_used,
+extern void psb_drm_query_memctl(uint64_t *cur_used,
 			     uint64_t *emer_used,
 			     uint64_t *low_threshold,
 			     uint64_t *high_threshold,
@@ -991,7 +991,7 @@
 			    size_t high_threshold,
 			    size_t unit_size);
 
-				/* Misc. IOCTL support (drm_ioctl.h) */
+				/* Misc. IOCTL support (psb_drm_ioctl.h) */
 extern int drm_irq_by_busid(struct drm_device *dev, void *data,
 			    struct drm_file *file_priv);
 extern int drm_getunique(struct drm_device *dev, void *data,
@@ -1041,7 +1041,7 @@
 		      struct drm_file *file_priv);
 extern int drm_update_drawable_info(struct drm_device *dev, void *data,
 				    struct drm_file *file_priv);
-extern struct drm_drawable_info *drm_get_drawable_info(struct drm_device *dev,
+extern struct drm_drawable_info *psb_drm_get_drawable_info(struct drm_device *dev,
 						       drm_drawable_t id);
 extern void drm_drawable_free_all(struct drm_device *dev);
 
@@ -1058,28 +1058,28 @@
 		      struct drm_file *file_priv);
 extern int drm_lock_take(struct drm_lock_data *lock_data, unsigned int context);
 extern int drm_lock_free(struct drm_lock_data *lock_data, unsigned int context);
-extern void drm_idlelock_take(struct drm_lock_data *lock_data);
-extern void drm_idlelock_release(struct drm_lock_data *lock_data);
+extern void psb_drm_idlelock_take(struct drm_lock_data *lock_data);
+extern void psb_drm_idlelock_release(struct drm_lock_data *lock_data);
 
 /*
  * These are exported to drivers so that they can implement fencing using
  * DMA quiscent + idle. DMA quiescent usually requires the hardware lock.
  */
 
-extern int drm_i_have_hw_lock(struct drm_device *dev,
+extern int psb_drm_i_have_hw_lock(struct drm_device *dev,
 			      struct drm_file *file_priv);
 
 				/* Buffer management support (drm_bufs.h) */
-extern int drm_addbufs_agp(struct drm_device *dev, struct drm_buf_desc * request);
-extern int drm_addbufs_pci(struct drm_device *dev, struct drm_buf_desc * request);
-extern int drm_addbufs_fb (struct drm_device *dev, struct drm_buf_desc * request);
-extern int drm_addmap(struct drm_device *dev, unsigned int offset,
+extern int psb_drm_addbufs_agp(struct drm_device *dev, struct drm_buf_desc * request);
+extern int psb_drm_addbufs_pci(struct drm_device *dev, struct drm_buf_desc * request);
+extern int psb_drm_addbufs_fb (struct drm_device *dev, struct drm_buf_desc * request);
+extern int psb_drm_addmap(struct drm_device *dev, unsigned int offset,
 		      unsigned int size, enum drm_map_type type,
 		      enum drm_map_flags flags, drm_local_map_t ** map_ptr);
 extern int drm_addmap_ioctl(struct drm_device *dev, void *data,
 			    struct drm_file *file_priv);
-extern int drm_rmmap(struct drm_device *dev, drm_local_map_t *map);
-extern int drm_rmmap_locked(struct drm_device *dev, drm_local_map_t *map);
+extern int psb_drm_rmmap(struct drm_device *dev, drm_local_map_t *map);
+extern int psb_drm_rmmap_locked(struct drm_device *dev, drm_local_map_t *map);
 extern int drm_rmmap_ioctl(struct drm_device *dev, void *data,
 			   struct drm_file *file_priv);
 extern int drm_addbufs(struct drm_device *dev, void *data,
@@ -1092,12 +1092,12 @@
 			struct drm_file *file_priv);
 extern int drm_mapbufs(struct drm_device *dev, void *data,
 		       struct drm_file *file_priv);
-extern int drm_order(unsigned long size);
-extern unsigned long drm_get_resource_start(struct drm_device *dev,
+extern int psb_drm_order(unsigned long size);
+extern unsigned long psb_drm_get_resource_start(struct drm_device *dev,
 					    unsigned int resource);
-extern unsigned long drm_get_resource_len(struct drm_device *dev,
+extern unsigned long psb_drm_get_resource_len(struct drm_device *dev,
 					  unsigned int resource);
-extern struct drm_map_list *drm_find_matching_map(struct drm_device *dev,
+extern struct drm_map_list *psb_drm_find_matching_map(struct drm_device *dev,
 						  drm_local_map_t *map);
 
 
@@ -1105,15 +1105,15 @@
 extern int drm_dma_setup(struct drm_device *dev);
 extern void drm_dma_takedown(struct drm_device *dev);
 extern void drm_free_buffer(struct drm_device *dev, struct drm_buf * buf);
-extern void drm_core_reclaim_buffers(struct drm_device *dev,
+extern void psb_drm_core_reclaim_buffers(struct drm_device *dev,
 				     struct drm_file *filp);
 
 				/* IRQ support (drm_irq.h) */
 extern int drm_control(struct drm_device *dev, void *data,
 		       struct drm_file *file_priv);
 extern irqreturn_t drm_irq_handler(DRM_IRQ_ARGS);
-extern int drm_irq_install(struct drm_device *dev);
-extern int drm_irq_uninstall(struct drm_device *dev);
+extern int psb_drm_irq_install(struct drm_device *dev);
+extern int psb_drm_irq_uninstall(struct drm_device *dev);
 extern void drm_driver_irq_preinstall(struct drm_device *dev);
 extern void drm_driver_irq_postinstall(struct drm_device *dev);
 extern void drm_driver_irq_uninstall(struct drm_device *dev);
@@ -1121,33 +1121,33 @@
 extern int drm_wait_vblank(struct drm_device *dev, void *data,
 			   struct drm_file *file_priv);
 extern int drm_vblank_wait(struct drm_device *dev, unsigned int *vbl_seq);
-extern void drm_vbl_send_signals(struct drm_device *dev);
-extern void drm_locked_tasklet(struct drm_device *dev, void(*func)(struct drm_device*));
+extern void psb_drm_vbl_send_signals(struct drm_device *dev);
+extern void psb_drm_locked_tasklet(struct drm_device *dev, void(*func)(struct drm_device*));
 
 				/* AGP/GART support (drm_agpsupport.h) */
 extern struct drm_agp_head *drm_agp_init(struct drm_device *dev);
-extern int drm_agp_acquire(struct drm_device *dev);
+extern int psb_drm_agp_acquire(struct drm_device *dev);
 extern int drm_agp_acquire_ioctl(struct drm_device *dev, void *data,
 				 struct drm_file *file_priv);
-extern int drm_agp_release(struct drm_device *dev);
+extern int psb_drm_agp_release(struct drm_device *dev);
 extern int drm_agp_release_ioctl(struct drm_device *dev, void *data,
 				 struct drm_file *file_priv);
-extern int drm_agp_enable(struct drm_device *dev, struct drm_agp_mode mode);
+extern int psb_drm_agp_enable(struct drm_device *dev, struct drm_agp_mode mode);
 extern int drm_agp_enable_ioctl(struct drm_device *dev, void *data,
 				struct drm_file *file_priv);
-extern int drm_agp_info(struct drm_device *dev, struct drm_agp_info *info);
+extern int psb_drm_agp_info(struct drm_device *dev, struct psb_drm_agp_info *info);
 extern int drm_agp_info_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv);
-extern int drm_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request);
+extern int psb_drm_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request);
 extern int drm_agp_alloc_ioctl(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv);
-extern int drm_agp_free(struct drm_device *dev, struct drm_agp_buffer *request);
+extern int psb_drm_agp_free(struct drm_device *dev, struct drm_agp_buffer *request);
 extern int drm_agp_free_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv);
-extern int drm_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request);
+extern int psb_drm_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request);
 extern int drm_agp_unbind_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv);
-extern int drm_agp_bind(struct drm_device *dev, struct drm_agp_binding *request);
+extern int psb_drm_agp_bind(struct drm_device *dev, struct drm_agp_binding *request);
 extern int drm_agp_bind_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv);
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11)
@@ -1156,22 +1156,22 @@
 extern DRM_AGP_MEM *drm_agp_allocate_memory(struct agp_bridge_data *bridge, size_t pages, u32 type);
 #endif
 extern int drm_agp_free_memory(DRM_AGP_MEM * handle);
-extern int drm_agp_bind_memory(DRM_AGP_MEM * handle, off_t start);
+extern int psb_drm_agp_bind_memory(DRM_AGP_MEM * handle, off_t start);
 extern int drm_agp_unbind_memory(DRM_AGP_MEM * handle);
-extern struct drm_ttm_backend *drm_agp_init_ttm(struct drm_device *dev);
+extern struct drm_ttm_backend *psb_drm_agp_init_ttm(struct drm_device *dev);
 extern void drm_agp_chipset_flush(struct drm_device *dev);
 				/* Stub support (drm_stub.h) */
-extern int drm_get_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
+extern int psb_drm_get_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
 		     struct drm_driver *driver);
 extern int drm_put_dev(struct drm_device *dev);
 extern int drm_put_head(struct drm_head * head);
-extern unsigned int drm_debug; /* 1 to enable debug output */
+extern unsigned int psb_drm_debug; /* 1 to enable debug output */
 extern unsigned int drm_cards_limit;
 extern struct drm_head **drm_heads;
 extern struct class *drm_class;
 extern struct proc_dir_entry *drm_proc_root;
 
-extern drm_local_map_t *drm_getsarea(struct drm_device *dev);
+extern drm_local_map_t *psb_drm_getsarea(struct drm_device *dev);
 
 				/* Proc support (drm_proc.h) */
 extern int drm_proc_init(struct drm_device *dev,
@@ -1183,22 +1183,22 @@
 			    struct proc_dir_entry *dev_root);
 
 				/* Scatter Gather Support (drm_scatter.h) */
-extern void drm_sg_cleanup(struct drm_sg_mem * entry);
+extern void psb_drm_sg_cleanup(struct drm_sg_mem * entry);
 extern int drm_sg_alloc_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv);
-extern int drm_sg_alloc(struct drm_device *dev, struct drm_scatter_gather * request);
+extern int psb_drm_sg_alloc(struct drm_device *dev, struct drm_scatter_gather * request);
 extern int drm_sg_free(struct drm_device *dev, void *data,
 		       struct drm_file *file_priv);
 
 			       /* ATI PCIGART support (ati_pcigart.h) */
-extern int drm_ati_pcigart_init(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info);
-extern int drm_ati_pcigart_cleanup(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info);
-extern struct drm_ttm_backend *ati_pcigart_init_ttm(struct drm_device *dev, struct drm_ati_pcigart_info *info, void (*gart_flush_fn)(struct drm_device *dev));
+extern int psb_drm_ati_pcigart_init(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info);
+extern int psb_drm_ati_pcigart_cleanup(struct drm_device *dev, struct drm_ati_pcigart_info *gart_info);
+extern struct drm_ttm_backend *psb_ati_pcigart_init_ttm(struct drm_device *dev, struct drm_ati_pcigart_info *info, void (*gart_flush_fn)(struct drm_device *dev));
 
-extern drm_dma_handle_t *drm_pci_alloc(struct drm_device *dev, size_t size,
+extern drm_dma_handle_t *psb_drm_pci_alloc(struct drm_device *dev, size_t size,
 			   size_t align, dma_addr_t maxaddr);
 extern void __drm_pci_free(struct drm_device *dev, drm_dma_handle_t *dmah);
-extern void drm_pci_free(struct drm_device *dev, drm_dma_handle_t *dmah);
+extern void psb_drm_pci_free(struct drm_device *dev, drm_dma_handle_t *dmah);
 
 			       /* sysfs support (drm_sysfs.c) */
 struct drm_sysfs_class;
@@ -1213,11 +1213,11 @@
 
 extern struct drm_mm_node * drm_mm_get_block(struct drm_mm_node * parent, unsigned long size,
 					       unsigned alignment);
-extern void drm_mm_put_block(struct drm_mm_node *cur);
+extern void psb_drm_mm_put_block(struct drm_mm_node *cur);
 extern struct drm_mm_node *drm_mm_search_free(const struct drm_mm *mm, unsigned long size,
 						unsigned alignment, int best_match);
-extern int drm_mm_init(struct drm_mm *mm, unsigned long start, unsigned long size);
-extern void drm_mm_takedown(struct drm_mm *mm);
+extern int psb_drm_mm_init(struct drm_mm *mm, unsigned long start, unsigned long size);
+extern void psb_drm_mm_takedown(struct drm_mm *mm);
 extern int drm_mm_clean(struct drm_mm *mm);
 extern unsigned long drm_mm_tail_space(struct drm_mm *mm);
 extern int drm_mm_remove_space_from_tail(struct drm_mm *mm, unsigned long size);
@@ -1228,8 +1228,8 @@
 	return block->mm;
 }
 
-extern void drm_core_ioremap(struct drm_map *map, struct drm_device *dev);
-extern void drm_core_ioremapfree(struct drm_map *map, struct drm_device *dev);
+extern void psb_drm_core_ioremap(struct drm_map *map, struct drm_device *dev);
+extern void psb_drm_core_ioremapfree(struct drm_map *map, struct drm_device *dev);
 
 static __inline__ struct drm_map *drm_core_findmap(struct drm_device *dev,
 						   unsigned int token)
@@ -1265,19 +1265,19 @@
 
 #ifndef DEBUG_MEMORY
 /** Wrapper around kmalloc() */
-static __inline__ void *drm_alloc(size_t size, int area)
+static __inline__ void *psb_drm_alloc(size_t size, int area)
 {
 	return kmalloc(size, GFP_KERNEL);
 }
 
 /** Wrapper around kfree() */
-static __inline__ void drm_free(void *pt, size_t size, int area)
+static __inline__ void psb_drm_free(void *pt, size_t size, int area)
 {
 	kfree(pt);
 }
 #else
-extern void *drm_alloc(size_t size, int area);
-extern void drm_free(void *pt, size_t size, int area);
+extern void *psb_drm_alloc(size_t size, int area);
+extern void psb_drm_free(void *pt, size_t size, int area);
 #endif
 
 /*
@@ -1289,9 +1289,9 @@
 	void *ret;
 	if (drm_alloc_memctl(size))
 		return NULL;
-	ret = drm_alloc(size, area);
+	ret = psb_drm_alloc(size, area);
 	if (!ret)
-		drm_free_memctl(size);
+		psb_drm_free_memctl(size);
 	return ret;
 }
 
@@ -1301,16 +1301,16 @@
 
 	if (drm_alloc_memctl(nmemb*size))
 		return NULL;
-	ret = drm_calloc(nmemb, size, area);
+	ret = psb_drm_calloc(nmemb, size, area);
 	if (!ret)
-		drm_free_memctl(nmemb*size);
+		psb_drm_free_memctl(nmemb*size);
 	return ret;
 }
 
 static inline void drm_ctl_free(void *pt, size_t size, int area)
 {
-	drm_free(pt, size, area);
-	drm_free_memctl(size);
+	psb_drm_free(pt, size, area);
+	psb_drm_free_memctl(size);
 }
 
 static inline size_t drm_size_align(size_t size)
diff -urNad psb-kernel-source-4.41.2/drm_proc.c psb-kernel-source-4.41.2.drm_psb/drm_proc.c
--- psb-kernel-source-4.41.2/drm_proc.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_proc.c	2010-05-02 10:13:44.095192095 +0200
@@ -469,7 +469,7 @@
 		DRM_PROC_PRINT("Buffer objects are not supported by this driver.\n");
 	}
 
-	drm_query_memctl(&used_mem, &used_emer, &low_mem, &high_mem, &emer_mem);
+	psb_drm_query_memctl(&used_mem, &used_emer, &low_mem, &high_mem, &emer_mem);
 
 	if (used_mem > 16*PAGE_SIZE) {
 		DRM_PROC_PRINT("Used object memory is %lu pages.\n",
diff -urNad psb-kernel-source-4.41.2/drm_regman.c psb-kernel-source-4.41.2.drm_psb/drm_regman.c
--- psb-kernel-source-4.41.2/drm_regman.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_regman.c	2010-05-02 10:13:45.299193916 +0200
@@ -34,7 +34,7 @@
  * Allocate a compatible register and put it on the unfenced list.
  */
 
-int drm_regs_alloc(struct drm_reg_manager *manager,
+int psb_drm_regs_alloc(struct drm_reg_manager *manager,
 		   const void *data,
 		   uint32_t fence_class,
 		   uint32_t fence_type,
@@ -92,12 +92,12 @@
 
 	list_for_each_entry_safe(entry, next_entry, &manager->lru, head) {
 		BUG_ON(!entry->fence);
-		ret = drm_fence_object_wait(entry->fence, 0, !interruptible,
+		ret = psb_drm_fence_object_wait(entry->fence, 0, !interruptible,
 					    entry->fence_type);
 		if (ret)
 			return ret;
 
-		drm_fence_usage_deref_unlocked(&entry->fence);
+		psb_drm_fence_usage_deref_unlocked(&entry->fence);
 		list_del(&entry->head);
 		entry->new_fence_type = fence_type;
 		list_add_tail(&entry->head, &manager->unfenced);
@@ -113,9 +113,9 @@
 	*reg = entry;
 	return 0;
 }
-EXPORT_SYMBOL(drm_regs_alloc);
+EXPORT_SYMBOL(psb_drm_regs_alloc);
 
-void drm_regs_fence(struct drm_reg_manager *manager,
+void psb_drm_regs_fence(struct drm_reg_manager *manager,
 		    struct drm_fence_object *fence)
 {
 	struct drm_reg *entry;
@@ -144,8 +144,8 @@
 					 head) {
 			list_del(&entry->head);
 			if (entry->fence)
-				drm_fence_usage_deref_unlocked(&entry->fence);
-			drm_fence_reference_unlocked(&entry->fence, fence);
+				psb_drm_fence_usage_deref_unlocked(&entry->fence);
+			psb_drm_fence_reference_unlocked(&entry->fence, fence);
 
 			entry->fence_type = entry->new_fence_type;
 			BUG_ON((entry->fence_type & fence->type) !=
@@ -155,14 +155,14 @@
 		}
 	}
 }
-EXPORT_SYMBOL(drm_regs_fence);
+EXPORT_SYMBOL(psb_drm_regs_fence);
 
-void drm_regs_free(struct drm_reg_manager *manager)
+void psb_drm_regs_free(struct drm_reg_manager *manager)
 {
 	struct drm_reg *entry;
 	struct drm_reg *next_entry;
 
-	drm_regs_fence(manager, NULL);
+	psb_drm_regs_fence(manager, NULL);
 
 	list_for_each_entry_safe(entry, next_entry, &manager->free, head) {
 		list_del(&entry->head);
@@ -171,23 +171,23 @@
 
 	list_for_each_entry_safe(entry, next_entry, &manager->lru, head) {
 
-		(void)drm_fence_object_wait(entry->fence, 1, 1,
+		(void)psb_drm_fence_object_wait(entry->fence, 1, 1,
 					    entry->fence_type);
 		list_del(&entry->head);
-		drm_fence_usage_deref_unlocked(&entry->fence);
+		psb_drm_fence_usage_deref_unlocked(&entry->fence);
 		manager->reg_destroy(entry);
 	}
 }
-EXPORT_SYMBOL(drm_regs_free);
+EXPORT_SYMBOL(psb_drm_regs_free);
 
-void drm_regs_add(struct drm_reg_manager *manager, struct drm_reg *reg)
+void psb_drm_regs_add(struct drm_reg_manager *manager, struct drm_reg *reg)
 {
 	reg->fence = NULL;
 	list_add_tail(&reg->head, &manager->free);
 }
-EXPORT_SYMBOL(drm_regs_add);
+EXPORT_SYMBOL(psb_drm_regs_add);
 
-void drm_regs_init(struct drm_reg_manager *manager,
+void psb_drm_regs_init(struct drm_reg_manager *manager,
 		   int (*reg_reusable) (const struct drm_reg *, const void *),
 		   void (*reg_destroy) (struct drm_reg *))
 {
@@ -197,4 +197,4 @@
 	manager->reg_reusable = reg_reusable;
 	manager->reg_destroy = reg_destroy;
 }
-EXPORT_SYMBOL(drm_regs_init);
+EXPORT_SYMBOL(psb_drm_regs_init);
diff -urNad psb-kernel-source-4.41.2/drm_scatter.c psb-kernel-source-4.41.2.drm_psb/drm_scatter.c
--- psb-kernel-source-4.41.2/drm_scatter.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_scatter.c	2010-05-02 10:13:44.595193352 +0200
@@ -36,7 +36,7 @@
 
 #define DEBUG_SCATTER 0
 
-void drm_sg_cleanup(struct drm_sg_mem *entry)
+void psb_drm_sg_cleanup(struct drm_sg_mem *entry)
 {
 	struct page *page;
 	int i;
@@ -49,13 +49,13 @@
 
 	vfree(entry->virtual);
 
-	drm_free(entry->busaddr,
+	psb_drm_free(entry->busaddr,
 		 entry->pages * sizeof(*entry->busaddr), DRM_MEM_PAGES);
-	drm_free(entry->pagelist,
+	psb_drm_free(entry->pagelist,
 		 entry->pages * sizeof(*entry->pagelist), DRM_MEM_PAGES);
-	drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
+	psb_drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 }
-EXPORT_SYMBOL(drm_sg_cleanup);
+EXPORT_SYMBOL(psb_drm_sg_cleanup);
 
 #ifdef _LP64
 # define ScatterHandle(x) (unsigned int)((x >> 32) + (x & ((1L << 32) - 1)))
@@ -63,7 +63,7 @@
 # define ScatterHandle(x) (unsigned int)(x)
 #endif
 
-int drm_sg_alloc(struct drm_device *dev, struct drm_scatter_gather * request)
+int psb_drm_sg_alloc(struct drm_device *dev, struct drm_scatter_gather * request)
 {
 	struct drm_sg_mem *entry;
 	unsigned long pages, i, j;
@@ -76,7 +76,7 @@
 	if (dev->sg)
 		return -EINVAL;
 
-	entry = drm_alloc(sizeof(*entry), DRM_MEM_SGLISTS);
+	entry = psb_drm_alloc(sizeof(*entry), DRM_MEM_SGLISTS);
 	if (!entry)
 		return -ENOMEM;
 
@@ -85,34 +85,34 @@
 	DRM_DEBUG("sg size=%ld pages=%ld\n", request->size, pages);
 
 	entry->pages = pages;
-	entry->pagelist = drm_alloc(pages * sizeof(*entry->pagelist),
+	entry->pagelist = psb_drm_alloc(pages * sizeof(*entry->pagelist),
 				    DRM_MEM_PAGES);
 	if (!entry->pagelist) {
-		drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
+		psb_drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 		return -ENOMEM;
 	}
 
 	memset(entry->pagelist, 0, pages * sizeof(*entry->pagelist));
 
-	entry->busaddr = drm_alloc(pages * sizeof(*entry->busaddr),
+	entry->busaddr = psb_drm_alloc(pages * sizeof(*entry->busaddr),
 				   DRM_MEM_PAGES);
 	if (!entry->busaddr) {
-		drm_free(entry->pagelist,
+		psb_drm_free(entry->pagelist,
 			 entry->pages * sizeof(*entry->pagelist),
 			 DRM_MEM_PAGES);
-		drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
+		psb_drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 		return -ENOMEM;
 	}
 	memset((void *)entry->busaddr, 0, pages * sizeof(*entry->busaddr));
 
 	entry->virtual = vmalloc_32(pages << PAGE_SHIFT);
 	if (!entry->virtual) {
-		drm_free(entry->busaddr,
+		psb_drm_free(entry->busaddr,
 			 entry->pages * sizeof(*entry->busaddr), DRM_MEM_PAGES);
-		drm_free(entry->pagelist,
+		psb_drm_free(entry->pagelist,
 			 entry->pages * sizeof(*entry->pagelist),
 			 DRM_MEM_PAGES);
-		drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
+		psb_drm_free(entry, sizeof(*entry), DRM_MEM_SGLISTS);
 		return -ENOMEM;
 	}
 
@@ -181,18 +181,18 @@
 	return 0;
 
       failed:
-	drm_sg_cleanup(entry);
+	psb_drm_sg_cleanup(entry);
 	return -ENOMEM;
 
 }
-EXPORT_SYMBOL(drm_sg_alloc);
+EXPORT_SYMBOL(psb_drm_sg_alloc);
 
 int drm_sg_alloc_ioctl(struct drm_device *dev, void *data,
 		       struct drm_file *file_priv)
 {
 	struct drm_scatter_gather *request = data;
 
-	return drm_sg_alloc(dev, request);
+	return psb_drm_sg_alloc(dev, request);
 
 }
 
@@ -213,7 +213,7 @@
 
 	DRM_DEBUG("sg free virtual  = %p\n", entry->virtual);
 
-	drm_sg_cleanup(entry);
+	psb_drm_sg_cleanup(entry);
 
 	return 0;
 }
diff -urNad psb-kernel-source-4.41.2/drm_sman.c psb-kernel-source-4.41.2.drm_psb/drm_sman.c
--- psb-kernel-source-4.41.2/drm_sman.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_sman.c	2010-05-02 10:13:45.019194094 +0200
@@ -44,24 +44,24 @@
 	struct list_head mem_blocks;
 };
 
-void drm_sman_takedown(struct drm_sman * sman)
+void psb_drm_sman_takedown(struct drm_sman * sman)
 {
 	drm_ht_remove(&sman->user_hash_tab);
 	drm_ht_remove(&sman->owner_hash_tab);
 	if (sman->mm)
-		drm_free(sman->mm, sman->num_managers * sizeof(*sman->mm),
+		psb_drm_free(sman->mm, sman->num_managers * sizeof(*sman->mm),
 			 DRM_MEM_MM);
 }
 
-EXPORT_SYMBOL(drm_sman_takedown);
+EXPORT_SYMBOL(psb_drm_sman_takedown);
 
 int
-drm_sman_init(struct drm_sman * sman, unsigned int num_managers,
+psb_drm_sman_init(struct drm_sman * sman, unsigned int num_managers,
 	      unsigned int user_order, unsigned int owner_order)
 {
 	int ret = 0;
 
-	sman->mm = (struct drm_sman_mm *) drm_calloc(num_managers, sizeof(*sman->mm),
+	sman->mm = (struct drm_sman_mm *) psb_drm_calloc(num_managers, sizeof(*sman->mm),
 						DRM_MEM_MM);
 	if (!sman->mm) {
 		ret = -ENOMEM;
@@ -78,12 +78,12 @@
 
 	drm_ht_remove(&sman->owner_hash_tab);
 out1:
-	drm_free(sman->mm, num_managers * sizeof(*sman->mm), DRM_MEM_MM);
+	psb_drm_free(sman->mm, num_managers * sizeof(*sman->mm), DRM_MEM_MM);
 out:
 	return ret;
 }
 
-EXPORT_SYMBOL(drm_sman_init);
+EXPORT_SYMBOL(psb_drm_sman_init);
 
 static void *drm_sman_mm_allocate(void *private, unsigned long size,
 				  unsigned alignment)
@@ -103,14 +103,14 @@
 {
 	struct drm_mm_node *node = (struct drm_mm_node *) ref;
 
-	drm_mm_put_block(node);
+	psb_drm_mm_put_block(node);
 }
 
 static void drm_sman_mm_destroy(void *private)
 {
 	struct drm_mm *mm = (struct drm_mm *) private;
-	drm_mm_takedown(mm);
-	drm_free(mm, sizeof(*mm), DRM_MEM_MM);
+	psb_drm_mm_takedown(mm);
+	psb_drm_free(mm, sizeof(*mm), DRM_MEM_MM);
 }
 
 static unsigned long drm_sman_mm_offset(void *private, void *ref)
@@ -120,7 +120,7 @@
 }
 
 int
-drm_sman_set_range(struct drm_sman * sman, unsigned int manager,
+psb_drm_sman_set_range(struct drm_sman * sman, unsigned int manager,
 		   unsigned long start, unsigned long size)
 {
 	struct drm_sman_mm *sman_mm;
@@ -130,15 +130,15 @@
 	BUG_ON(manager >= sman->num_managers);
 
 	sman_mm = &sman->mm[manager];
-	mm = drm_calloc(1, sizeof(*mm), DRM_MEM_MM);
+	mm = psb_drm_calloc(1, sizeof(*mm), DRM_MEM_MM);
 	if (!mm) {
 		return -ENOMEM;
 	}
 	sman_mm->private = mm;
-	ret = drm_mm_init(mm, start, size);
+	ret = psb_drm_mm_init(mm, start, size);
 
 	if (ret) {
-		drm_free(mm, sizeof(*mm), DRM_MEM_MM);
+		psb_drm_free(mm, sizeof(*mm), DRM_MEM_MM);
 		return ret;
 	}
 
@@ -150,10 +150,10 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(drm_sman_set_range);
+EXPORT_SYMBOL(psb_drm_sman_set_range);
 
 int
-drm_sman_set_manager(struct drm_sman * sman, unsigned int manager,
+psb_drm_sman_set_manager(struct drm_sman * sman, unsigned int manager,
 		     struct drm_sman_mm * allocator)
 {
 	BUG_ON(manager >= sman->num_managers);
@@ -161,7 +161,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(drm_sman_set_manager);
+EXPORT_SYMBOL(psb_drm_sman_set_manager);
 
 static struct drm_owner_item *drm_sman_get_owner_item(struct drm_sman * sman,
 						 unsigned long owner)
@@ -176,7 +176,7 @@
 				      owner_hash);
 	}
 
-	owner_item = drm_calloc(1, sizeof(*owner_item), DRM_MEM_MM);
+	owner_item = psb_drm_calloc(1, sizeof(*owner_item), DRM_MEM_MM);
 	if (!owner_item)
 		goto out;
 
@@ -189,12 +189,12 @@
 	return owner_item;
 
 out1:
-	drm_free(owner_item, sizeof(*owner_item), DRM_MEM_MM);
+	psb_drm_free(owner_item, sizeof(*owner_item), DRM_MEM_MM);
 out:
 	return NULL;
 }
 
-struct drm_memblock_item *drm_sman_alloc(struct drm_sman *sman, unsigned int manager,
+struct drm_memblock_item *psb_drm_sman_alloc(struct drm_sman *sman, unsigned int manager,
 				    unsigned long size, unsigned alignment,
 				    unsigned long owner)
 {
@@ -212,7 +212,7 @@
 		return NULL;
 	}
 
-	memblock = drm_calloc(1, sizeof(*memblock), DRM_MEM_MM);
+	memblock = psb_drm_calloc(1, sizeof(*memblock), DRM_MEM_MM);
 
 	if (!memblock)
 		goto out;
@@ -237,14 +237,14 @@
 out2:
 	drm_ht_remove_item(&sman->user_hash_tab, &memblock->user_hash);
 out1:
-	drm_free(memblock, sizeof(*memblock), DRM_MEM_MM);
+	psb_drm_free(memblock, sizeof(*memblock), DRM_MEM_MM);
 out:
 	sman_mm->free(sman_mm->private, tmp);
 
 	return NULL;
 }
 
-EXPORT_SYMBOL(drm_sman_alloc);
+EXPORT_SYMBOL(psb_drm_sman_alloc);
 
 static void drm_sman_free(struct drm_memblock_item *item)
 {
@@ -253,10 +253,10 @@
 	list_del(&item->owner_list);
 	drm_ht_remove_item(&sman->user_hash_tab, &item->user_hash);
 	item->mm->free(item->mm->private, item->mm_info);
-	drm_free(item, sizeof(*item), DRM_MEM_MM);
+	psb_drm_free(item, sizeof(*item), DRM_MEM_MM);
 }
 
-int drm_sman_free_key(struct drm_sman *sman, unsigned int key)
+int psb_drm_sman_free_key(struct drm_sman *sman, unsigned int key)
 {
 	struct drm_hash_item *hash_item;
 	struct drm_memblock_item *memblock_item;
@@ -270,17 +270,17 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(drm_sman_free_key);
+EXPORT_SYMBOL(psb_drm_sman_free_key);
 
 static void drm_sman_remove_owner(struct drm_sman *sman,
 				  struct drm_owner_item *owner_item)
 {
 	list_del(&owner_item->sman_list);
 	drm_ht_remove_item(&sman->owner_hash_tab, &owner_item->owner_hash);
-	drm_free(owner_item, sizeof(*owner_item), DRM_MEM_MM);
+	psb_drm_free(owner_item, sizeof(*owner_item), DRM_MEM_MM);
 }
 
-int drm_sman_owner_clean(struct drm_sman *sman, unsigned long owner)
+int psb_drm_sman_owner_clean(struct drm_sman *sman, unsigned long owner)
 {
 
 	struct drm_hash_item *hash_item;
@@ -299,7 +299,7 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(drm_sman_owner_clean);
+EXPORT_SYMBOL(psb_drm_sman_owner_clean);
 
 static void drm_sman_do_owner_cleanup(struct drm_sman *sman,
 				      struct drm_owner_item *owner_item)
@@ -313,7 +313,7 @@
 	drm_sman_remove_owner(sman, owner_item);
 }
 
-void drm_sman_owner_cleanup(struct drm_sman *sman, unsigned long owner)
+void psb_drm_sman_owner_cleanup(struct drm_sman *sman, unsigned long owner)
 {
 
 	struct drm_hash_item *hash_item;
@@ -328,9 +328,9 @@
 	drm_sman_do_owner_cleanup(sman, owner_item);
 }
 
-EXPORT_SYMBOL(drm_sman_owner_cleanup);
+EXPORT_SYMBOL(psb_drm_sman_owner_cleanup);
 
-void drm_sman_cleanup(struct drm_sman *sman)
+void psb_drm_sman_cleanup(struct drm_sman *sman)
 {
 	struct drm_owner_item *entry, *next;
 	unsigned int i;
@@ -350,4 +350,4 @@
 	}
 }
 
-EXPORT_SYMBOL(drm_sman_cleanup);
+EXPORT_SYMBOL(psb_drm_sman_cleanup);
diff -urNad psb-kernel-source-4.41.2/drm_sman.h psb-kernel-source-4.41.2.drm_psb/drm_sman.h
--- psb-kernel-source-4.41.2/drm_sman.h	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_sman.h	2010-05-02 10:13:43.075194790 +0200
@@ -94,10 +94,10 @@
 
 /*
  * Take down a memory manager. This function should only be called after a
- * successful init and after a call to drm_sman_cleanup.
+ * successful init and after a call to psb_drm_sman_cleanup.
  */
 
-extern void drm_sman_takedown(struct drm_sman * sman);
+extern void psb_drm_sman_takedown(struct drm_sman * sman);
 
 /*
  * Allocate structures for a manager.
@@ -112,7 +112,7 @@
  *
  */
 
-extern int drm_sman_init(struct drm_sman * sman, unsigned int num_managers,
+extern int psb_drm_sman_init(struct drm_sman * sman, unsigned int num_managers,
 			 unsigned int user_order, unsigned int owner_order);
 
 /*
@@ -120,7 +120,7 @@
  * manager unless a customized allogator is used.
  */
 
-extern int drm_sman_set_range(struct drm_sman * sman, unsigned int manager,
+extern int psb_drm_sman_set_range(struct drm_sman * sman, unsigned int manager,
 			      unsigned long start, unsigned long size);
 
 /*
@@ -129,14 +129,14 @@
  * so it can be destroyed after this call.
  */
 
-extern int drm_sman_set_manager(struct drm_sman * sman, unsigned int mananger,
+extern int psb_drm_sman_set_manager(struct drm_sman * sman, unsigned int mananger,
 				struct drm_sman_mm * allocator);
 
 /*
  * Allocate a memory block. Aligment is not implemented yet.
  */
 
-extern struct drm_memblock_item *drm_sman_alloc(struct drm_sman * sman,
+extern struct drm_memblock_item *psb_drm_sman_alloc(struct drm_sman * sman,
 						unsigned int manager,
 						unsigned long size,
 						unsigned alignment,
@@ -145,16 +145,16 @@
  * Free a memory block identified by its user hash key.
  */
 
-extern int drm_sman_free_key(struct drm_sman * sman, unsigned int key);
+extern int psb_drm_sman_free_key(struct drm_sman * sman, unsigned int key);
 
 /*
  * returns 1 iff there are no stale memory blocks associated with this owner.
  * Typically called to determine if we need to idle the hardware and call
- * drm_sman_owner_cleanup. If there are no stale memory blocks, it removes all
+ * psb_drm_sman_owner_cleanup. If there are no stale memory blocks, it removes all
  * resources associated with owner.
  */
 
-extern int drm_sman_owner_clean(struct drm_sman * sman, unsigned long owner);
+extern int psb_drm_sman_owner_clean(struct drm_sman * sman, unsigned long owner);
 
 /*
  * Frees all stale memory blocks associated with this owner. Note that this
@@ -164,13 +164,13 @@
  * is not going to be referenced anymore.
  */
 
-extern void drm_sman_owner_cleanup(struct drm_sman * sman, unsigned long owner);
+extern void psb_drm_sman_owner_cleanup(struct drm_sman * sman, unsigned long owner);
 
 /*
  * Frees all stale memory blocks associated with the memory manager.
  * See idling above.
  */
 
-extern void drm_sman_cleanup(struct drm_sman * sman);
+extern void psb_drm_sman_cleanup(struct drm_sman * sman);
 
 #endif
diff -urNad psb-kernel-source-4.41.2/drm_stub.c psb-kernel-source-4.41.2.drm_psb/drm_stub.c
--- psb-kernel-source-4.41.2/drm_stub.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_stub.c	2010-05-02 10:13:41.783192927 +0200
@@ -38,8 +38,8 @@
 #include "drm_core.h"
 
 unsigned int drm_cards_limit = 16;	/* Enough for one machine */
-unsigned int drm_debug = 0;		/* 1 to enable debug output */
-EXPORT_SYMBOL(drm_debug);
+unsigned int psb_drm_debug = 0;		/* 1 to enable debug output */
+EXPORT_SYMBOL(psb_drm_debug);
 
 MODULE_AUTHOR(CORE_AUTHOR);
 MODULE_DESCRIPTION(CORE_DESC);
@@ -48,7 +48,7 @@
 MODULE_PARM_DESC(debug, "Enable debug output");
 
 module_param_named(cards_limit, drm_cards_limit, int, 0444);
-module_param_named(debug, drm_debug, int, 0600);
+module_param_named(debug, psb_drm_debug, int, 0600);
 
 struct drm_head **drm_heads;
 struct class *drm_class;
@@ -89,7 +89,7 @@
 	if (drm_ht_create(&dev->map_hash, DRM_MAP_HASH_ORDER))
 		return -ENOMEM;
 
-	if (drm_mm_init(&dev->offset_manager, DRM_FILE_PAGE_OFFSET_START,
+	if (psb_drm_mm_init(&dev->offset_manager, DRM_FILE_PAGE_OFFSET_START,
 			DRM_FILE_PAGE_OFFSET_SIZE)) {
 		drm_ht_remove(&dev->map_hash);
 		return -ENOMEM;
@@ -97,7 +97,7 @@
 
 	if (drm_ht_create(&dev->object_hash, DRM_OBJECT_HASH_ORDER)) {
 		drm_ht_remove(&dev->map_hash);
-		drm_mm_takedown(&dev->offset_manager);
+		psb_drm_mm_takedown(&dev->offset_manager);
 		return -ENOMEM;
 	}
 
@@ -217,7 +217,7 @@
  * then register the character device and inter module information.
  * Try and register, if we fail to register, backout previous work.
  */
-int drm_get_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
+int psb_drm_get_dev(struct pci_dev *pdev, const struct pci_device_id *ent,
 		struct drm_driver *driver)
 {
 	struct drm_device *dev;
@@ -225,7 +225,7 @@
 
 	DRM_DEBUG("\n");
 
-	dev = drm_calloc(1, sizeof(*dev), DRM_MEM_STUB);
+	dev = psb_drm_calloc(1, sizeof(*dev), DRM_MEM_STUB);
 	if (!dev)
 		return -ENOMEM;
 
@@ -264,11 +264,11 @@
 	if (!drm_fb_loaded)
 		pci_set_drvdata(pdev, NULL);
 
-	drm_free(dev, sizeof(*dev), DRM_MEM_STUB);
-	printk(KERN_ERR "DRM: drm_get_dev failed.\n");
+	psb_drm_free(dev, sizeof(*dev), DRM_MEM_STUB);
+	printk(KERN_ERR "DRM: psb_drm_get_dev failed.\n");
 	return ret;
 }
-EXPORT_SYMBOL(drm_get_dev);
+EXPORT_SYMBOL(psb_drm_get_dev);
 
 
 /**
@@ -286,16 +286,16 @@
 	DRM_DEBUG("release primary %s\n", dev->driver->pci_driver.name);
 
 	if (dev->unique) {
-		drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
+		psb_drm_free(dev->unique, strlen(dev->unique) + 1, DRM_MEM_DRIVER);
 		dev->unique = NULL;
 		dev->unique_len = 0;
 	}
 	if (dev->devname) {
-		drm_free(dev->devname, strlen(dev->devname) + 1,
+		psb_drm_free(dev->devname, strlen(dev->devname) + 1,
 			 DRM_MEM_DRIVER);
 		dev->devname = NULL;
 	}
-	drm_free(dev, sizeof(*dev), DRM_MEM_STUB);
+	psb_drm_free(dev, sizeof(*dev), DRM_MEM_STUB);
 	return 0;
 }
 
diff -urNad psb-kernel-source-4.41.2/drm_ttm.c psb-kernel-source-4.41.2.drm_psb/drm_ttm.c
--- psb-kernel-source-4.41.2/drm_ttm.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_ttm.c	2010-05-02 10:13:41.827193142 +0200
@@ -35,7 +35,7 @@
 	flush_agp_cache();
 }
 
-void drm_ttm_cache_flush(void)
+void psb_drm_ttm_cache_flush(void)
 {
   #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
   if (on_each_cpu(drm_ttm_ipi_handler, NULL, 1) != 0) 
@@ -44,7 +44,7 @@
   #endif
 		DRM_ERROR("Timed out waiting for drm cache flush.\n");
 }
-EXPORT_SYMBOL(drm_ttm_cache_flush);
+EXPORT_SYMBOL(psb_drm_ttm_cache_flush);
 
 /*
  * Use kmalloc if possible. Otherwise fall back to vmalloc.
@@ -56,7 +56,7 @@
 	ttm->pages = NULL;
 
 	if (size <= PAGE_SIZE)
-		ttm->pages = drm_calloc(1, size, DRM_MEM_TTM);
+		ttm->pages = psb_drm_calloc(1, size, DRM_MEM_TTM);
 
 	if (!ttm->pages) {
 		ttm->pages = vmalloc_user(size);
@@ -73,7 +73,7 @@
 		vfree(ttm->pages);
 		ttm->page_flags &= ~DRM_TTM_PAGE_VMALLOC;
 	} else {
-		drm_free(ttm->pages, size, DRM_MEM_TTM);
+		psb_drm_free(ttm->pages, size, DRM_MEM_TTM);
 	}
 	ttm->pages = NULL;
 }
@@ -106,7 +106,7 @@
 		return 0;
 
 	if (noncached)
-		drm_ttm_cache_flush();
+		psb_drm_ttm_cache_flush();
 
 	for (i = 0; i < ttm->num_pages; ++i) {
 		cur_page = ttm->pages + i;
@@ -215,7 +215,7 @@
 	return 0;
 }
 
-struct page *drm_ttm_get_page(struct drm_ttm *ttm, int index)
+struct page *psb_drm_ttm_get_page(struct drm_ttm *ttm, int index)
 {
 	struct page *p;
 	struct drm_buffer_manager *bm = &ttm->dev->bm;
@@ -230,7 +230,7 @@
 	}
 	return p;
 }
-EXPORT_SYMBOL(drm_ttm_get_page);
+EXPORT_SYMBOL(psb_drm_ttm_get_page);
 
 int drm_ttm_set_user(struct drm_ttm *ttm,
 		     struct task_struct *tsk,
@@ -279,7 +279,7 @@
 
 	be = ttm->be;
 	for (i = 0; i < ttm->num_pages; ++i) {
-		page = drm_ttm_get_page(ttm, i);
+		page = psb_drm_ttm_get_page(ttm, i);
 		if (!page)
 			return -ENOMEM;
 	}
@@ -324,7 +324,7 @@
 	if (!bo_driver)
 		return NULL;
 
-	ttm = drm_calloc(1, sizeof(*ttm), DRM_MEM_TTM);
+	ttm = psb_drm_calloc(1, sizeof(*ttm), DRM_MEM_TTM);
 	if (!ttm)
 		return NULL;
 
@@ -392,7 +392,7 @@
 	drm_ttm_fixup_caching(ttm);
 }
 
-int drm_bind_ttm(struct drm_ttm *ttm, struct drm_bo_mem_reg *bo_mem)
+int psb_drm_bind_ttm(struct drm_ttm *ttm, struct drm_bo_mem_reg *bo_mem)
 {
 	struct drm_bo_driver *bo_driver = ttm->dev->driver->bo_driver;
 	int ret = 0;
@@ -427,4 +427,4 @@
 		ttm->page_flags |= DRM_TTM_PAGE_USER_DIRTY;
 	return 0;
 }
-EXPORT_SYMBOL(drm_bind_ttm);
+EXPORT_SYMBOL(psb_drm_bind_ttm);
diff -urNad psb-kernel-source-4.41.2/drm_vm.c psb-kernel-source-4.41.2.drm_psb/drm_vm.c
--- psb-kernel-source-4.41.2/drm_vm.c	2009-08-11 20:18:30.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/drm_vm.c	2010-05-02 10:13:45.671193442 +0200
@@ -227,7 +227,7 @@
 			found_maps++;
 		if (pt->vma == vma) {
 			list_del(&pt->head);
-			drm_free(pt, sizeof(*pt), DRM_MEM_VMAS);
+			psb_drm_free(pt, sizeof(*pt), DRM_MEM_VMAS);
 		}
 	}
 	/* We were the only map that was found */
@@ -272,7 +272,7 @@
 				BUG_ON(1);
 				break;
 			}
-			drm_free(map, sizeof(*map), DRM_MEM_MAPS);
+			psb_drm_free(map, sizeof(*map), DRM_MEM_MAPS);
 		}
 	}
 	mutex_unlock(&dev->struct_mutex);
@@ -411,7 +411,7 @@
 		  vma->vm_start, vma->vm_end - vma->vm_start);
 	atomic_inc(&dev->vma_count);
 
-	vma_entry = drm_alloc(sizeof(*vma_entry), DRM_MEM_VMAS);
+	vma_entry = psb_drm_alloc(sizeof(*vma_entry), DRM_MEM_VMAS);
 	if (vma_entry) {
 		vma_entry->vma = vma;
 		vma_entry->pid = current->pid;
@@ -451,7 +451,7 @@
 	list_for_each_entry_safe(pt, temp, &dev->vmalist, head) {
 		if (pt->vma == vma) {
 			list_del(&pt->head);
-			drm_free(pt, sizeof(*pt), DRM_MEM_VMAS);
+			psb_drm_free(pt, sizeof(*pt), DRM_MEM_VMAS);
 			break;
 		}
 	}
@@ -509,13 +509,13 @@
 	return 0;
 }
 
-unsigned long drm_core_get_map_ofs(struct drm_map * map)
+unsigned long psb_drm_core_get_map_ofs(struct drm_map * map)
 {
 	return map->offset;
 }
-EXPORT_SYMBOL(drm_core_get_map_ofs);
+EXPORT_SYMBOL(psb_drm_core_get_map_ofs);
 
-unsigned long drm_core_get_reg_ofs(struct drm_device *dev)
+unsigned long psb_drm_core_get_reg_ofs(struct drm_device *dev)
 {
 #ifdef __alpha__
 	return dev->hose->dense_mem_base - dev->hose->mem_space->start;
@@ -523,7 +523,7 @@
 	return 0;
 #endif
 }
-EXPORT_SYMBOL(drm_core_get_reg_ofs);
+EXPORT_SYMBOL(psb_drm_core_get_reg_ofs);
 
 /**
  * mmap DMA memory.
@@ -659,7 +659,7 @@
 	return 0;
 }
 
-int drm_mmap(struct file *filp, struct vm_area_struct *vma)
+int psb_drm_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	struct drm_file *priv = filp->private_data;
 	struct drm_device *dev = priv->head->dev;
@@ -671,7 +671,7 @@
 
 	return ret;
 }
-EXPORT_SYMBOL(drm_mmap);
+EXPORT_SYMBOL(psb_drm_mmap);
 
 /**
  * buffer object vm functions.
@@ -720,17 +720,17 @@
 		return VM_FAULT_SIGBUS;
 
 	dev = bo->dev;
-	err = drm_bo_read_lock(&dev->bm.bm_lock, 1);
+	err = psb_drm_bo_read_lock(&dev->bm.bm_lock, 1);
 	if (err)
 		return VM_FAULT_NOPAGE;
 
 	err = mutex_lock_interruptible(&bo->mutex);
 	if (err) {
-		drm_bo_read_unlock(&dev->bm.bm_lock);
+		psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 		return VM_FAULT_NOPAGE;
 	}
 
-	err = drm_bo_wait(bo, 0, 0, 0);
+	err = psb_drm_bo_wait(bo, 0, 0, 0);
 	if (err) {
 		ret = (err != -EAGAIN) ? VM_FAULT_SIGBUS : VM_FAULT_NOPAGE;
 		goto out_unlock;
@@ -771,7 +771,7 @@
 		ttm = bo->ttm;
 
 		drm_ttm_fixup_caching(ttm);
-		page = drm_ttm_get_page(ttm, page_offset);
+		page = psb_drm_ttm_get_page(ttm, page_offset);
 		if (!page) {
 			ret = VM_FAULT_OOM;
 			goto out_unlock;
@@ -799,7 +799,7 @@
 			pfn = ((bus_base + bus_offset) >> PAGE_SHIFT) 
 				+ page_offset;
 		} else {
-			page = drm_ttm_get_page(ttm, page_offset);
+			page = psb_drm_ttm_get_page(ttm, page_offset);
 			if (!page)
 				break;
 			pfn = page_to_pfn(page);
@@ -809,11 +809,11 @@
 	}
 out_unlock:
 	mutex_unlock(&bo->mutex);
-	drm_bo_read_unlock(&dev->bm.bm_lock);
+	psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 	return ret;
 }
 
-int drm_bo_vm_nopfn(struct vm_area_struct *vma,
+int psb_drm_bo_vm_nopfn(struct vm_area_struct *vma,
 			      struct vm_fault *vmf )
 {
 	struct drm_buffer_object *bo = (struct drm_buffer_object *) vma->vm_private_data;
@@ -835,17 +835,17 @@
 		return VM_FAULT_SIGBUS;
 
 	dev = bo->dev;
-	err = drm_bo_read_lock(&dev->bm.bm_lock, 1);
+	err = psb_drm_bo_read_lock(&dev->bm.bm_lock, 1);
 	if (err)
 		return VM_FAULT_NOPAGE;
 
 	err = mutex_lock_interruptible(&bo->mutex);
 	if (err) {
-		drm_bo_read_unlock(&dev->bm.bm_lock);
+		psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 		return VM_FAULT_NOPAGE;
 	}
 
-	err = drm_bo_wait(bo, 0, 0, 0);
+	err = psb_drm_bo_wait(bo, 0, 0, 0);
 	if (err) {
 		ret = (err != -EAGAIN) ? VM_FAULT_SIGBUS : VM_FAULT_NOPAGE;
 		goto out_unlock;
@@ -886,7 +886,7 @@
 		ttm = bo->ttm;
 
 		drm_ttm_fixup_caching(ttm);
-		page = drm_ttm_get_page(ttm, page_offset);
+		page = psb_drm_ttm_get_page(ttm, page_offset);
 		if (!page) {
 			ret = VM_FAULT_OOM;
 			goto out_unlock;
@@ -914,7 +914,7 @@
 			pfn = ((bus_base + bus_offset) >> PAGE_SHIFT) 
 				+ page_offset;
 		} else {
-			page = drm_ttm_get_page(ttm, page_offset);
+			page = psb_drm_ttm_get_page(ttm, page_offset);
 			if (!page)
 				break;
 			pfn = page_to_pfn(page);
@@ -924,12 +924,12 @@
 	}
 out_unlock:
 	mutex_unlock(&bo->mutex);
-	drm_bo_read_unlock(&dev->bm.bm_lock);
+	psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 	return ret;
 }
 
 #else
-unsigned long drm_bo_vm_nopfn(struct vm_area_struct *vma,
+unsigned long psb_drm_bo_vm_nopfn(struct vm_area_struct *vma,
 			      unsigned long address)
 {
 	struct drm_buffer_object *bo = (struct drm_buffer_object *) vma->vm_private_data;
@@ -949,17 +949,17 @@
 		return NOPFN_SIGBUS;
 
 	dev = bo->dev;
-	err = drm_bo_read_lock(&dev->bm.bm_lock, 1);
+	err = psb_drm_bo_read_lock(&dev->bm.bm_lock, 1);
 	if (err)
 		return NOPFN_REFAULT;
 
 	err = mutex_lock_interruptible(&bo->mutex);
 	if (err) {
-		drm_bo_read_unlock(&dev->bm.bm_lock);
+		psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 		return NOPFN_REFAULT;
 	}
 
-	err = drm_bo_wait(bo, 0, 0, 0);
+	err = psb_drm_bo_wait(bo, 0, 0, 0);
 	if (err) {
 		ret = (err != -EAGAIN) ? NOPFN_SIGBUS : NOPFN_REFAULT;
 		goto out_unlock;
@@ -1000,7 +1000,7 @@
 		ttm = bo->ttm;
 
 		drm_ttm_fixup_caching(ttm);
-		page = drm_ttm_get_page(ttm, page_offset);
+		page = psb_drm_ttm_get_page(ttm, page_offset);
 		if (!page) {
 			ret = NOPFN_OOM;
 			goto out_unlock;
@@ -1028,7 +1028,7 @@
 			pfn = ((bus_base + bus_offset) >> PAGE_SHIFT) 
 				+ page_offset;
 		} else {
-			page = drm_ttm_get_page(ttm, page_offset);
+			page = psb_drm_ttm_get_page(ttm, page_offset);
 			if (!page)
 				break;
 			pfn = page_to_pfn(page);
@@ -1038,12 +1038,12 @@
 	}
 out_unlock:
 	mutex_unlock(&bo->mutex);
-	drm_bo_read_unlock(&dev->bm.bm_lock);
+	psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 	return ret;
 }
 #endif
 
-EXPORT_SYMBOL(drm_bo_vm_nopfn);
+EXPORT_SYMBOL(psb_drm_bo_vm_nopfn);
 #endif
    
    static void drm_bo_vm_open_locked(struct vm_area_struct *vma)
@@ -1090,7 +1090,7 @@
    #ifdef DRM_ODD_MM_COMPAT
    		drm_bo_delete_vma(bo, vma);
    #endif
-   		drm_bo_usage_deref_locked((struct drm_buffer_object **)
+   		psb_drm_bo_usage_deref_locked((struct drm_buffer_object **)
    					  &vma->vm_private_data);
    		mutex_unlock(&dev->struct_mutex);
    	}
@@ -1102,10 +1102,10 @@
            .fault = drm_bo_vm_fault,
    #else
    #ifdef DRM_FULL_MM_COMPAT
-           .nopfn = drm_bo_vm_nopfn,
+           .nopfn = psb_drm_bo_vm_nopfn,
    #else
    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19))
-           .nopfn = drm_bo_vm_nopfn,
+           .nopfn = psb_drm_bo_vm_nopfn,
    #else
    	.nopage = drm_bo_vm_nopage,
    #endif
diff -urNad psb-kernel-source-4.41.2/i915_buffer.c psb-kernel-source-4.41.2.drm_psb/i915_buffer.c
--- psb-kernel-source-4.41.2/i915_buffer.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_buffer.c	2010-05-02 10:13:45.903192473 +0200
@@ -35,7 +35,7 @@
 
 struct drm_ttm_backend *i915_create_ttm_backend_entry(struct drm_device *dev)
 {
-	return drm_agp_init_ttm(dev);
+	return psb_drm_agp_init_ttm(dev);
 }
 
 int i915_fence_types(struct drm_buffer_object *bo,
@@ -179,7 +179,7 @@
 
 	i915_emit_mi_flush(bo->dev, MI_READ_FLUSH | MI_EXE_FLUSH);
 
-	return drm_bo_move_accel_cleanup(bo, evict, no_wait, 0,
+	return psb_drm_bo_move_accel_cleanup(bo, evict, no_wait, 0,
 					 DRM_FENCE_TYPE_EXE |
 					 DRM_I915_FENCE_TYPE_RW,
 					 DRM_I915_FENCE_FLAG_FLUSHED, new_mem);
@@ -202,11 +202,11 @@
 	tmp_mem.mask = DRM_BO_FLAG_MEM_TT |
 	    DRM_BO_FLAG_CACHED | DRM_BO_FLAG_FORCE_CACHING;
 
-	ret = drm_bo_mem_space(bo, &tmp_mem, no_wait);
+	ret = psb_drm_bo_mem_space(bo, &tmp_mem, no_wait);
 	if (ret)
 		return ret;
 
-	ret = drm_bind_ttm(bo->ttm, &tmp_mem);
+	ret = psb_drm_bind_ttm(bo->ttm, &tmp_mem);
 	if (ret)
 		goto out_cleanup;
 
@@ -214,12 +214,12 @@
 	if (ret)
 		goto out_cleanup;
 
-	ret = drm_bo_move_ttm(bo, evict, no_wait, new_mem);
+	ret = psb_drm_bo_move_ttm(bo, evict, no_wait, new_mem);
 out_cleanup:
 	if (tmp_mem.mm_node) {
 		mutex_lock(&dev->struct_mutex);
 		if (tmp_mem.mm_node != bo->pinned_node)
-			drm_mm_put_block(tmp_mem.mm_node);
+			psb_drm_mm_put_block(tmp_mem.mm_node);
 		tmp_mem.mm_node = NULL;
 		mutex_unlock(&dev->struct_mutex);
 	}
@@ -241,13 +241,13 @@
 	struct drm_bo_mem_reg *old_mem = &bo->mem;
 
 	if (old_mem->mem_type == DRM_BO_MEM_LOCAL) {
-		return drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
+		return psb_drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
 	} else if (new_mem->mem_type == DRM_BO_MEM_LOCAL) {
 		if (0) /*i915_move_flip(bo, evict, no_wait, new_mem)*/
-			return drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
+			return psb_drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
 	} else {
 		if (0) /*i915_move_blit(bo, evict, no_wait, new_mem)*/
-			return drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
+			return psb_drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
 	}
 	return 0;
 }
@@ -281,6 +281,6 @@
 
 	DRM_MEMORYBARRIER();
 	for (i = ttm->num_pages-1; i >= 0; i--)
-		drm_cache_flush_page(drm_ttm_get_page(ttm, i));
+		drm_cache_flush_page(psb_drm_ttm_get_page(ttm, i));
 	DRM_MEMORYBARRIER();
 }
diff -urNad psb-kernel-source-4.41.2/i915_dma.c psb-kernel-source-4.41.2.drm_psb/i915_dma.c
--- psb-kernel-source-4.41.2/i915_dma.c	2009-04-16 05:25:02.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_dma.c	2010-05-02 10:13:43.883192724 +0200
@@ -85,7 +85,7 @@
 	 * is freed, it's too late.
 	 */
 	if (dev->irq)
-		drm_irq_uninstall(dev);
+		psb_drm_irq_uninstall(dev);
 
 	return 0;
 }
@@ -94,7 +94,7 @@
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
-	dev_priv->sarea = drm_getsarea(dev);
+	dev_priv->sarea = psb_drm_getsarea(dev);
 	if (!dev_priv->sarea) {
 		DRM_ERROR("can not find sarea!\n");
 		i915_dma_cleanup(dev);
@@ -126,7 +126,7 @@
 	dev_priv->ring.map.flags = 0;
 	dev_priv->ring.map.mtrr = 0;
 
-	drm_core_ioremap(&dev_priv->ring.map, dev);
+	psb_drm_core_ioremap(&dev_priv->ring.map, dev);
 
 	if (dev_priv->ring.map.handle == NULL) {
 		i915_dma_cleanup(dev);
@@ -156,7 +156,7 @@
 	/* Program Hardware Status Page */
 	if (!IS_G33(dev)) {
 		dev_priv->status_page_dmah =
-			drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE, 0xffffffff);
+			psb_drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE, 0xffffffff);
 
 		if (!dev_priv->status_page_dmah) {
 			i915_dma_cleanup(dev);
@@ -477,7 +477,7 @@
 	i915_emit_breadcrumb( dev );
 #ifdef I915_HAVE_FENCE
 	if (unlikely((dev_priv->counter & 0xFF) == 0))
-		drm_fence_flush_old(dev, 0, dev_priv->counter);
+		psb_drm_fence_flush_old(dev, 0, dev_priv->counter);
 #endif
 	return 0;
 }
@@ -532,7 +532,7 @@
 	i915_emit_breadcrumb( dev );
 #ifdef I915_HAVE_FENCE
 	if (unlikely((dev_priv->counter & 0xFF) == 0))
-		drm_fence_flush_old(dev, 0, dev_priv->counter);
+		psb_drm_fence_flush_old(dev, 0, dev_priv->counter);
 #endif
 	return 0;
 }
@@ -607,7 +607,7 @@
 	i915_emit_breadcrumb(dev);
 #ifdef I915_HAVE_FENCE
 	if (unlikely(!sync && ((dev_priv->counter & 0xFF) == 0)))
-		drm_fence_flush_old(dev, 0, dev_priv->counter);
+		psb_drm_fence_flush_old(dev, 0, dev_priv->counter);
 #endif
 }
 
@@ -704,7 +704,7 @@
 					    unsigned num_buffers)
 {
 	while (num_buffers--)
-		drm_bo_usage_deref_locked(&buffers[num_buffers]);
+		psb_drm_bo_usage_deref_locked(&buffers[num_buffers]);
 }
 
 int i915_apply_reloc(struct drm_file *file_priv, int num_buffers,
@@ -724,10 +724,10 @@
 
 	new_cmd_offset = reloc[0];
 	if (!relocatee->data_page ||
-	    !drm_bo_same_page(relocatee->offset, new_cmd_offset)) {
-		drm_bo_kunmap(&relocatee->kmap);
+	    !psb_drm_bo_same_page(relocatee->offset, new_cmd_offset)) {
+		psb_drm_bo_kunmap(&relocatee->kmap);
 		relocatee->offset = new_cmd_offset;
-		ret = drm_bo_kmap(relocatee->buf, new_cmd_offset >> PAGE_SHIFT,
+		ret = psb_drm_bo_kmap(relocatee->buf, new_cmd_offset >> PAGE_SHIFT,
 				  1, &relocatee->kmap);
 		if (ret) {
 			DRM_ERROR("Could not map command buffer to apply relocs\n %08lx", new_cmd_offset);
@@ -767,12 +767,12 @@
 	memset(&reloc_kmap, 0, sizeof(reloc_kmap));
 
 	mutex_lock(&dev->struct_mutex);
-	reloc_list_object = drm_lookup_buffer_object(file_priv, cur_handle, 1);
+	reloc_list_object = psb_drm_lookup_buffer_object(file_priv, cur_handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 	if (!reloc_list_object)
 		return -EINVAL;
 
-	ret = drm_bo_kmap(reloc_list_object, 0, 1, &reloc_kmap);
+	ret = psb_drm_bo_kmap(reloc_list_object, 0, 1, &reloc_kmap);
 	if (ret) {
 		DRM_ERROR("Could not map relocation buffer.\n");
 		goto out;
@@ -797,7 +797,7 @@
 	reloc_end = reloc_offset + (num_relocs * reloc_stride);
 
 	do {
-		next_offset = drm_bo_offset_end(reloc_offset, reloc_end);
+		next_offset = psb_drm_bo_offset_end(reloc_offset, reloc_end);
 
 		do {
 			cur_offset = ((reloc_offset + reloc_page_offset) & ~PAGE_MASK) / sizeof(uint32_t);
@@ -809,11 +809,11 @@
 			reloc_offset += reloc_stride;
 		} while (reloc_offset < next_offset);
 
-		drm_bo_kunmap(&reloc_kmap);
+		psb_drm_bo_kunmap(&reloc_kmap);
 
 		reloc_offset = next_offset;
 		if (reloc_offset != reloc_end) {
-			ret = drm_bo_kmap(reloc_list_object, reloc_offset >> PAGE_SHIFT, 1, &reloc_kmap);
+			ret = psb_drm_bo_kmap(reloc_list_object, reloc_offset >> PAGE_SHIFT, 1, &reloc_kmap);
 			if (ret) {
 				DRM_ERROR("Could not map relocation buffer.\n");
 				goto out;
@@ -825,13 +825,13 @@
 
 	} while (reloc_offset != reloc_end);
 out:
-	drm_bo_kunmap(&relocatee->kmap);
+	psb_drm_bo_kunmap(&relocatee->kmap);
 	relocatee->data_page = NULL;
 
-	drm_bo_kunmap(&reloc_kmap);
+	psb_drm_bo_kunmap(&reloc_kmap);
 
 	mutex_lock(&dev->struct_mutex);
-	drm_bo_usage_deref_locked(&reloc_list_object);
+	psb_drm_bo_usage_deref_locked(&reloc_list_object);
 	mutex_unlock(&dev->struct_mutex);
 
 	return ret;
@@ -849,7 +849,7 @@
 	memset(&relocatee, 0, sizeof(relocatee));
 
 	mutex_lock(&dev->struct_mutex);
-	relocatee.buf = drm_lookup_buffer_object(file_priv, buf_handle, 1);
+	relocatee.buf = psb_drm_lookup_buffer_object(file_priv, buf_handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 	if (!relocatee.buf) {
 		DRM_DEBUG("relocatee buffer invalid %08x\n", buf_handle);
@@ -866,7 +866,7 @@
 	}
 
 	mutex_lock(&dev->struct_mutex);
-	drm_bo_usage_deref_locked(&relocatee.buf);
+	psb_drm_bo_usage_deref_locked(&relocatee.buf);
 	mutex_unlock(&dev->struct_mutex);
 
 out_err:
@@ -908,7 +908,7 @@
 		if (arg.handled) {
 			data = arg.next;
 			mutex_lock(&dev->struct_mutex);
-			buffers[buf_count] = drm_lookup_buffer_object(file_priv, req->arg_handle, 1);
+			buffers[buf_count] = psb_drm_lookup_buffer_object(file_priv, req->arg_handle, 1);
 			mutex_unlock(&dev->struct_mutex);
 			buf_count++;
 			continue;
@@ -932,7 +932,7 @@
 			DRM_MEMORYBARRIER();
 		}
 
-		rep.ret = drm_bo_handle_validate(file_priv, req->bo_req.handle,
+		rep.ret = psb_drm_bo_handle_validate(file_priv, req->bo_req.handle,
 						 req->bo_req.fence_class,
 						 req->bo_req.flags,
 						 req->bo_req.mask,
@@ -997,7 +997,7 @@
 		return -EINVAL;
 
 
-	ret = drm_bo_read_lock(&dev->bm.bm_lock, 1);
+	ret = psb_drm_bo_read_lock(&dev->bm.bm_lock, 1);
 	if (ret)
 		return ret;
 
@@ -1008,15 +1008,15 @@
 
 	ret = mutex_lock_interruptible(&dev_priv->cmdbuf_mutex);
 	if (ret) {
-		drm_bo_read_unlock(&dev->bm.bm_lock);
+		psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 		return -EAGAIN;
 	}
 
 	num_buffers = exec_buf->num_buffers;
 
-	buffers = drm_calloc(num_buffers, sizeof(struct drm_buffer_object *), DRM_MEM_DRIVER);
+	buffers = psb_drm_calloc(num_buffers, sizeof(struct drm_buffer_object *), DRM_MEM_DRIVER);
 	if (!buffers) {
-	        drm_bo_read_unlock(&dev->bm.bm_lock);
+	        psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 		mutex_unlock(&dev_priv->cmdbuf_mutex);
 		return -ENOMEM;
         }
@@ -1044,12 +1044,12 @@
 	sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
 
 	/* fence */
-	ret = drm_fence_buffer_objects(dev, NULL, 0, NULL, &fence);
+	ret = psb_drm_fence_buffer_objects(dev, NULL, 0, NULL, &fence);
 	if (ret)
 		goto out_err0;
 
 	if (!(fence_arg->flags & DRM_FENCE_FLAG_NO_USER)) {
-		ret = drm_fence_add_user_object(file_priv, fence, fence_arg->flags & DRM_FENCE_FLAG_SHAREABLE);
+		ret = psb_drm_fence_add_user_object(file_priv, fence, fence_arg->flags & DRM_FENCE_FLAG_SHAREABLE);
 		if (!ret) {
 			fence_arg->handle = fence->base.hash.key;
 			fence_arg->fence_class = fence->fence_class;
@@ -1057,7 +1057,7 @@
 			fence_arg->signaled = fence->signaled_types;
 		}
 	}
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 out_err0:
 
 	/* handle errors */
@@ -1066,10 +1066,10 @@
 	mutex_unlock(&dev->struct_mutex);
 
 out_free:
-	drm_free(buffers, (exec_buf->num_buffers * sizeof(struct drm_buffer_object *)), DRM_MEM_DRIVER);
+	psb_drm_free(buffers, (exec_buf->num_buffers * sizeof(struct drm_buffer_object *)), DRM_MEM_DRIVER);
 
 	mutex_unlock(&dev_priv->cmdbuf_mutex);
-	drm_bo_read_unlock(&dev->bm.bm_lock);
+	psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 	return ret;
 }
 #endif
@@ -1262,7 +1262,7 @@
 	dev_priv->hws_map.flags = 0;
 	dev_priv->hws_map.mtrr = 0;
 
-	drm_core_ioremap(&dev_priv->hws_map, dev);
+	psb_drm_core_ioremap(&dev_priv->hws_map, dev);
 	if (dev_priv->hws_map.handle == NULL) {
 		i915_dma_cleanup(dev);
 		dev_priv->status_gfx_addr = 0;
diff -urNad psb-kernel-source-4.41.2/i915_drv.c psb-kernel-source-4.41.2.drm_psb/i915_drv.c
--- psb-kernel-source-4.41.2/i915_drv.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_drv.c	2010-05-02 10:13:42.703193876 +0200
@@ -545,20 +545,20 @@
 	.irq_postinstall = i915_driver_irq_postinstall,
 	.irq_uninstall = i915_driver_irq_uninstall,
 	.irq_handler = i915_driver_irq_handler,
-	.reclaim_buffers = drm_core_reclaim_buffers,
-	.get_map_ofs = drm_core_get_map_ofs,
-	.get_reg_ofs = drm_core_get_reg_ofs,
-	.fb_probe = intelfb_probe,
-	.fb_remove = intelfb_remove,
+	.reclaim_buffers = psb_drm_core_reclaim_buffers,
+	.get_map_ofs = psb_drm_core_get_map_ofs,
+	.get_reg_ofs = psb_drm_core_get_reg_ofs,
+	.fb_probe = psb_intelfb_probe,
+	.fb_remove = psb_intelfb_remove,
 	.ioctls = i915_ioctls,
 	.fops = {
 		.owner = THIS_MODULE,
-		.open = drm_open,
-		.release = drm_release,
-		.ioctl = drm_ioctl,
-		.mmap = drm_mmap,
-		.poll = drm_poll,
-		.fasync = drm_fasync,
+		.open = psb_drm_open,
+		.release = psb_drm_release,
+		.ioctl = psb_drm_ioctl,
+		.mmap = psb_drm_mmap,
+		.poll = psb_drm_poll,
+		.fasync = psb_drm_fasync,
 #if defined(CONFIG_COMPAT) && LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
 		.compat_ioctl = i915_compat_ioctl,
 #endif
@@ -567,7 +567,7 @@
 		.name = DRIVER_NAME,
 		.id_table = pciidlist,
 		.probe = probe,
-		.remove = __devexit_p(drm_cleanup_pci),
+		.remove = __devexit_p(psb_drm_cleanup_pci),
 		},
 #ifdef I915_HAVE_FENCE
 	.fence_driver = &i915_fence_driver,
@@ -585,18 +585,18 @@
 
 static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	return drm_get_dev(pdev, ent, &driver);
+	return psb_drm_get_dev(pdev, ent, &driver);
 }
 
 static int __init i915_init(void)
 {
 	driver.num_ioctls = i915_max_ioctl;
-	return drm_init(&driver, pciidlist);
+	return psb_drm_init(&driver, pciidlist);
 }
 
 static void __exit i915_exit(void)
 {
-	drm_exit(&driver);
+	psb_drm_exit(&driver);
 }
 
 module_init(i915_init);
diff -urNad psb-kernel-source-4.41.2/i915_fence.c psb-kernel-source-4.41.2.drm_psb/i915_fence.c
--- psb-kernel-source-4.41.2/i915_fence.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_fence.c	2010-05-02 10:13:45.791192761 +0200
@@ -94,7 +94,7 @@
 			flush_flags = dev_priv->flush_flags;
 			flush_sequence = dev_priv->flush_sequence;
 			dev_priv->flush_pending = 0;
-			drm_fence_handler(dev, 0, flush_sequence, flush_flags, 0);
+			psb_drm_fence_handler(dev, 0, flush_sequence, flush_flags, 0);
 		}
 	}		
 
@@ -107,7 +107,7 @@
 
 		if (sequence != dev_priv->reported_sequence ||
 		    !dev_priv->reported_sequence_valid) {
-			drm_fence_handler(dev, 0, sequence, 
+			psb_drm_fence_handler(dev, 0, sequence, 
 					  DRM_FENCE_TYPE_EXE, 0);
 			dev_priv->reported_sequence = sequence;
 			dev_priv->reported_sequence_valid = 1;
@@ -139,7 +139,7 @@
 			flush_flags = dev_priv->flush_flags;
 			flush_sequence = dev_priv->flush_sequence;
 			dev_priv->flush_pending = 0;
-			drm_fence_handler(dev, 0, flush_sequence, flush_flags, 0);
+			psb_drm_fence_handler(dev, 0, flush_sequence, flush_flags, 0);
 		}
 	}
 }
@@ -186,14 +186,14 @@
 	int ret;
 	unsigned long  _end = jiffies + 3 * DRM_HZ;
 
-	drm_fence_object_flush(fence, mask);
+	psb_drm_fence_object_flush(fence, mask);
 	if (likely(interruptible))
 		ret = wait_event_interruptible_timeout
-			(fc->fence_queue, drm_fence_object_signaled(fence, DRM_FENCE_TYPE_EXE), 
+			(fc->fence_queue, psb_drm_fence_object_signaled(fence, DRM_FENCE_TYPE_EXE), 
 			 3 * DRM_HZ);
 	else 
 		ret = wait_event_timeout
-			(fc->fence_queue, drm_fence_object_signaled(fence, DRM_FENCE_TYPE_EXE), 
+			(fc->fence_queue, psb_drm_fence_object_signaled(fence, DRM_FENCE_TYPE_EXE), 
 			 3 * DRM_HZ);
 
 	if (unlikely(ret == -ERESTARTSYS))
@@ -203,7 +203,7 @@
 		return -EBUSY;
 
 	if (likely(mask == DRM_FENCE_TYPE_EXE || 
-		   drm_fence_object_signaled(fence, mask))) 
+		   psb_drm_fence_object_signaled(fence, mask))) 
 		return 0;
 
 	/*
@@ -218,7 +218,7 @@
 		msleep(100);
 		dev_priv->flush_pending = 0;
 		write_lock_irqsave(&fm->lock, irq_flags);
-		drm_fence_handler(dev, fence->fence_class, 
+		psb_drm_fence_handler(dev, fence->fence_class, 
 				  fence->sequence, fence->type, 0);
 		write_unlock_irqrestore(&fm->lock, irq_flags);
 	}
@@ -227,7 +227,7 @@
 	 * Poll for sync flush completion.
 	 */
 
-	return drm_fence_wait_polling(fence, lazy, interruptible, mask, _end);
+	return psb_drm_fence_wait_polling(fence, lazy, interruptible, mask, _end);
 }
 
 static uint32_t i915_fence_needed_flush(struct drm_fence_object *fence)
diff -urNad psb-kernel-source-4.41.2/i915_init.c psb-kernel-source-4.41.2.drm_psb/i915_init.c
--- psb-kernel-source-4.41.2/i915_init.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_init.c	2010-05-02 10:13:44.771193083 +0200
@@ -116,7 +116,7 @@
 	unsigned long sareapage;
 	int size, ret;
 
-	dev_priv = drm_alloc(sizeof(struct drm_i915_private), DRM_MEM_DRIVER);
+	dev_priv = psb_drm_alloc(sizeof(struct drm_i915_private), DRM_MEM_DRIVER);
 	if (dev_priv == NULL)
 		return -ENOMEM;
 
@@ -132,15 +132,15 @@
 	dev->types[9] = _DRM_STAT_DMA;
 
 	if (IS_I9XX(dev)) {
-		dev_priv->mmiobase = drm_get_resource_start(dev, 0);
-		dev_priv->mmiolen = drm_get_resource_len(dev, 0);
+		dev_priv->mmiobase = psb_drm_get_resource_start(dev, 0);
+		dev_priv->mmiolen = psb_drm_get_resource_len(dev, 0);
 		dev->mode_config.fb_base =
-			drm_get_resource_start(dev, 2) & 0xff000000;
-	} else if (drm_get_resource_start(dev, 1)) {
-		dev_priv->mmiobase = drm_get_resource_start(dev, 1);
-		dev_priv->mmiolen = drm_get_resource_len(dev, 1);
+			psb_drm_get_resource_start(dev, 2) & 0xff000000;
+	} else if (psb_drm_get_resource_start(dev, 1)) {
+		dev_priv->mmiobase = psb_drm_get_resource_start(dev, 1);
+		dev_priv->mmiolen = psb_drm_get_resource_len(dev, 1);
 		dev->mode_config.fb_base =
-			drm_get_resource_start(dev, 0) & 0xff000000;
+			psb_drm_get_resource_start(dev, 0) & 0xff000000;
 	} else {
 		DRM_ERROR("Unable to find MMIO registers\n");
 		return -ENODEV;
@@ -148,7 +148,7 @@
 
 	DRM_DEBUG("fb_base: 0x%08lx\n", dev->mode_config.fb_base);
 
-	ret = drm_addmap(dev, dev_priv->mmiobase, dev_priv->mmiolen,
+	ret = psb_drm_addmap(dev, dev_priv->mmiobase, dev_priv->mmiolen,
 			 _DRM_REGISTERS, _DRM_READ_ONLY|_DRM_DRIVER, &dev_priv->mmio_map);
 	if (ret != 0) {
 		DRM_ERROR("Cannot add mapping for MMIO registers\n");
@@ -157,7 +157,7 @@
 
 	/* prebuild the SAREA */
 	sareapage = max(SAREA_MAX, PAGE_SIZE);
-	ret = drm_addmap(dev, 0, sareapage, _DRM_SHM, _DRM_CONTAINS_LOCK|_DRM_DRIVER,
+	ret = psb_drm_addmap(dev, 0, sareapage, _DRM_SHM, _DRM_CONTAINS_LOCK|_DRM_DRIVER,
 			 &dev_priv->sarea);
 	if (ret) {
 		DRM_ERROR("SAREA setup failed\n");
@@ -172,20 +172,20 @@
 	/*
 	 * Initialize the memory manager for local and AGP space
 	 */
-	drm_bo_driver_init(dev);
+	psb_drm_bo_driver_init(dev);
 
 	i915_probe_agp(dev->pdev, &agp_size, &prealloc_size);
 	printk("setting up %ld bytes of VRAM space\n", prealloc_size);
 	printk("setting up %ld bytes of TT space\n", (agp_size - prealloc_size));
-	drm_bo_init_mm(dev, DRM_BO_MEM_VRAM, 0, prealloc_size >> PAGE_SHIFT);
-	drm_bo_init_mm(dev, DRM_BO_MEM_TT, prealloc_size >> PAGE_SHIFT, (agp_size - prealloc_size) >> PAGE_SHIFT);
+	psb_drm_bo_init_mm(dev, DRM_BO_MEM_VRAM, 0, prealloc_size >> PAGE_SHIFT);
+	psb_drm_bo_init_mm(dev, DRM_BO_MEM_TT, prealloc_size >> PAGE_SHIFT, (agp_size - prealloc_size) >> PAGE_SHIFT);
 
 	I915_WRITE(LP_RING + RING_LEN, 0);
 	I915_WRITE(LP_RING + RING_HEAD, 0);
 	I915_WRITE(LP_RING + RING_TAIL, 0);
 
 	size = PRIMARY_RINGBUFFER_SIZE;
-	ret = drm_buffer_object_create(dev, size, drm_bo_type_kernel,
+	ret = psb_drm_buffer_object_create(dev, size, drm_bo_type_kernel,
 				       DRM_BO_FLAG_READ | DRM_BO_FLAG_WRITE |
 				       DRM_BO_FLAG_MEM_VRAM |
 				       DRM_BO_FLAG_NO_EVICT |
@@ -203,7 +203,7 @@
 	dev_priv->ring.tail_mask = dev_priv->ring.Size - 1;
 
 	/* FIXME: need wrapper with PCI mem checks */
-	ret = drm_mem_reg_ioremap(dev, &dev_priv->ring_buffer->mem,
+	ret = psb_drm_mem_reg_ioremap(dev, &dev_priv->ring_buffer->mem,
 				  (void **) &dev_priv->ring.virtual_start);
 	if (ret)
 		DRM_ERROR("error mapping ring buffer: %d\n", ret);
@@ -232,7 +232,7 @@
 	/* Program Hardware Status Page */
 	if (!IS_G33(dev)) {
 		dev_priv->status_page_dmah = 
-			drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE, 0xffffffff);
+			psb_drm_pci_alloc(dev, PAGE_SIZE, PAGE_SIZE, 0xffffffff);
 
 		if (!dev_priv->status_page_dmah) {
 			dev->dev_private = (void *)dev_priv;
@@ -250,7 +250,7 @@
 	DRM_DEBUG("Enabled hardware status page\n");
 
 	intel_modeset_init(dev);
-	drm_initial_config(dev, false);
+	psb_drm_initial_config(dev, false);
 
 	return 0;
 }
@@ -260,11 +260,11 @@
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
 	if (dev_priv->ring.virtual_start) {
-		drm_core_ioremapfree(&dev_priv->ring.map, dev);
+		psb_drm_core_ioremapfree(&dev_priv->ring.map, dev);
 	}
 
 	if (dev_priv->status_page_dmah) {
-		drm_pci_free(dev, dev_priv->status_page_dmah);
+		psb_drm_pci_free(dev, dev_priv->status_page_dmah);
 		dev_priv->status_page_dmah = NULL;
 		dev_priv->hw_status_page = NULL;
 		dev_priv->dma_status_page = 0;
@@ -274,7 +274,7 @@
 
 	if (dev_priv->status_gfx_addr) {
 		dev_priv->status_gfx_addr = 0;
-		drm_core_ioremapfree(&dev_priv->hws_map, dev);
+		psb_drm_core_ioremapfree(&dev_priv->hws_map, dev);
 		I915_WRITE(I915REG_HWS_PGA, 0x1ffff000);
 	}
 
@@ -282,30 +282,30 @@
 
 	intel_modeset_cleanup(dev);
 
-	drm_mem_reg_iounmap(dev, &dev_priv->ring_buffer->mem,
+	psb_drm_mem_reg_iounmap(dev, &dev_priv->ring_buffer->mem,
 			    dev_priv->ring.virtual_start);
 
 	DRM_DEBUG("usage is %d\n", atomic_read(&dev_priv->ring_buffer->usage));
 	mutex_lock(&dev->struct_mutex);
-	drm_bo_usage_deref_locked(&dev_priv->ring_buffer);
+	psb_drm_bo_usage_deref_locked(&dev_priv->ring_buffer);
 
-	if (drm_bo_clean_mm(dev, DRM_BO_MEM_TT)) {
+	if (psb_drm_bo_clean_mm(dev, DRM_BO_MEM_TT)) {
 		DRM_ERROR("Memory manager type 3 not clean. "
 			  "Delaying takedown\n");
 	}
-	if (drm_bo_clean_mm(dev, DRM_BO_MEM_VRAM)) {
+	if (psb_drm_bo_clean_mm(dev, DRM_BO_MEM_VRAM)) {
 		DRM_ERROR("Memory manager type 3 not clean. "
 			  "Delaying takedown\n");
 	}
 	mutex_unlock(&dev->struct_mutex);
 
-	drm_bo_driver_finish(dev);
+	psb_drm_bo_driver_finish(dev);
 
         DRM_DEBUG("%p, %p\n", dev_priv->mmio_map, dev_priv->sarea);
-        drm_rmmap(dev, dev_priv->mmio_map);
-        drm_rmmap(dev, dev_priv->sarea);
+        psb_drm_rmmap(dev, dev_priv->mmio_map);
+        psb_drm_rmmap(dev, dev_priv->sarea);
 
-	drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
+	psb_drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
 
 	dev->dev_private = NULL;
 	return 0;
diff -urNad psb-kernel-source-4.41.2/i915_ioc32.c psb-kernel-source-4.41.2.drm_psb/i915_ioc32.c
--- psb-kernel-source-4.41.2/i915_ioc32.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_ioc32.c	2010-05-02 10:13:43.123193070 +0200
@@ -66,7 +66,7 @@
 			  &batchbuffer->cliprects))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_I915_BATCHBUFFER,
 			 (unsigned long) batchbuffer);
 }
@@ -102,7 +102,7 @@
 			  &cmdbuffer->cliprects))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_I915_CMDBUFFER, (unsigned long) cmdbuffer);
 }
 
@@ -125,7 +125,7 @@
 			  &request->irq_seq))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_I915_IRQ_EMIT, (unsigned long) request);
 }
 typedef struct drm_i915_getparam32 {
@@ -149,7 +149,7 @@
 			  &request->value))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_I915_GETPARAM, (unsigned long) request);
 }
 
@@ -178,7 +178,7 @@
 			  &request->region_offset))
 		return -EFAULT;
 
-	return drm_ioctl(file->f_dentry->d_inode, file,
+	return psb_drm_ioctl(file->f_dentry->d_inode, file,
 			 DRM_IOCTL_I915_ALLOC, (unsigned long) request);
 }
 
@@ -207,7 +207,7 @@
 	int ret;
 
 	if (nr < DRM_COMMAND_BASE)
-		return drm_compat_ioctl(filp, cmd, arg);
+		return psb_drm_compat_ioctl(filp, cmd, arg);
 
 	if (nr < DRM_COMMAND_BASE + DRM_ARRAY_SIZE(i915_compat_ioctls))
 		fn = i915_compat_ioctls[nr - DRM_COMMAND_BASE];
@@ -216,7 +216,7 @@
 	if (fn != NULL)
 		ret = (*fn)(filp, cmd, arg);
 	else
-		ret = drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
+		ret = psb_drm_ioctl(filp->f_dentry->d_inode, filp, cmd, arg);
 	unlock_kernel();
 
 	return ret;
diff -urNad psb-kernel-source-4.41.2/i915_irq.c psb-kernel-source-4.41.2.drm_psb/i915_irq.c
--- psb-kernel-source-4.41.2/i915_irq.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_irq.c	2010-05-02 10:13:45.491191231 +0200
@@ -155,11 +155,11 @@
 		DRM_SPINUNLOCK(&dev_priv->swaps_lock);
 		DRM_SPINLOCK(&dev->drw_lock);
 
-		drw = drm_get_drawable_info(dev, vbl_swap->drw_id);
+		drw = psb_drm_get_drawable_info(dev, vbl_swap->drw_id);
 
 		if (!drw) {
 			DRM_SPINUNLOCK(&dev->drw_lock);
-			drm_free(vbl_swap, sizeof(*vbl_swap), DRM_MEM_DRIVER);
+			psb_drm_free(vbl_swap, sizeof(*vbl_swap), DRM_MEM_DRIVER);
 			DRM_SPINLOCK(&dev_priv->swaps_lock);
 			continue;
 		}
@@ -168,7 +168,7 @@
 			struct drm_i915_vbl_swap *swap_cmp =
 				list_entry(hit, struct drm_i915_vbl_swap, head);
 			struct drm_drawable_info *drw_cmp =
-				drm_get_drawable_info(dev, swap_cmp->drw_id);
+				psb_drm_get_drawable_info(dev, swap_cmp->drw_id);
 
 			if (drw_cmp &&
 			    drw_cmp->rects[0].y1 > drw->rects[0].y1) {
@@ -229,7 +229,7 @@
 			int num_rects, plane, front, back;
 			unsigned short top, bottom;
 
-			drw = drm_get_drawable_info(dev, swap_hit->drw_id);
+			drw = psb_drm_get_drawable_info(dev, swap_hit->drw_id);
 
 			if (!drw)
 				continue;
@@ -297,7 +297,7 @@
 
 		list_del(hit);
 
-		drm_free(swap_hit, sizeof(*swap_hit), DRM_MEM_DRIVER);
+		psb_drm_free(swap_hit, sizeof(*swap_hit), DRM_MEM_DRIVER);
 	}
 }
 
@@ -350,10 +350,10 @@
 			atomic_inc(&dev->vbl_received);
 
 		DRM_WAKEUP(&dev->vbl_queue);
-		drm_vbl_send_signals(dev);
+		psb_drm_vbl_send_signals(dev);
 
 		if (dev_priv->swaps_pending > 0)
-			drm_locked_tasklet(dev, i915_vblank_tasklet);
+			psb_drm_locked_tasklet(dev, i915_vblank_tasklet);
 		I915_WRITE(I915REG_PIPEASTAT,
 			pipea_stats|I915_VBLANK_INTERRUPT_ENABLE|
 			I915_VBLANK_CLEAR);
@@ -632,7 +632,7 @@
 	 * server is too old to push drawable information to the DRM, in which
 	 * case all such swaps would become ineffective.
 	 */
-	if (!drm_get_drawable_info(dev, swap->drawable)) {
+	if (!psb_drm_get_drawable_info(dev, swap->drawable)) {
 		DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock, irqflags);
 		DRM_DEBUG("Invalid drawable ID %d\n", swap->drawable);
 		return -EINVAL;
@@ -664,7 +664,7 @@
 
 			DRM_SPINLOCK_IRQSAVE(&dev->drw_lock, irqflags);
 
-			drw = drm_get_drawable_info(dev, swap->drawable);
+			drw = psb_drm_get_drawable_info(dev, swap->drawable);
 
 			if (!drw) {
 				DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock,
@@ -704,7 +704,7 @@
 		return -EBUSY;
 	}
 
-	vbl_swap = drm_calloc(1, sizeof(*vbl_swap), DRM_MEM_DRIVER);
+	vbl_swap = psb_drm_calloc(1, sizeof(*vbl_swap), DRM_MEM_DRIVER);
 
 	if (!vbl_swap) {
 		DRM_ERROR("Failed to allocate memory to queue swap\n");
diff -urNad psb-kernel-source-4.41.2/i915_mem.c psb-kernel-source-4.41.2.drm_psb/i915_mem.c
--- psb-kernel-source-4.41.2/i915_mem.c	2009-04-16 05:25:02.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/i915_mem.c	2010-05-02 10:13:41.955193493 +0200
@@ -94,7 +94,7 @@
 	/* Maybe cut off the start of an existing block */
 	if (start > p->start) {
 		struct mem_block *newblock =
-		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
+		    psb_drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
 		if (!newblock)
 			goto out;
 		newblock->start = start;
@@ -111,7 +111,7 @@
 	/* Maybe cut off the end of an existing block */
 	if (size < p->size) {
 		struct mem_block *newblock =
-		    drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
+		    psb_drm_alloc(sizeof(*newblock), DRM_MEM_BUFLISTS);
 		if (!newblock)
 			goto out;
 		newblock->start = start + size;
@@ -168,7 +168,7 @@
 		p->size += q->size;
 		p->next = q->next;
 		p->next->prev = p;
-		drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
+		psb_drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
 	}
 
 	if (p->prev->file_priv == NULL) {
@@ -176,7 +176,7 @@
 		q->size += p->size;
 		q->next = p->next;
 		q->next->prev = q;
-		drm_free(p, sizeof(*q), DRM_MEM_BUFLISTS);
+		psb_drm_free(p, sizeof(*q), DRM_MEM_BUFLISTS);
 	}
 }
 
@@ -184,14 +184,14 @@
  */
 static int init_heap(struct mem_block **heap, int start, int size)
 {
-	struct mem_block *blocks = drm_alloc(sizeof(*blocks), DRM_MEM_BUFLISTS);
+	struct mem_block *blocks = psb_drm_alloc(sizeof(*blocks), DRM_MEM_BUFLISTS);
 
 	if (!blocks)
 		return -ENOMEM;
 
-	*heap = drm_alloc(sizeof(**heap), DRM_MEM_BUFLISTS);
+	*heap = psb_drm_alloc(sizeof(**heap), DRM_MEM_BUFLISTS);
 	if (!*heap) {
-		drm_free(blocks, sizeof(*blocks), DRM_MEM_BUFLISTS);
+		psb_drm_free(blocks, sizeof(*blocks), DRM_MEM_BUFLISTS);
 		return -ENOMEM;
 	}
 
@@ -232,7 +232,7 @@
 			p->size += q->size;
 			p->next = q->next;
 			p->next->prev = p;
-			drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
+			psb_drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
 		}
 	}
 }
@@ -249,10 +249,10 @@
 	for (p = (*heap)->next; p != *heap;) {
 		struct mem_block *q = p;
 		p = p->next;
-		drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
+		psb_drm_free(q, sizeof(*q), DRM_MEM_BUFLISTS);
 	}
 
-	drm_free(*heap, sizeof(**heap), DRM_MEM_BUFLISTS);
+	psb_drm_free(*heap, sizeof(**heap), DRM_MEM_BUFLISTS);
 	*heap = NULL;
 }
 
diff -urNad psb-kernel-source-4.41.2/intel_crt.c psb-kernel-source-4.41.2.drm_psb/intel_crt.c
--- psb-kernel-source-4.41.2/intel_crt.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/intel_crt.c	2010-05-02 10:13:45.043192188 +0200
@@ -220,11 +220,11 @@
 	struct drm_output *output;
 	struct intel_output *intel_output;
 
-	output = drm_output_create(dev, &intel_crt_output_funcs, "VGA");
+	output = psb_drm_output_create(dev, &intel_crt_output_funcs, "VGA");
 
 	intel_output = kmalloc(sizeof(struct intel_output), GFP_KERNEL);
 	if (!intel_output) {
-		drm_output_destroy(output);
+		psb_drm_output_destroy(output);
 		return;
 	}
 	/* Set up the DDC bus. */
diff -urNad psb-kernel-source-4.41.2/intel_display.c psb-kernel-source-4.41.2.drm_psb/intel_display.c
--- psb-kernel-source-4.41.2/intel_display.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/intel_display.c	2010-05-02 10:13:42.491192907 +0200
@@ -1068,7 +1068,7 @@
 		I915_WRITE(PFIT_CONTROL, 0);
 
 	DRM_DEBUG("Mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');
-	drm_mode_debug_printmodeline(dev, mode);
+	psb_drm_mode_debug_printmodeline(dev, mode);
 
         /*psbPrintPll("chosen", &clock);*/
     DRM_DEBUG("clock regs: 0x%08x, 0x%08x,dspntr is 0x%8x, pipeconf is 0x%8x\n", (int)dpll,
@@ -1307,8 +1307,8 @@
 	mode->vsync_start = (vsync & 0xffff) + 1;
 	mode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;
 
-	drm_mode_set_name(mode);
-	drm_mode_set_crtcinfo(mode, 0);
+	psb_drm_mode_set_name(mode);
+	psb_drm_mode_set_crtcinfo(mode, 0);
 
 	return mode;
 }
@@ -1331,7 +1331,7 @@
 	struct intel_crtc *intel_crtc;
 	int i;
 
-	crtc = drm_crtc_create(dev, &intel_crtc_funcs);
+	crtc = psb_drm_crtc_create(dev, &intel_crtc_funcs);
 	if (crtc == NULL)
 		return;
 
@@ -1436,7 +1436,7 @@
 	int num_pipe;
 	int i;
 
-	drm_mode_config_init(dev);
+	psb_drm_mode_config_init(dev);
 
 	dev->mode_config.min_width = 0;
 	dev->mode_config.min_height = 0;
@@ -1463,10 +1463,10 @@
 
 	intel_setup_outputs(dev);
 
-	//drm_initial_config(dev, false);
+	//psb_drm_initial_config(dev, false);
 }
 
 void intel_modeset_cleanup(struct drm_device *dev)
 {
-	drm_mode_config_cleanup(dev);
+	psb_drm_mode_config_cleanup(dev);
 }
diff -urNad psb-kernel-source-4.41.2/intel_drv.h psb-kernel-source-4.41.2.drm_psb/intel_drv.h
--- psb-kernel-source-4.41.2/intel_drv.h	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/intel_drv.h	2010-05-02 10:13:45.307192140 +0200
@@ -76,8 +76,8 @@
 extern void intel_wait_for_vblank(struct drm_device *dev);
 extern struct drm_crtc *intel_get_crtc_from_pipe(struct drm_device *dev, int pipe);
 
-extern int intelfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
-extern int intelfb_remove(struct drm_device *dev, struct drm_crtc *crtc);
+extern int psb_intelfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
+extern int psb_intelfb_remove(struct drm_device *dev, struct drm_crtc *crtc);
 
 extern void intel_modeset_init(struct drm_device *dev);
 extern void intel_modeset_cleanup(struct drm_device *dev);
diff -urNad psb-kernel-source-4.41.2/intel_fb.c psb-kernel-source-4.41.2.drm_psb/intel_fb.c
--- psb-kernel-source-4.41.2/intel_fb.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/intel_fb.c	2010-05-02 10:13:42.575191438 +0200
@@ -249,7 +249,7 @@
         info->screen_size = info->fix.smem_len; /* ??? */
 
 	/* create a drm mode */
-        drm_mode = drm_mode_create(dev);
+        drm_mode = psb_drm_mode_create(dev);
         drm_mode->hdisplay = var->xres;
         drm_mode->hsync_start = drm_mode->hdisplay + var->right_margin;
         drm_mode->hsync_end = drm_mode->hsync_start + var->hsync_len;
@@ -259,21 +259,21 @@
         drm_mode->vsync_end = drm_mode->vsync_start + var->vsync_len;
         drm_mode->vtotal = drm_mode->vsync_end + var->upper_margin;
         drm_mode->clock = PICOS2KHZ(var->pixclock);
-        drm_mode->vrefresh = drm_mode_vrefresh(drm_mode);
-        drm_mode_set_name(drm_mode);
-	drm_mode_set_crtcinfo(drm_mode, CRTC_INTERLACE_HALVE_V);
+        drm_mode->vrefresh = psb_drm_mode_vrefresh(drm_mode);
+        psb_drm_mode_set_name(drm_mode);
+	psb_drm_mode_set_crtcinfo(drm_mode, CRTC_INTERLACE_HALVE_V);
 
         list_for_each_entry(output, &dev->mode_config.output_list, head) {
                 if (output->crtc == par->crtc)
                         break;
         }
 
-	drm_mode_debug_printmodeline(dev, drm_mode);    
+	psb_drm_mode_debug_printmodeline(dev, drm_mode);    
         list_for_each_entry(search_mode, &output->modes, head) {
 		DRM_ERROR("mode %s : %s\n", drm_mode->name, search_mode->name);
-		drm_mode_debug_printmodeline(dev, search_mode);
-		if (drm_mode_equal(drm_mode, search_mode)) {
-			drm_mode_destroy(dev, drm_mode);
+		psb_drm_mode_debug_printmodeline(dev, search_mode);
+		if (psb_drm_mode_equal(drm_mode, search_mode)) {
+			psb_drm_mode_destroy(dev, drm_mode);
 			drm_mode = search_mode;
 			found = 1;
 			break;
@@ -281,19 +281,19 @@
 	}
 	
 	if (!found) {
-		drm_mode_addmode(dev, drm_mode);
+		psb_drm_mode_addmode(dev, drm_mode);
 		if (par->fb_mode) {
-			drm_mode_detachmode_crtc(dev, par->fb_mode);
-			drm_mode_rmmode(dev, par->fb_mode);
+			psb_drm_mode_detachmode_crtc(dev, par->fb_mode);
+			psb_drm_mode_rmmode(dev, par->fb_mode);
 		}
 	
 		par->fb_mode = drm_mode;
-		drm_mode_debug_printmodeline(dev, drm_mode);
+		psb_drm_mode_debug_printmodeline(dev, drm_mode);
 		/* attach mode */
-		drm_mode_attachmode_crtc(dev, par->crtc, par->fb_mode);
+		psb_drm_mode_attachmode_crtc(dev, par->crtc, par->fb_mode);
 	}
 
-        if (!drm_crtc_set_mode(par->crtc, drm_mode, 0, 0))
+        if (!psb_drm_crtc_set_mode(par->crtc, drm_mode, 0, 0))
                 return -EINVAL;
 
 	return 0;
@@ -460,7 +460,7 @@
 	.fb_imageblit = cfb_imageblit, //intelfb_imageblit,
 };
 
-int intelfb_probe(struct drm_device *dev, struct drm_crtc *crtc)
+int psb_intelfb_probe(struct drm_device *dev, struct drm_crtc *crtc)
 {
 	struct fb_info *info;
 	struct intelfb_par *par;
@@ -475,7 +475,7 @@
 		return -EINVAL;
 	}
 
-	fb = drm_framebuffer_create(dev);
+	fb = psb_drm_framebuffer_create(dev);
 	if (!fb) {
 		framebuffer_release(info);
 		DRM_ERROR("failed to allocate fb.\n");
@@ -489,7 +489,7 @@
 	fb->bits_per_pixel = 32;
 	fb->pitch = fb->width * ((fb->bits_per_pixel + 1) / 8);
 	fb->depth = 24;
-	ret = drm_buffer_object_create(dev, fb->width * fb->height * 4, 
+	ret = psb_drm_buffer_object_create(dev, fb->width * fb->height * 4, 
 				       drm_bo_type_kernel,
 				       DRM_BO_FLAG_READ |
 				       DRM_BO_FLAG_WRITE |
@@ -500,7 +500,7 @@
 				       &fbo);
 	if (ret || !fbo) {
 		printk(KERN_ERR "failed to allocate framebuffer\n");
-		drm_framebuffer_destroy(fb);
+		psb_drm_framebuffer_destroy(fb);
 		framebuffer_release(info);
 		return -EINVAL;
 	}
@@ -537,7 +537,7 @@
 
 	info->flags = FBINFO_DEFAULT;
 
-	ret = drm_bo_kmap(fb->bo, 0, fb->bo->num_pages, &fb->kmap);
+	ret = psb_drm_bo_kmap(fb->bo, 0, fb->bo->num_pages, &fb->kmap);
 	if (ret)
 		DRM_ERROR("error mapping fb: %d\n", ret);
 
@@ -633,9 +633,9 @@
 	       info->fix.id);
 	return 0;
 }
-EXPORT_SYMBOL(intelfb_probe);
+EXPORT_SYMBOL(psb_intelfb_probe);
 
-int intelfb_remove(struct drm_device *dev, struct drm_crtc *crtc)
+int psb_intelfb_remove(struct drm_device *dev, struct drm_crtc *crtc)
 {
 	struct drm_framebuffer *fb = crtc->fb;
 	struct fb_info *info = fb->fbdev;
@@ -643,11 +643,11 @@
 	if (info) {
 		unregister_framebuffer(info);
                 framebuffer_release(info);
-                drm_bo_kunmap(&fb->kmap);
-                drm_bo_usage_deref_unlocked(&fb->bo);
-                drm_framebuffer_destroy(fb);
+                psb_drm_bo_kunmap(&fb->kmap);
+                psb_drm_bo_usage_deref_unlocked(&fb->bo);
+                psb_drm_framebuffer_destroy(fb);
         }
 	return 0;
 }
-EXPORT_SYMBOL(intelfb_remove);
+EXPORT_SYMBOL(psb_intelfb_remove);
 MODULE_LICENSE("GPL");
diff -urNad psb-kernel-source-4.41.2/intel_lvds.c psb-kernel-source-4.41.2.drm_psb/intel_lvds.c
--- psb-kernel-source-4.41.2/intel_lvds.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/intel_lvds.c	2010-05-02 10:13:45.379191238 +0200
@@ -351,7 +351,7 @@
 			dev_priv->panel_fixed_mode->vsync_end;
 		adjusted_mode->vtotal = dev_priv->panel_fixed_mode->vtotal;
 		adjusted_mode->clock = dev_priv->panel_fixed_mode->clock;
-		drm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);
+		psb_drm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);
 	}
 
 	/*
@@ -450,17 +450,17 @@
         struct edid *edid;
 
 	/* Try reading DDC from the adapter */
-        edid = (struct edid *)drm_ddc_read(&intel_output->ddc_bus->adapter);
+        edid = (struct edid *)psb_drm_ddc_read(&intel_output->ddc_bus->adapter);
 
         if (!edid) {
                 DRM_INFO("%s: no EDID data from device, reading ACPI _DDC data.\n",
                          output->name);
                 edid = kzalloc(sizeof(struct edid), GFP_KERNEL);
-                drm_get_acpi_edid(ACPI_EDID_LCD, (char*)edid, 128);
+                psb_drm_get_acpi_edid(ACPI_EDID_LCD, (char*)edid, 128);
         }
 
 	if (edid)
-	        drm_add_edid_modes(output, edid);
+	        psb_drm_add_edid_modes(output, edid);
 
 	/* Didn't get an EDID */
 	if (!output->monitor_info) {
@@ -482,8 +482,8 @@
 out:
 	if (dev_priv->panel_fixed_mode != NULL) {
 		struct drm_display_mode *mode =
-			drm_mode_duplicate(dev, dev_priv->panel_fixed_mode);
-		drm_mode_probed_add(output, mode);
+			psb_drm_mode_duplicate(dev, dev_priv->panel_fixed_mode);
+		psb_drm_mode_probed_add(output, mode);
 		return 1;
 	}
 
@@ -628,13 +628,13 @@
 	if (!drm_intel_ignore_acpi && !intel_get_acpi_dod(ACPI_DOD))
 		return;
 
-	output = drm_output_create(dev, &intel_lvds_output_funcs, "LVDS");
+	output = psb_drm_output_create(dev, &intel_lvds_output_funcs, "LVDS");
 	if (!output)
 		return;
 
 	intel_output = kmalloc(sizeof(struct intel_output), GFP_KERNEL);
 	if (!intel_output) {
-		drm_output_destroy(output);
+		psb_drm_output_destroy(output);
 		return;
 	}
 
@@ -839,7 +839,7 @@
 	list_for_each_entry(scan, &output->probed_modes, head) {
 		if (scan->type & DRM_MODE_TYPE_PREFERRED) {
 			dev_priv->panel_fixed_mode = 
-				drm_mode_duplicate(dev, scan);
+				psb_drm_mode_duplicate(dev, scan);
 			goto out; /* FIXME: check for quirks */
 		}
 	}
@@ -937,5 +937,5 @@
 
 failed:
         DRM_DEBUG("No LVDS modes found, disabling.\n");
-	drm_output_destroy(output); /* calls intel_lvds_destroy above */
+	psb_drm_output_destroy(output); /* calls intel_lvds_destroy above */
 }
diff -urNad psb-kernel-source-4.41.2/intel_modes.c psb-kernel-source-4.41.2.drm_psb/intel_modes.c
--- psb-kernel-source-4.41.2/intel_modes.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/intel_modes.c	2010-05-02 10:13:42.307195561 +0200
@@ -51,9 +51,9 @@
 	struct edid *edid;
 	int ret = 0;
 
-	edid = drm_get_edid(output, &intel_output->ddc_bus->adapter);
+	edid = psb_drm_get_edid(output, &intel_output->ddc_bus->adapter);
 	if (edid) {
-		ret = drm_add_edid_modes(output, edid);
+		ret = psb_drm_add_edid_modes(output, edid);
 		kfree(edid);
 	}
 	return ret;
diff -urNad psb-kernel-source-4.41.2/intel_sdvo.c psb-kernel-source-4.41.2.drm_psb/intel_sdvo.c
--- psb-kernel-source-4.41.2/intel_sdvo.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/intel_sdvo.c	2010-05-02 10:13:43.719191996 +0200
@@ -434,7 +434,7 @@
 	struct intel_sdvo_priv *sdvo_priv = intel_output->dev_priv;
 	int i;
 
-        if (drm_debug) {
+        if (psb_drm_debug) {
                 DRM_DEBUG("%s: W: %02X ", SDVO_NAME(sdvo_priv), cmd);
                 for (i = 0; i < args_len; i++)
                         printk("%02X ", ((u8 *)args)[i]);
@@ -487,7 +487,7 @@
 		/* read the return status */
 		intel_sdvo_read_byte(output, SDVO_I2C_CMD_STATUS, &status);
 
-	        if (drm_debug) {
+	        if (psb_drm_debug) {
 			DRM_DEBUG("%s: R: ", SDVO_NAME(sdvo_priv));
        			for (i = 0; i < response_len; i++)
                         	printk("%02X ", ((u8 *)response)[i]);
@@ -2923,7 +2923,7 @@
 
     print_Pll("chosen", &clock);
 	DRM_DEBUG("Mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');
-	drm_mode_debug_printmodeline(dev, mode);	
+	psb_drm_mode_debug_printmodeline(dev, mode);	
 	DRM_DEBUG("Modeline %d:\"%s\" %d %d %d %d %d %d %d %d\n",
 		  mode->mode_id, mode->name, mode->crtc_htotal, mode->crtc_hdisplay,
 		  mode->crtc_hblank_end, mode->crtc_hblank_start,
@@ -3025,7 +3025,7 @@
 	if (!i830_tv_mode_check_support(output, mode)) {
 	    DRM_DEBUG("mode setting failed, use the forced mode\n");
 	    mode = &tv_modes[0].mode_entry;
-		drm_mode_set_crtcinfo(mode, 0);
+		psb_drm_mode_set_crtcinfo(mode, 0);
 	}
     }	
     save_mode = mode;
@@ -3595,8 +3595,8 @@
 
 	if(output->name && (strcmp(output->name,deviceName) != 0)){
 	    DRM_DEBUG("change the output name to %s\n", deviceName);
-	    if (!drm_output_rename(output, deviceName)) {
-		drm_output_destroy(output);
+	    if (!psb_drm_output_rename(output, deviceName)) {
+		psb_drm_output_destroy(output);
 		return output_status_disconnected;
 	    }
 
@@ -3628,9 +3628,9 @@
 		((sdvo_priv->TVMode == TVMODE_SDTV) && /*sdtv mode list */
 		(tv_modes[i].dwSupportedSDTVvss & TVSTANDARD_SDTV_ALL))) {
 			struct drm_display_mode *newmode;
-			newmode = drm_mode_duplicate(dev, &tv_modes[i].mode_entry);		
-			drm_mode_set_crtcinfo(newmode,0);
-			drm_mode_probed_add(output, newmode);
+			newmode = psb_drm_mode_duplicate(dev, &tv_modes[i].mode_entry);		
+			psb_drm_mode_set_crtcinfo(newmode,0);
+			psb_drm_mode_probed_add(output, newmode);
 			modes++;
 		}
 
@@ -3763,13 +3763,13 @@
 		}
 	}
 
-	output = drm_output_create(dev, &intel_sdvo_output_funcs, NULL);
+	output = psb_drm_output_create(dev, &intel_sdvo_output_funcs, NULL);
 	if (!output)
 		return;
 
 	intel_output = kcalloc(sizeof(struct intel_output)+sizeof(struct intel_sdvo_priv), 1, GFP_KERNEL);
 	if (!intel_output) {
-		drm_output_destroy(output);
+		psb_drm_output_destroy(output);
 		return;
 	}
 
@@ -3786,7 +3786,7 @@
 		i2cbus = intel_i2c_create(dev, GPIOE, "SDVOCTRL_E for SDVOC");
 
 	if (i2cbus == NULL) {
-		drm_output_destroy(output);
+		psb_drm_output_destroy(output);
 		return;
 	}
 
@@ -3811,7 +3811,7 @@
 		if (!intel_sdvo_read_byte(output, i, &ch[i])) {
 			DRM_DEBUG("No SDVO device found on SDVO%c\n",
 				  output_device == SDVOB ? 'B' : 'C');
-			drm_output_destroy(output);
+			psb_drm_output_destroy(output);
 			return;
 		}
 	} 
@@ -3869,8 +3869,8 @@
 		sdvo_priv->ActiveDevice = SDVO_DEVICE_NONE;
 		strcpy(name, name_prefix);
 		strcat(name, name_suffix);
-		if (!drm_output_rename(output, name)) {
-			drm_output_destroy(output);
+		if (!psb_drm_output_rename(output, name)) {
+			psb_drm_output_destroy(output);
 			return;
         	}
 		return;
@@ -3992,8 +3992,8 @@
         
         strcpy(name, name_prefix);
         strcat(name, name_suffix);
-        if (!drm_output_rename(output, name)) {
-            drm_output_destroy(output);
+        if (!psb_drm_output_rename(output, name)) {
+            psb_drm_output_destroy(output);
             return;
         }
     } else {
@@ -4005,8 +4005,8 @@
         sdvo_priv->ActiveDevice = SDVO_DEVICE_NONE;
         strcpy(name, name_prefix);
         strcat(name, name_suffix);
-        if (!drm_output_rename(output, name)) {
-            drm_output_destroy(output);
+        if (!psb_drm_output_rename(output, name)) {
+            psb_drm_output_destroy(output);
             return;
         }
 
diff -urNad psb-kernel-source-4.41.2/psb_buffer.c psb-kernel-source-4.41.2.drm_psb/psb_buffer.c
--- psb-kernel-source-4.41.2/psb_buffer.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_buffer.c	2010-05-02 10:13:43.259193024 +0200
@@ -215,7 +215,7 @@
 			      new_mem->mm_node->start << PAGE_SHIFT,
 			      new_mem->num_pages, dir);
 
-	return drm_bo_move_accel_cleanup(bo, evict, no_wait, 0,
+	return psb_drm_bo_move_accel_cleanup(bo, evict, no_wait, 0,
 					 DRM_FENCE_TYPE_EXE, 0, new_mem);
 }
 
@@ -235,22 +235,22 @@
 	tmp_mem.mm_node = NULL;
 	tmp_mem.mask = DRM_BO_FLAG_MEM_TT;
 
-	ret = drm_bo_mem_space(bo, &tmp_mem, no_wait);
+	ret = psb_drm_bo_mem_space(bo, &tmp_mem, no_wait);
 	if (ret)
 		return ret;
-	ret = drm_bind_ttm(bo->ttm, &tmp_mem);
+	ret = psb_drm_bind_ttm(bo->ttm, &tmp_mem);
 	if (ret)
 		goto out_cleanup;
 	ret = psb_move_blit(bo, 1, no_wait, &tmp_mem);
 	if (ret)
 		goto out_cleanup;
 
-	ret = drm_bo_move_ttm(bo, evict, no_wait, new_mem);
+	ret = psb_drm_bo_move_ttm(bo, evict, no_wait, new_mem);
       out_cleanup:
 	if (tmp_mem.mm_node) {
 		mutex_lock(&dev->struct_mutex);
 		if (tmp_mem.mm_node != bo->pinned_node)
-			drm_mm_put_block(tmp_mem.mm_node);
+			psb_drm_mm_put_block(tmp_mem.mm_node);
 		tmp_mem.mm_node = NULL;
 		mutex_unlock(&dev->struct_mutex);
 	}
@@ -263,13 +263,13 @@
 	struct drm_bo_mem_reg *old_mem = &bo->mem;
 
 	if (old_mem->mem_type == DRM_BO_MEM_LOCAL) {
-		return drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
+		return psb_drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
 	} else if (new_mem->mem_type == DRM_BO_MEM_LOCAL) {
 		if (psb_move_flip(bo, evict, no_wait, new_mem))
-			return drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
+			return psb_drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
 	} else {
 		if (psb_move_blit(bo, evict, no_wait, new_mem))
-			return drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
+			return psb_drm_bo_move_memcpy(bo, evict, no_wait, new_mem);
 	}
 	return 0;
 }
@@ -387,7 +387,7 @@
 	    container_of(backend, struct drm_psb_ttm_backend, base);
 
 	if (backend)
-		drm_free(psb_be, sizeof(*psb_be), DRM_MEM_TTM);
+		psb_drm_free(psb_be, sizeof(*psb_be), DRM_MEM_TTM);
 }
 
 static struct drm_ttm_backend_func psb_ttm_backend = {
@@ -403,7 +403,7 @@
 {
 	struct drm_psb_ttm_backend *psb_be;
 
-	psb_be = drm_calloc(1, sizeof(*psb_be), DRM_MEM_TTM);
+	psb_be = psb_drm_calloc(1, sizeof(*psb_be), DRM_MEM_TTM);
 	if (!psb_be)
 		return NULL;
 	psb_be->pages = NULL;
diff -urNad psb-kernel-source-4.41.2/psb_drv.c psb-kernel-source-4.41.2.drm_psb/psb_drv.c
--- psb-kernel-source-4.41.2/psb_drv.c	2009-06-24 04:38:56.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_drv.c	2010-05-02 10:13:43.415192812 +0200
@@ -35,8 +35,8 @@
 #include <linux/notifier.h>
 #include <linux/fb.h>
 
-int drm_psb_debug = 0;
-EXPORT_SYMBOL(drm_psb_debug);
+int psb_drm_psb_debug = 0;
+EXPORT_SYMBOL(psb_drm_psb_debug);
 static int drm_psb_trap_pagefaults = 0;
 static int drm_psb_clock_gating = 0;
 static int drm_psb_ta_mem_size = 32 * 1024;
@@ -67,7 +67,7 @@
 MODULE_PARM_DESC(xres, "initial mode width");
 MODULE_PARM_DESC(yres, "initial mode height");
 
-module_param_named(debug, drm_psb_debug, int, 0600);
+module_param_named(debug, psb_drm_psb_debug, int, 0600);
 module_param_named(clock_gating, drm_psb_clock_gating, int, 0600);
 module_param_named(no_fb, drm_psb_no_fb, int, 0600);
 module_param_named(trap_pagefaults, drm_psb_trap_pagefaults, int, 0600);
@@ -169,23 +169,23 @@
 	mutex_lock(&dev->struct_mutex);
 	if (dev->bm.initialized) {
 		if (dev_priv->have_mem_rastgeom) {
-			drm_bo_clean_mm(dev, DRM_PSB_MEM_RASTGEOM);
+			psb_drm_bo_clean_mm(dev, DRM_PSB_MEM_RASTGEOM);
 			dev_priv->have_mem_rastgeom = 0;
 		}
 		if (dev_priv->have_mem_mmu) {
-			drm_bo_clean_mm(dev, DRM_PSB_MEM_MMU);
+			psb_drm_bo_clean_mm(dev, DRM_PSB_MEM_MMU);
 			dev_priv->have_mem_mmu = 0;
 		}
 		if (dev_priv->have_mem_aper) {
-			drm_bo_clean_mm(dev, DRM_PSB_MEM_APER);
+			psb_drm_bo_clean_mm(dev, DRM_PSB_MEM_APER);
 			dev_priv->have_mem_aper = 0;
 		}
 		if (dev_priv->have_tt) {
-			drm_bo_clean_mm(dev, DRM_BO_MEM_TT);
+			psb_drm_bo_clean_mm(dev, DRM_BO_MEM_TT);
 			dev_priv->have_tt = 0;
 		}
 		if (dev_priv->have_vram) {
-			drm_bo_clean_mm(dev, DRM_BO_MEM_VRAM);
+			psb_drm_bo_clean_mm(dev, DRM_BO_MEM_VRAM);
 			dev_priv->have_vram = 0;
 		}
 	}
@@ -263,7 +263,7 @@
 
 	int ret = -ENOMEM;
 
-	DRM_ERROR("Debug is 0x%08x\n", drm_psb_debug);
+	DRM_ERROR("Debug is 0x%08x\n", psb_drm_psb_debug);
 
 	dev_priv->ta_mem_pages =
 	    PSB_ALIGN_TO(drm_psb_ta_mem_size * 1024, PAGE_SIZE) >> PAGE_SHIFT;
@@ -322,7 +322,7 @@
 	if (ret)
 		goto out_err;
 
-	if (1 || drm_debug) {
+	if (1 || psb_drm_debug) {
 		uint32_t core_id = PSB_RSGX32(PSB_CR_CORE_ID);
 		uint32_t core_rev = PSB_RSGX32(PSB_CR_CORE_REVISION);
 		DRM_INFO("SGX core id = 0x%08x\n", core_id);
@@ -349,30 +349,30 @@
 
 	mutex_lock(&dev->struct_mutex);
 
-	if (!drm_bo_init_mm(dev, DRM_BO_MEM_VRAM, 0,
+	if (!psb_drm_bo_init_mm(dev, DRM_BO_MEM_VRAM, 0,
 			    pg->stolen_size >> PAGE_SHIFT)) {
 		dev_priv->have_vram = 1;
 	}
 
-	if (!drm_bo_init_mm(dev, DRM_BO_MEM_TT, tt_start >> PAGE_SHIFT,
+	if (!psb_drm_bo_init_mm(dev, DRM_BO_MEM_TT, tt_start >> PAGE_SHIFT,
 			    tt_pages)) {
 		dev_priv->have_tt = 1;
 	}
 
-	if (!drm_bo_init_mm(dev, DRM_PSB_MEM_MMU, 0x00000000,
+	if (!psb_drm_bo_init_mm(dev, DRM_PSB_MEM_MMU, 0x00000000,
 			    (pg->gatt_start -
 			     PSB_MEM_MMU_START) >> PAGE_SHIFT)) {
 		dev_priv->have_mem_mmu = 1;
 	}
 
-	if (!drm_bo_init_mm(dev, DRM_PSB_MEM_RASTGEOM, 0x00000000,
+	if (!psb_drm_bo_init_mm(dev, DRM_PSB_MEM_RASTGEOM, 0x00000000,
 			    (PSB_MEM_MMU_START -
 			     PSB_MEM_RASTGEOM_START) >> PAGE_SHIFT)) {
 		dev_priv->have_mem_rastgeom = 1;
 	}
 #if 0
 	if (pg->gatt_pages > PSB_TT_PRIV0_PLIMIT) {
-		if (!drm_bo_init_mm(dev, DRM_PSB_MEM_APER, PSB_TT_PRIV0_PLIMIT,
+		if (!psb_drm_bo_init_mm(dev, DRM_PSB_MEM_APER, PSB_TT_PRIV0_PLIMIT,
 				    pg->gatt_pages - PSB_TT_PRIV0_PLIMIT)) {
 			dev_priv->have_mem_aper = 1;
 		}
@@ -408,16 +408,16 @@
 
 		mutex_lock(&dev->struct_mutex);
 		if (dev_priv->have_mem_pds) {
-			drm_bo_clean_mm(dev, DRM_PSB_MEM_PDS);
+			psb_drm_bo_clean_mm(dev, DRM_PSB_MEM_PDS);
 			dev_priv->have_mem_pds = 0;
 		}
 		if (dev_priv->have_mem_kernel) {
-			drm_bo_clean_mm(dev, DRM_PSB_MEM_KERNEL);
+			psb_drm_bo_clean_mm(dev, DRM_PSB_MEM_KERNEL);
 			dev_priv->have_mem_kernel = 0;
 		}
 		mutex_unlock(&dev->struct_mutex);
 
-		(void)drm_bo_driver_finish(dev);
+		(void)psb_drm_bo_driver_finish(dev);
 
 		if (dev_priv->pf_pd) {
 			psb_mmu_free_pagedir(dev_priv->pf_pd);
@@ -455,17 +455,17 @@
 			dev_priv->msvdx_reg = NULL;
 		}
 
-		drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
+		psb_drm_free(dev_priv, sizeof(*dev_priv), DRM_MEM_DRIVER);
 		dev->dev_private = NULL;
 	}
 	return 0;
 }
 
-extern int drm_crtc_probe_output_modes(struct drm_device *dev, int, int);
-extern int drm_pick_crtcs(struct drm_device *dev);
-extern char drm_init_mode[32];
-extern int drm_init_xres;
-extern int drm_init_yres;
+extern int psb_drm_crtc_probe_output_modes(struct drm_device *dev, int, int);
+extern int psb_drm_pick_crtcs(struct drm_device *dev);
+extern char psb_drm_init_mode[32];
+extern int psb_drm_init_xres;
+extern int psb_drm_init_yres;
 
 static int psb_initial_config(struct drm_device *dev, bool can_grow)
 {
@@ -476,14 +476,14 @@
 
 	mutex_lock(&dev->mode_config.mutex);
 
-	drm_crtc_probe_output_modes(dev, 2048, 2048);
+	psb_drm_crtc_probe_output_modes(dev, 2048, 2048);
 	
-	/* strncpy(drm_init_mode, psb_init_mode, strlen(psb_init_mode)); */
-	drm_init_xres = psb_init_xres;
-	drm_init_yres = psb_init_yres;
+	/* strncpy(psb_drm_init_mode, psb_init_mode, strlen(psb_init_mode)); */
+	psb_drm_init_xres = psb_init_xres;
+	psb_drm_init_yres = psb_init_yres;
 	printk(KERN_ERR "detear is %sabled\n", drm_psb_detear ? "en" : "dis" );
 
-	drm_pick_crtcs(dev);
+	psb_drm_pick_crtcs(dev);
 
 	if ((I915_READ(PIPEACONF) & PIPEACONF_ENABLE) && !drm_psb_force_pipeb)
 		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
@@ -506,15 +506,15 @@
 			continue;
 
 		if (output->crtc->fb)
-			drm_crtc_set_mode(output->crtc,
+			psb_drm_crtc_set_mode(output->crtc,
 					  output->crtc->desired_mode, 0, 0);
 	}
 
 #ifdef SII_1392_WA
 	if((SII_1392 != 1) || (drm_psb_no_fb==0))
-		drm_disable_unused_functions(dev);
+		psb_drm_disable_unused_functions(dev);
 #else
-	drm_disable_unused_functions(dev);
+	psb_drm_disable_unused_functions(dev);
 #endif
 
 	mutex_unlock(&dev->mode_config.mutex);
@@ -531,7 +531,7 @@
 	int ret = -ENOMEM;
 
 	DRM_INFO("psb - %s\n", PSB_PACKAGE_VERSION);
-	dev_priv = drm_calloc(1, sizeof(*dev_priv), DRM_MEM_DRIVER);
+	dev_priv = psb_drm_calloc(1, sizeof(*dev_priv), DRM_MEM_DRIVER);
 	if (dev_priv == NULL)
 		return -ENOMEM;
 
@@ -644,18 +644,18 @@
 
 	psb_init_2d(dev_priv);
 
-	ret = drm_bo_driver_init(dev);
+	ret = psb_drm_bo_driver_init(dev);
 	if (ret)
 		goto out_err;
 
-	ret = drm_bo_init_mm(dev, DRM_PSB_MEM_KERNEL, 0x00000000,
+	ret = psb_drm_bo_init_mm(dev, DRM_PSB_MEM_KERNEL, 0x00000000,
 			     (PSB_MEM_PDS_START - PSB_MEM_KERNEL_START)
 			     >> PAGE_SHIFT);
 	if (ret)
 		goto out_err;
 	dev_priv->have_mem_kernel = 1;
 
-	ret = drm_bo_init_mm(dev, DRM_PSB_MEM_PDS, 0x00000000,
+	ret = psb_drm_bo_init_mm(dev, DRM_PSB_MEM_PDS, 0x00000000,
 			     (PSB_MEM_RASTGEOM_START - PSB_MEM_PDS_START)
 			     >> PAGE_SHIFT);
 	if (ret)
@@ -716,7 +716,7 @@
 		do {
 			DRM_WAIT_ON(ret, fc->fence_queue, 3 * DRM_HZ,
 				    (signaled =
-				     drm_fence_object_signaled(fence,
+				     psb_drm_fence_object_signaled(fence,
 							       DRM_FENCE_TYPE_EXE)));
 			if (signaled)
 				break;
@@ -841,7 +841,7 @@
 	if (drm_psb_no_fb == 0) {
             list_for_each_entry(output, &dev->mode_config.output_list, head) {
                 if(output->crtc != NULL)
-                    drm_crtc_set_mode(output->crtc, &output->crtc->mode,
+                    psb_drm_crtc_set_mode(output->crtc, &output->crtc->mode,
                               output->crtc->x, output->crtc->y);
             }
         }
@@ -913,7 +913,7 @@
 	if (dev_priv && dev_priv->xhw_file) {
 		psb_xhw_init_takedown(dev_priv, file_priv, 1);
 	}
-	return drm_release(inode, filp);
+	return psb_drm_release(inode, filp);
 }
 
 extern struct drm_fence_driver psb_fence_driver;
@@ -965,7 +965,7 @@
 	.load = psb_driver_load,
 	.unload = psb_driver_unload,
 	.dri_library_name = dri_library_name,
-	.get_reg_ofs = drm_core_get_reg_ofs,
+	.get_reg_ofs = psb_drm_core_get_reg_ofs,
 	.ioctls = psb_ioctls,
 	.device_is_agp = psb_driver_device_is_agp,
 	.vblank_wait = psb_vblank_wait2,
@@ -974,24 +974,24 @@
 	.irq_postinstall = psb_irq_postinstall,
 	.irq_uninstall = psb_irq_uninstall,
 	.irq_handler = psb_irq_handler,
-	.fb_probe = psbfb_probe,
-	.fb_remove = psbfb_remove,
+	.fb_probe = psb_psbfb_probe,
+	.fb_remove = psb_psbfb_remove,
 	.firstopen = NULL,
 	.lastclose = psb_lastclose,
 	.fops = {
 		 .owner = THIS_MODULE,
-		 .open = drm_open,
+		 .open = psb_drm_open,
 		 .release = psb_release,
-		 .ioctl = drm_ioctl,
-		 .mmap = drm_mmap,
+		 .ioctl = psb_drm_ioctl,
+		 .mmap = psb_drm_mmap,
 		 .poll = psb_poll,
-		 .fasync = drm_fasync,
+		 .fasync = psb_drm_fasync,
 		 },
 	.pci_driver = {
 		       .name = DRIVER_NAME,
 		       .id_table = pciidlist,
 		       .probe = probe,
-		       .remove = __devexit_p(drm_cleanup_pci),
+		       .remove = __devexit_p(psb_drm_cleanup_pci),
 		       .resume = psb_resume,
 		       .suspend = psb_suspend,
 		       },
@@ -1007,19 +1007,19 @@
 
 static int probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	return drm_get_dev(pdev, ent, &driver);
+	return psb_drm_get_dev(pdev, ent, &driver);
 }
 
 static int __init psb_init(void)
 {
 	driver.num_ioctls = psb_max_ioctl;
 
-	return drm_init(&driver, pciidlist);
+	return psb_drm_init(&driver, pciidlist);
 }
 
 static void __exit psb_exit(void)
 {
-	drm_exit(&driver);
+	psb_drm_exit(&driver);
 }
 
 module_init(psb_init);
diff -urNad psb-kernel-source-4.41.2/psb_drv.h psb-kernel-source-4.41.2.drm_psb/psb_drv.h
--- psb-kernel-source-4.41.2/psb_drv.h	2009-06-24 09:10:56.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_drv.h	2010-05-02 10:13:43.783192582 +0200
@@ -632,8 +632,8 @@
 /*
  * psb_fb.c
  */
-extern int psbfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
-extern int psbfb_remove(struct drm_device *dev, struct drm_crtc *crtc);
+extern int psb_psbfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
+extern int psb_psbfb_remove(struct drm_device *dev, struct drm_crtc *crtc);
 extern int psbfb_kms_off_ioctl(struct drm_device *dev, void *data,
 			       struct drm_file *file_priv);
 extern int psbfb_kms_on_ioctl(struct drm_device *dev, void *data,
@@ -782,7 +782,7 @@
 #define PSB_D_TMP    (1 << 5)
 #define PSB_D_RELOC   (1 << 6)
 
-extern int drm_psb_debug;
+extern int psb_drm_psb_debug;
 extern int drm_psb_no_fb;
 extern int drm_psb_disable_vsync;
 extern int drm_psb_detear;
@@ -807,7 +807,7 @@
 #if DRM_DEBUG_CODE
 #define PSB_DEBUG(_flag, _fmt, _arg...)					\
 	do {								\
-	  if (unlikely((_flag) & drm_psb_debug))			\
+	  if (unlikely((_flag) & psb_drm_psb_debug))			\
 			printk(KERN_DEBUG				\
 			       "[psb:0x%02x:%s] " _fmt , _flag,	\
 			       __FUNCTION__ , ##_arg);			\
diff -urNad psb-kernel-source-4.41.2/psb_fb.c psb-kernel-source-4.41.2.drm_psb/psb_fb.c
--- psb-kernel-source-4.41.2/psb_fb.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_fb.c	2010-05-02 10:13:42.075194019 +0200
@@ -63,8 +63,8 @@
 	struct psbfb_vm_info *tmp = *vi;
 	*vi = NULL;
 	if (atomic_dec_and_test(&tmp->refcount)) {
-		drm_bo_usage_deref_unlocked(&tmp->bo);
-		drm_free(tmp, sizeof(*tmp), DRM_MEM_MAPS);
+		psb_drm_bo_usage_deref_unlocked(&tmp->bo);
+		psb_drm_free(tmp, sizeof(*tmp), DRM_MEM_MAPS);
 	}
 }
 
@@ -78,7 +78,7 @@
 {
 	struct psbfb_vm_info *vi;
 
-	vi = drm_calloc(1, sizeof(*vi), DRM_MEM_MAPS);
+	vi = psb_drm_calloc(1, sizeof(*vi), DRM_MEM_MAPS);
 	if (!vi)
 		return NULL;
 
@@ -188,7 +188,7 @@
 		/* a temporary BO to check if we could resize in setpar.
 		 * Therefore no need to set NO_EVICT.
 		 */
-		ret = drm_buffer_object_create(dev,
+		ret = psb_drm_buffer_object_create(dev,
 					       pitch * var->yres,
 					       drm_bo_type_kernel,
 					       DRM_BO_FLAG_READ |
@@ -200,15 +200,15 @@
 		if (ret || !fbo)
 			return -ENOMEM;
 
-		ret = drm_bo_kmap(fbo, 0, fbo->num_pages, &tmp_kmap);
+		ret = psb_drm_bo_kmap(fbo, 0, fbo->num_pages, &tmp_kmap);
 		if (ret) {
-			drm_bo_usage_deref_unlocked(&fbo);
+			psb_drm_bo_usage_deref_unlocked(&fbo);
 			return -EINVAL;
 		}
 
-		drm_bo_kunmap(&tmp_kmap);
+		psb_drm_bo_kunmap(&tmp_kmap);
 		/* destroy our current fbo! */
-		drm_bo_usage_deref_unlocked(&fbo);
+		psb_drm_bo_usage_deref_unlocked(&fbo);
 #endif
 	}
 
@@ -314,7 +314,7 @@
 		unmap_mapping_range(par->vi->f_mapping, 0, holelen, 1);
 	}
 
-	ret = drm_bo_do_validate(bo,
+	ret = psb_drm_bo_do_validate(bo,
 				 mem_type_flags,
 				 DRM_BO_MASK_MEM |
 				 DRM_BO_FLAG_NO_EVICT,
@@ -373,7 +373,7 @@
 		struct drm_buffer_object *fbo = NULL, *tfbo;
 		struct drm_bo_kmap_obj tmp_kmap, tkmap;
 
-		ret = drm_buffer_object_create(dev,
+		ret = psb_drm_buffer_object_create(dev,
 					       pitch * var->yres,
 					       drm_bo_type_kernel,
 					       DRM_BO_FLAG_READ |
@@ -389,10 +389,10 @@
 			return -ENOMEM;
 		}
 
-		ret = drm_bo_kmap(fbo, 0, fbo->num_pages, &tmp_kmap);
+		ret = psb_drm_bo_kmap(fbo, 0, fbo->num_pages, &tmp_kmap);
 		if (ret) {
 			DRM_ERROR("failed to kmap framebuffer.\n");
-			drm_bo_usage_deref_unlocked(&fbo);
+			psb_drm_bo_usage_deref_unlocked(&fbo);
 			return -EINVAL;
 		}
 
@@ -404,11 +404,11 @@
 
 		tkmap = fb->kmap;
 		fb->kmap = tmp_kmap;
-		drm_bo_kunmap(&tkmap);
+		psb_drm_bo_kunmap(&tkmap);
 
 		tfbo = fb->bo;
 		fb->bo = fbo;
-		drm_bo_usage_deref_unlocked(&tfbo);
+		psb_drm_bo_usage_deref_unlocked(&tfbo);
 #endif
 	}
 
@@ -427,7 +427,7 @@
 	info->fix.smem_start = dev->mode_config.fb_base + fb->offset;
 
 	/* we have to align the output base address because the fb->bo
-	   may be moved in the previous drm_bo_do_validate().
+	   may be moved in the previous psb_drm_bo_do_validate().
 	   Otherwise the output screens may go black when exit the X
 	   window and re-enter the console */
 	info->screen_base = fb->kmap.virtual;
@@ -457,7 +457,7 @@
 #else
 	(void)output;		/* silence warning */
 
-	drm_mode = drm_mode_create(dev);
+	drm_mode = psb_drm_mode_create(dev);
 	drm_mode->hdisplay = var->xres;
 	drm_mode->hsync_start = drm_mode->hdisplay + var->right_margin;
 	drm_mode->hsync_end = drm_mode->hsync_start + var->hsync_len;
@@ -467,19 +467,19 @@
 	drm_mode->vsync_end = drm_mode->vsync_start + var->vsync_len;
 	drm_mode->vtotal = drm_mode->vsync_end + var->upper_margin;
 	drm_mode->clock = PICOS2KHZ(var->pixclock);
-	drm_mode->vrefresh = drm_mode_vrefresh(drm_mode);
-	drm_mode_set_name(drm_mode);
-	drm_mode_set_crtcinfo(drm_mode, CRTC_INTERLACE_HALVE_V);
+	drm_mode->vrefresh = psb_drm_mode_vrefresh(drm_mode);
+	psb_drm_mode_set_name(drm_mode);
+	psb_drm_mode_set_crtcinfo(drm_mode, CRTC_INTERLACE_HALVE_V);
 #endif
 
-	if (!drm_crtc_set_mode(par->crtc, drm_mode, 0, 0))
+	if (!psb_drm_crtc_set_mode(par->crtc, drm_mode, 0, 0))
 		return -EINVAL;
 
 	/* Have to destroy our created mode if we're not searching the mode
 	 * list for it.
 	 */
 #if 1
-	drm_mode_destroy(dev, drm_mode);
+	psb_drm_mode_destroy(dev, drm_mode);
 #endif
 
 	return 0;
@@ -837,7 +837,7 @@
 		if (!bo)
 			continue;
 
-		drm_bo_kunmap(&fb->kmap);
+		psb_drm_bo_kunmap(&fb->kmap);
 
 		/*
 		 * We don't take the 2D lock here as we assume that the
@@ -917,7 +917,7 @@
 		if (ret)
 			goto out_err;
 
-		ret = drm_bo_kmap(bo, 0, bo->num_pages, &fb->kmap);
+		ret = psb_drm_bo_kmap(bo, 0, bo->num_pages, &fb->kmap);
 		if (ret)
 			goto out_err;
 
@@ -958,9 +958,9 @@
 	release_console_sem();
 #ifdef SII_1392_WA
 	if((SII_1392 != 1) || (drm_psb_no_fb==0))
-		drm_disable_unused_functions(dev);
+		psb_drm_disable_unused_functions(dev);
 #else
-	drm_disable_unused_functions(dev);
+	psb_drm_disable_unused_functions(dev);
 #endif
 	return ret;
 }
@@ -979,9 +979,9 @@
 	release_console_sem();
 #ifdef SII_1392_WA
 	if((SII_1392 != 1) || (drm_psb_no_fb==0))
-		drm_disable_unused_functions(dev);
+		psb_drm_disable_unused_functions(dev);
 #else
-	drm_disable_unused_functions(dev);
+	psb_drm_disable_unused_functions(dev);
 #endif
 }
 
@@ -990,14 +990,14 @@
  * Also, these should be the default vm ops for buffer object type fbs.
  */
 
-extern unsigned long drm_bo_vm_nopfn(struct vm_area_struct *vma,
+extern unsigned long psb_drm_bo_vm_nopfn(struct vm_area_struct *vma,
 				     unsigned long address);
 
 /*
  * This wrapper is a bit ugly and is here because we need access to a mutex
  * that we can lock both around nopfn and around unmap_mapping_range + move.
  * Normally, this would've been done using the bo mutex, but unfortunately
- * we cannot lock it around drm_bo_do_validate(), since that would imply
+ * we cannot lock it around psb_drm_bo_do_validate(), since that would imply
  * recursive locking.
  */
 
@@ -1011,7 +1011,7 @@
 	mutex_lock(&vi->vm_mutex);
 	tmp_vma = *vma;
 	tmp_vma.vm_private_data = vi->bo;
-	ret = drm_bo_vm_nopfn(&tmp_vma, address);
+	ret = psb_drm_bo_vm_nopfn(&tmp_vma, address);
 	mutex_unlock(&vi->vm_mutex);
 	return ret;
 }
@@ -1028,7 +1028,7 @@
 	mutex_lock(&vi->vm_mutex);
 	tmp_vma = *vma;
 	tmp_vma.vm_private_data = vi->bo;
-	ret = drm_bo_vm_nopfn(&tmp_vma, address);
+	ret = psb_drm_bo_vm_nopfn(&tmp_vma, address);
 	mutex_unlock(&vi->vm_mutex);
 	return ret;
 }
@@ -1108,7 +1108,7 @@
 	.fb_blank = psbfb_blank,
 };
 
-int psbfb_probe(struct drm_device *dev, struct drm_crtc *crtc)
+int psb_psbfb_probe(struct drm_device *dev, struct drm_crtc *crtc)
 {
 	struct fb_info *info;
 	struct psbfb_par *par;
@@ -1132,7 +1132,7 @@
 		return -ENOMEM;
 	}
 
-	fb = drm_framebuffer_create(dev);
+	fb = psb_drm_framebuffer_create(dev);
 	if (!fb) {
 		framebuffer_release(info);
 		DRM_ERROR("failed to allocate fb.\n");
@@ -1148,7 +1148,7 @@
 	fb->pitch =
 	    ((fb->width * ((fb->bits_per_pixel + 1) / 8)) + 0x3f) & ~0x3f;
 
-	ret = drm_buffer_object_create(dev,
+	ret = psb_drm_buffer_object_create(dev,
 				       fb->pitch * fb->height,
 				       drm_bo_type_kernel,
 				       DRM_BO_FLAG_READ |
@@ -1203,7 +1203,7 @@
 	info->flags = FBINFO_DEFAULT |
 	    FBINFO_PARTIAL_PAN_OK /*| FBINFO_MISC_ALWAYS_SETPAR */ ;
 
-	ret = drm_bo_kmap(fb->bo, 0, fb->bo->num_pages, &fb->kmap);
+	ret = psb_drm_bo_kmap(fb->bo, 0, fb->bo->num_pages, &fb->kmap);
 	if (ret) {
 		DRM_ERROR("error mapping fb: %d\n", ret);
 		goto out_err2;
@@ -1309,21 +1309,21 @@
       out_err4:
 	unregister_framebuffer(info);
       out_err3:
-	drm_bo_kunmap(&fb->kmap);
+	psb_drm_bo_kunmap(&fb->kmap);
       out_err2:
 	psbfb_vm_info_deref(&par->vi);
       out_err1:
-	drm_bo_usage_deref_unlocked(&fb->bo);
+	psb_drm_bo_usage_deref_unlocked(&fb->bo);
       out_err0:
-	drm_framebuffer_destroy(fb);
+	psb_drm_framebuffer_destroy(fb);
 	framebuffer_release(info);
 	crtc->fb = NULL;
 	return -EINVAL;
 }
 
-EXPORT_SYMBOL(psbfb_probe);
+EXPORT_SYMBOL(psb_psbfb_probe);
 
-int psbfb_remove(struct drm_device *dev, struct drm_crtc *crtc)
+int psb_psbfb_remove(struct drm_device *dev, struct drm_crtc *crtc)
 {
 	struct drm_framebuffer *fb;
 	struct fb_info *info;
@@ -1337,15 +1337,15 @@
 
 	if (info) {
 		unregister_framebuffer(info);
-		drm_bo_kunmap(&fb->kmap);
+		psb_drm_bo_kunmap(&fb->kmap);
 		par = info->par;
 		if (par)
 			psbfb_vm_info_deref(&par->vi);
-		drm_bo_usage_deref_unlocked(&fb->bo);
-		drm_framebuffer_destroy(fb);
+		psb_drm_bo_usage_deref_unlocked(&fb->bo);
+		psb_drm_framebuffer_destroy(fb);
 		framebuffer_release(info);
 	}
 	return 0;
 }
 
-EXPORT_SYMBOL(psbfb_remove);
+EXPORT_SYMBOL(psb_psbfb_remove);
diff -urNad psb-kernel-source-4.41.2/psb_fence.c psb-kernel-source-4.41.2.drm_psb/psb_fence.c
--- psb-kernel-source-4.41.2/psb_fence.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_fence.c	2010-05-02 10:13:42.655191968 +0200
@@ -56,7 +56,7 @@
 		if (flags == 0)
 			sequence = seq->sequence;
 		else if (sequence != seq->sequence) {
-			drm_fence_handler(dev, PSB_ENGINE_TA,
+			psb_drm_fence_handler(dev, PSB_ENGINE_TA,
 					  sequence, flags, 0);
 			sequence = seq->sequence;
 			flags = 0;
@@ -81,7 +81,7 @@
 	}
 
 	if (flags) {
-		drm_fence_handler(dev, PSB_ENGINE_TA, sequence, flags, 0);
+		psb_drm_fence_handler(dev, PSB_ENGINE_TA, sequence, flags, 0);
 	}
 }
 
@@ -103,7 +103,7 @@
 		else
 			sequence = dev_priv->comm[fence_class << 4];
 
-		drm_fence_handler(dev, fence_class, sequence,
+		psb_drm_fence_handler(dev, fence_class, sequence,
 				  DRM_FENCE_TYPE_EXE, 0);
 
 		switch (fence_class) {
@@ -161,7 +161,7 @@
 
 	BUG_ON(fence_class >= PSB_NUM_ENGINES);
 	write_lock_irqsave(&fm->lock, irq_flags);
-	drm_fence_handler(dev, fence_class, sequence, type, error);
+	psb_drm_fence_handler(dev, fence_class, sequence, type, error);
 	write_unlock_irqrestore(&fm->lock, irq_flags);
 }
 
@@ -252,14 +252,14 @@
 	unsigned long timeout = DRM_HZ *
 	    ((fence->fence_class == PSB_ENGINE_TA) ? 30 : 3);
 
-	drm_fence_object_flush(fence, mask);
+	psb_drm_fence_object_flush(fence, mask);
 	if (interruptible)
 		ret = wait_event_interruptible_timeout
-		    (fc->fence_queue, drm_fence_object_signaled(fence, mask),
+		    (fc->fence_queue, psb_drm_fence_object_signaled(fence, mask),
 		     timeout);
 	else
 		ret = wait_event_timeout
-		    (fc->fence_queue, drm_fence_object_signaled(fence, mask),
+		    (fc->fence_queue, psb_drm_fence_object_signaled(fence, mask),
 		     timeout);
 
 	if (unlikely(ret == -ERESTARTSYS))
diff -urNad psb-kernel-source-4.41.2/psb_gtt.c psb-kernel-source-4.41.2.drm_psb/psb_gtt.c
--- psb-kernel-source-4.41.2/psb_gtt.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_gtt.c	2010-05-02 10:13:42.507191590 +0200
@@ -41,7 +41,7 @@
 
 struct psb_gtt *psb_gtt_alloc(struct drm_device *dev)
 {
-	struct psb_gtt *tmp = drm_calloc(1, sizeof(*tmp), DRM_MEM_DRIVER);
+	struct psb_gtt *tmp = psb_drm_calloc(1, sizeof(*tmp), DRM_MEM_DRIVER);
 
 	if (!tmp)
 		return NULL;
@@ -70,7 +70,7 @@
 		(void)PSB_RVDC32(PSB_PGETBL_CTL);
 	}
 	if (free)
-		drm_free(pg, sizeof(*pg), DRM_MEM_DRIVER);
+		psb_drm_free(pg, sizeof(*pg), DRM_MEM_DRIVER);
 }
 
 int psb_gtt_init(struct psb_gtt *pg, int resume)
diff -urNad psb-kernel-source-4.41.2/psb_irq.c psb-kernel-source-4.41.2.drm_psb/psb_irq.c
--- psb-kernel-source-4.41.2/psb_irq.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_irq.c	2010-05-02 10:13:44.191191373 +0200
@@ -97,7 +97,7 @@
 
 	if (wake) {
 		DRM_WAKEUP(&dev->vbl_queue);
-		drm_vbl_send_signals(dev);
+		psb_drm_vbl_send_signals(dev);
 	}
 }
 
diff -urNad psb-kernel-source-4.41.2/psb_mmu.c psb-kernel-source-4.41.2.drm_psb/psb_mmu.c
--- psb-kernel-source-4.41.2/psb_mmu.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_mmu.c	2010-05-02 10:13:45.883192724 +0200
@@ -189,7 +189,7 @@
 	uint32_t offset = (hw_context == 0) ? PSB_CR_BIF_DIR_LIST_BASE0 :
 	    PSB_CR_BIF_DIR_LIST_BASE1 + hw_context * 4;
 
-	drm_ttm_cache_flush();
+	psb_drm_ttm_cache_flush();
 	down_write(&pd->driver->sem);
 	psb_iowrite32(pd->driver, (page_to_pfn(pd->p) << PAGE_SHIFT), offset);
 	wmb();
@@ -543,7 +543,7 @@
 		gtt_start += PAGE_SIZE;
 	}
 
-	drm_ttm_cache_flush();
+	psb_drm_ttm_cache_flush();
 	kunmap_atomic(v, KM_USER0);
 	spin_unlock(&driver->lock);
 
@@ -657,7 +657,7 @@
 	unsigned long clflush_mask = pd->driver->clflush_mask;
 
 	if (!pd->driver->has_clflush) {
-		drm_ttm_cache_flush();
+		psb_drm_ttm_cache_flush();
 		return;
 	}
 
@@ -695,7 +695,7 @@
 			       uint32_t num_pages, uint32_t desired_tile_stride,
 			       uint32_t hw_tile_stride)
 {
-	drm_ttm_cache_flush();
+	psb_drm_ttm_cache_flush();
 }
 #endif
 
diff -urNad psb-kernel-source-4.41.2/psb_msvdx.c psb-kernel-source-4.41.2.drm_psb/psb_msvdx.c
--- psb-kernel-source-4.41.2/psb_msvdx.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_msvdx.c	2010-05-02 10:13:44.563191728 +0200
@@ -74,7 +74,7 @@
     }
   list_del (&msvdx_cmd->head);
   kfree (msvdx_cmd->cmd);
-  drm_free (msvdx_cmd, sizeof (struct psb_msvdx_cmd_queue), DRM_MEM_DRIVER);
+  psb_drm_free (msvdx_cmd, sizeof (struct psb_msvdx_cmd_queue), DRM_MEM_DRIVER);
   return ret;
 }
 
@@ -96,7 +96,7 @@
   if (cmd_size + cmd_page_offset > PAGE_SIZE)
     return -EINVAL;
 
-  ret = drm_bo_kmap (cmd_buffer, cmd_offset >> PAGE_SHIFT, 2, &cmd_kmap);
+  ret = psb_drm_bo_kmap (cmd_buffer, cmd_offset >> PAGE_SHIFT, 2, &cmd_kmap);
 
   if (ret)
     {
@@ -156,7 +156,7 @@
     {
       PSB_DEBUG_GENERAL
 	("MSVDXQUE: psb_msvdx_map_command copying command...\n");
-      tmp = drm_calloc (1, cmd_size, DRM_MEM_DRIVER);
+      tmp = psb_drm_calloc (1, cmd_size, DRM_MEM_DRIVER);
       if (tmp == NULL)
 	{
 	  ret = -ENOMEM;
@@ -179,7 +179,7 @@
     }
 
 out:
-  drm_bo_kunmap (&cmd_kmap);
+  psb_drm_bo_kunmap (&cmd_kmap);
 
   return ret;
 }
@@ -250,7 +250,7 @@
       /*queue the command to be sent when the h/w is ready */
       PSB_DEBUG_GENERAL ("MSVDXQUE: queueing sequence:%08x..\n", sequence);
       msvdx_cmd =
-	drm_calloc (1, sizeof (struct psb_msvdx_cmd_queue), DRM_MEM_DRIVER);
+	psb_drm_calloc (1, sizeof (struct psb_msvdx_cmd_queue), DRM_MEM_DRIVER);
       if (msvdx_cmd == NULL)
 	{
 	  mutex_unlock (&dev_priv->msvdx_mutex);
@@ -265,7 +265,7 @@
 	{
 	  mutex_unlock (&dev_priv->msvdx_mutex);
 	  PSB_DEBUG_GENERAL ("MSVDXQUE: Failed to extract cmd...\n");
-	  drm_free (msvdx_cmd, sizeof (struct psb_msvdx_cmd_queue),
+	  psb_drm_free (msvdx_cmd, sizeof (struct psb_msvdx_cmd_queue),
 		    DRM_MEM_DRIVER);
 	  return ret;
 	}
diff -urNad psb-kernel-source-4.41.2/psb_msvdxinit.c psb-kernel-source-4.41.2.drm_psb/psb_msvdxinit.c
--- psb-kernel-source-4.41.2/psb_msvdxinit.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_msvdxinit.c	2010-05-02 10:13:42.751192428 +0200
@@ -408,7 +408,7 @@
 static void
 psb_free_ccb (struct drm_buffer_object **ccb)
 {
-  drm_bo_usage_deref_unlocked (ccb);
+  psb_drm_bo_usage_deref_unlocked (ccb);
   *ccb = NULL;
 }
 
@@ -461,7 +461,7 @@
   struct drm_bo_kmap_obj tmp_kmap;
   int is_iomem;
 
-  ret = drm_buffer_object_create (dev, size,
+  ret = psb_drm_buffer_object_create (dev, size,
 				  drm_bo_type_kernel,
 				  DRM_BO_FLAG_READ |
 				  DRM_PSB_FLAG_MEM_KERNEL |
@@ -474,17 +474,17 @@
       return 1;
     }
 
-  ret = drm_bo_kmap (*ccb, 0, (*ccb)->num_pages, &tmp_kmap);
+  ret = psb_drm_bo_kmap (*ccb, 0, (*ccb)->num_pages, &tmp_kmap);
   if (ret)
     {
-      PSB_DEBUG_GENERAL ("drm_bo_kmap failed ret: %d\n", ret);
-      drm_bo_usage_deref_unlocked (ccb);
+      PSB_DEBUG_GENERAL ("psb_drm_bo_kmap failed ret: %d\n", ret);
+      psb_drm_bo_usage_deref_unlocked (ccb);
       *ccb = NULL;
       return 1;
     }
 
   memset (drm_bmo_virtual (&tmp_kmap, &is_iomem), 0, size);
-  drm_bo_kunmap (&tmp_kmap);
+  psb_drm_bo_kunmap (&tmp_kmap);
 
   *base_addr = (*ccb)->offset;
   return 0;
diff -urNad psb-kernel-source-4.41.2/psb_regman.c psb-kernel-source-4.41.2.drm_psb/psb_regman.c
--- psb-kernel-source-4.41.2/psb_regman.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_regman.c	2010-05-02 10:13:42.331193515 +0200
@@ -99,7 +99,7 @@
 	struct drm_reg *reg;
 	struct psb_use_reg *use_reg;
 
-	ret = drm_regs_alloc(&dev_priv->use_manager,
+	ret = psb_drm_regs_alloc(&dev_priv->use_manager,
 			     (const void *)&use_data,
 			     fence_class,
 			     fence_type, interruptible, no_wait, &reg);
@@ -127,7 +127,7 @@
 	PSB_WSGX32(PSB_ALPL(0, _PSB_CUC_BASE_ADDR),
 		   PSB_CR_USE_CODE_BASE(use_reg->reg_seq));
 
-	drm_free(use_reg, sizeof(*use_reg), DRM_MEM_DRIVER);
+	psb_drm_free(use_reg, sizeof(*use_reg), DRM_MEM_DRIVER);
 }
 
 int psb_init_use_base(struct drm_psb_private *dev_priv,
@@ -139,11 +139,11 @@
 
 	mutex_lock(&dev_priv->cmdbuf_mutex);
 
-	drm_regs_init(&dev_priv->use_manager,
+	psb_drm_regs_init(&dev_priv->use_manager,
 		      &psb_use_reg_reusable, &psb_use_reg_destroy);
 
 	for (i = reg_start; i < reg_start + reg_num; ++i) {
-		use_reg = drm_calloc(1, sizeof(*use_reg), DRM_MEM_DRIVER);
+		use_reg = psb_drm_calloc(1, sizeof(*use_reg), DRM_MEM_DRIVER);
 		if (!use_reg) {
 			ret = -ENOMEM;
 			goto out;
@@ -158,7 +158,7 @@
 			   (use_reg->data_master << _PSB_CUC_BASE_DM_SHIFT),
 			   PSB_CR_USE_CODE_BASE(use_reg->reg_seq));
 
-		drm_regs_add(&dev_priv->use_manager, &use_reg->reg);
+		psb_drm_regs_add(&dev_priv->use_manager, &use_reg->reg);
 	}
       out:
 	mutex_unlock(&dev_priv->cmdbuf_mutex);
@@ -170,6 +170,6 @@
 void psb_takedown_use_base(struct drm_psb_private *dev_priv)
 {
 	mutex_lock(&dev_priv->cmdbuf_mutex);
-	drm_regs_free(&dev_priv->use_manager);
+	psb_drm_regs_free(&dev_priv->use_manager);
 	mutex_unlock(&dev_priv->cmdbuf_mutex);
 }
diff -urNad psb-kernel-source-4.41.2/psb_reset.c psb-kernel-source-4.41.2.drm_psb/psb_reset.c
--- psb-kernel-source-4.41.2/psb_reset.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_reset.c	2010-05-02 10:13:44.883191118 +0200
@@ -192,7 +192,7 @@
 				DRM_FENCE_TYPE_EXE, DRM_CMD_HANG);
 		list_del(list);
 		kfree(msvdx_cmd->cmd);
-		drm_free(msvdx_cmd, sizeof(struct psb_msvdx_cmd_queue),
+		psb_drm_free(msvdx_cmd, sizeof(struct psb_msvdx_cmd_queue),
 			 DRM_MEM_DRIVER);
 	}
 }
diff -urNad psb-kernel-source-4.41.2/psb_scene.c psb-kernel-source-4.41.2.drm_psb/psb_scene.c
--- psb-kernel-source-4.41.2/psb_scene.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_scene.c	2010-05-02 10:13:44.743192879 +0200
@@ -34,7 +34,7 @@
 	void *v;
 
 	for (i = 0; i < scene->clear_num_pages; ++i) {
-		page = drm_ttm_get_page(scene->hw_data->ttm,
+		page = psb_drm_ttm_get_page(scene->hw_data->ttm,
 					scene->clear_p_start + i);
 		if (in_irq())
 			v = kmap_atomic(page, KM_IRQ0);
@@ -56,7 +56,7 @@
 	int is_iomem;
 	void *addr;
 
-	int ret = drm_bo_kmap(scene->hw_data, scene->clear_p_start,
+	int ret = psb_drm_bo_kmap(scene->hw_data, scene->clear_p_start,
 			      scene->clear_num_pages, &bmo);
 
 	PSB_DEBUG_RENDER("Scene clear\n");
@@ -66,7 +66,7 @@
 	addr = drm_bmo_virtual(&bmo, &is_iomem);
 	BUG_ON(is_iomem);
 	memset(addr, 0, scene->clear_num_pages << PAGE_SHIFT);
-	drm_bo_kunmap(&bmo);
+	psb_drm_bo_kunmap(&bmo);
 
 	return 0;
 }
@@ -77,8 +77,8 @@
 		return;
 
 	PSB_DEBUG_RENDER("Scene destroy\n");
-	drm_bo_usage_deref_locked(&scene->hw_data);
-	drm_free(scene, sizeof(*scene), DRM_MEM_DRIVER);
+	psb_drm_bo_usage_deref_locked(&scene->hw_data);
+	psb_drm_free(scene, sizeof(*scene), DRM_MEM_DRIVER);
 }
 
 void psb_scene_unref_devlocked(struct psb_scene **scene)
@@ -112,7 +112,7 @@
 
 	PSB_DEBUG_RENDER("Alloc scene w %u h %u\n", w, h);
 
-	scene = drm_calloc(1, sizeof(*scene), DRM_MEM_DRIVER);
+	scene = psb_drm_calloc(1, sizeof(*scene), DRM_MEM_DRIVER);
 
 	if (!scene) {
 		DRM_ERROR("Out of memory allocating scene object.\n");
@@ -133,7 +133,7 @@
 	if (ret)
 		goto out_err;
 
-	ret = drm_buffer_object_create(dev, bo_size, drm_bo_type_kernel,
+	ret = psb_drm_buffer_object_create(dev, bo_size, drm_bo_type_kernel,
 				       DRM_PSB_FLAG_MEM_MMU |
 				       DRM_BO_FLAG_READ |
 				       DRM_BO_FLAG_CACHED |
@@ -146,7 +146,7 @@
 
 	return scene;
       out_err:
-	drm_free(scene, sizeof(*scene), DRM_MEM_DRIVER);
+	psb_drm_free(scene, sizeof(*scene), DRM_MEM_DRIVER);
 	return NULL;
 }
 
@@ -218,7 +218,7 @@
 		spin_unlock_irqrestore(&scheduler->lock, irq_flags);
 		PSB_DEBUG_RENDER("Waiting to clear scene memory.\n");
 		mutex_lock(&scene->hw_data->mutex);
-		ret = drm_bo_wait(scene->hw_data, 0, 0, 0);
+		ret = psb_drm_bo_wait(scene->hw_data, 0, 0, 0);
 		mutex_unlock(&scene->hw_data->mutex);
 		if (ret)
 			return ret;
@@ -232,15 +232,15 @@
 	}
 	spin_unlock_irqrestore(&scheduler->lock, irq_flags);
 
-	ret = drm_bo_do_validate(scene->hw_data, flags, mask, hint,
+	ret = psb_drm_bo_do_validate(scene->hw_data, flags, mask, hint,
 				 PSB_ENGINE_TA, 0, NULL);
 	if (ret)
 		return ret;
-	ret = drm_bo_do_validate(dev_priv->ta_mem->hw_data, 0, 0, 0,
+	ret = psb_drm_bo_do_validate(dev_priv->ta_mem->hw_data, 0, 0, 0,
 				 PSB_ENGINE_TA, 0, NULL);
 	if (ret)
 		return ret;
-	ret = drm_bo_do_validate(dev_priv->ta_mem->ta_memory, 0, 0, 0,
+	ret = psb_drm_bo_do_validate(dev_priv->ta_mem->ta_memory, 0, 0, 0,
 				 PSB_ENGINE_TA, 0, NULL);
 	if (ret)
 		return ret;
@@ -299,7 +299,7 @@
 		if (pool->scenes[i])
 			psb_scene_unref_devlocked(&pool->scenes[i]);
 	}
-	drm_free(pool, sizeof(*pool), DRM_MEM_DRIVER);
+	psb_drm_free(pool, sizeof(*pool), DRM_MEM_DRIVER);
 }
 
 void psb_scene_pool_unref_devlocked(struct psb_scene_pool **pool)
@@ -341,14 +341,14 @@
 	struct drm_user_object *uo;
 	struct psb_scene_pool *pool;
 
-	uo = drm_lookup_user_object(priv, handle);
+	uo = psb_drm_lookup_user_object(priv, handle);
 	if (!uo || (uo->type != PSB_USER_OBJECT_SCENE_POOL)) {
 		DRM_ERROR("Could not find scene pool object 0x%08x\n", handle);
 		return NULL;
 	}
 
 	if (check_owner && priv != uo->owner) {
-		if (!drm_lookup_ref_object(priv, uo, _DRM_REF_USE))
+		if (!psb_drm_lookup_ref_object(priv, uo, _DRM_REF_USE))
 			return NULL;
 	}
 
@@ -366,7 +366,7 @@
 	int ret;
 
 	PSB_DEBUG_RENDER("Scene pool alloc\n");
-	pool = drm_calloc(1, sizeof(*pool), DRM_MEM_DRIVER);
+	pool = psb_drm_calloc(1, sizeof(*pool), DRM_MEM_DRIVER);
 	if (!pool) {
 		DRM_ERROR("Out of memory allocating scene pool object.\n");
 		return NULL;
@@ -377,7 +377,7 @@
 	pool->num_scenes = num_scenes;
 
 	mutex_lock(&dev->struct_mutex);
-	ret = drm_add_user_object(priv, &pool->user, shareable);
+	ret = psb_drm_add_user_object(priv, &pool->user, shareable);
 	if (ret)
 		goto out_err;
 
@@ -387,7 +387,7 @@
 	mutex_unlock(&dev->struct_mutex);
 	return pool;
       out_err:
-	drm_free(pool, sizeof(*pool), DRM_MEM_DRIVER);
+	psb_drm_free(pool, sizeof(*pool), DRM_MEM_DRIVER);
 	return NULL;
 }
 
@@ -400,9 +400,9 @@
 	if (!ta_mem)
 		return;
 
-	drm_bo_usage_deref_locked(&ta_mem->hw_data);
-	drm_bo_usage_deref_locked(&ta_mem->ta_memory);
-	drm_free(ta_mem, sizeof(*ta_mem), DRM_MEM_DRIVER);
+	psb_drm_bo_usage_deref_locked(&ta_mem->hw_data);
+	psb_drm_bo_usage_deref_locked(&ta_mem->ta_memory);
+	psb_drm_free(ta_mem, sizeof(*ta_mem), DRM_MEM_DRIVER);
 }
 
 void psb_ta_mem_unref_devlocked(struct psb_ta_mem **ta_mem)
@@ -438,7 +438,7 @@
 
 	INIT_LIST_HEAD(&buf.head);
 
-	ta_mem = drm_calloc(1, sizeof(*ta_mem), DRM_MEM_DRIVER);
+	ta_mem = psb_drm_calloc(1, sizeof(*ta_mem), DRM_MEM_DRIVER);
 
 	if (!ta_mem) {
 		DRM_ERROR("Out of memory allocating parameter memory.\n");
@@ -461,7 +461,7 @@
 
 	bo_size = pages * PAGE_SIZE;
 	ta_mem->dev = dev;
-	ret = drm_buffer_object_create(dev, bo_size, drm_bo_type_kernel,
+	ret = psb_drm_buffer_object_create(dev, bo_size, drm_bo_type_kernel,
 				       DRM_PSB_FLAG_MEM_MMU | DRM_BO_FLAG_READ |
 				       DRM_BO_FLAG_WRITE |
 				       PSB_BO_FLAG_SCENE,
@@ -471,7 +471,7 @@
 		goto out_err0;
 
 	ret =
-	    drm_buffer_object_create(dev, pages << PAGE_SHIFT,
+	    psb_drm_buffer_object_create(dev, pages << PAGE_SHIFT,
 				     drm_bo_type_kernel,
 				     DRM_PSB_FLAG_MEM_RASTGEOM |
 				     DRM_BO_FLAG_READ |
@@ -486,9 +486,9 @@
 	ta_mem->ref_count = 1;
 	return ta_mem;
       out_err1:
-	drm_bo_usage_deref_unlocked(&ta_mem->hw_data);
+	psb_drm_bo_usage_deref_unlocked(&ta_mem->hw_data);
       out_err0:
-	drm_free(ta_mem, sizeof(*ta_mem), DRM_MEM_DRIVER);
+	psb_drm_free(ta_mem, sizeof(*ta_mem), DRM_MEM_DRIVER);
 	return NULL;
 }
 
@@ -504,7 +504,7 @@
 	if (!scene->handle_valid)
 		goto out_unlock;
 
-	uo = drm_lookup_user_object(file_priv, scene->handle);
+	uo = psb_drm_lookup_user_object(file_priv, scene->handle);
 	if (!uo) {
 		ret = -EINVAL;
 		goto out_unlock;
@@ -521,9 +521,9 @@
 	}
 
 	scene->handle_valid = 0;
-	ro = drm_lookup_ref_object(file_priv, uo, _DRM_REF_USE);
+	ro = psb_drm_lookup_ref_object(file_priv, uo, _DRM_REF_USE);
 	BUG_ON(!ro);
-	drm_remove_ref_object(file_priv, ro);
+	psb_drm_remove_ref_object(file_priv, ro);
 
       out_unlock:
 	mutex_unlock(&dev->struct_mutex);
diff -urNad psb-kernel-source-4.41.2/psb_schedule.c psb-kernel-source-4.41.2.drm_psb/psb_schedule.c
--- psb-kernel-source-4.41.2/psb_schedule.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_schedule.c	2010-05-02 10:13:44.703191082 +0200
@@ -916,14 +916,14 @@
 			if (task->feedback.bo) {
 				PSB_DEBUG_RENDER("Unref feedback bo %d\n",
 						 task->sequence);
-				drm_bo_usage_deref_locked(&task->feedback.bo);
+				psb_drm_bo_usage_deref_locked(&task->feedback.bo);
 			}
 			mutex_unlock(&dev->struct_mutex);
 		}
 
 		if (atomic_read(&task->buf.done)) {
 			PSB_DEBUG_RENDER("Deleting task %d\n", task->sequence);
-			drm_free(task, sizeof(*task), DRM_MEM_DRIVER);
+			psb_drm_free(task, sizeof(*task), DRM_MEM_DRIVER);
 			task = NULL;
 		}
 		spin_lock_irqsave(&scheduler->lock, irq_flags);
@@ -1167,7 +1167,7 @@
 		return -EINVAL;
 	}
 
-	task = drm_calloc(1, sizeof(*task), DRM_MEM_DRIVER);
+	task = psb_drm_calloc(1, sizeof(*task), DRM_MEM_DRIVER);
 	if (!task)
 		return -ENOMEM;
 
@@ -1222,7 +1222,7 @@
 	*task_p = task;
 	return 0;
       out_err:
-	drm_free(task, sizeof(*task), DRM_MEM_DRIVER);
+	psb_drm_free(task, sizeof(*task), DRM_MEM_DRIVER);
 	*task_p = NULL;
 	return ret;
 }
@@ -1278,7 +1278,7 @@
 	spin_unlock_irq(&scheduler->lock);
 
 	psb_fence_or_sync(priv, PSB_ENGINE_TA, arg, fence_arg, &fence);
-	drm_regs_fence(&dev_priv->use_manager, fence);
+	psb_drm_regs_fence(&dev_priv->use_manager, fence);
 	if (fence) {
 		spin_lock_irq(&scheduler->lock);
 		psb_report_fence(scheduler, PSB_ENGINE_TA, task->sequence, 0, 1);
@@ -1292,14 +1292,14 @@
 
 	if (fence) {
 #ifdef PSB_WAIT_FOR_TA_COMPLETION
-		drm_fence_object_wait(fence, 1, 1, DRM_FENCE_TYPE_EXE |
+		psb_drm_fence_object_wait(fence, 1, 1, DRM_FENCE_TYPE_EXE |
 				      _PSB_FENCE_TYPE_TA_DONE);
 #ifdef PSB_BE_PARANOID
-		drm_fence_object_wait(fence, 1, 1, DRM_FENCE_TYPE_EXE |
+		psb_drm_fence_object_wait(fence, 1, 1, DRM_FENCE_TYPE_EXE |
 				      _PSB_FENCE_TYPE_SCENE_DONE);
 #endif
 #endif
-		drm_fence_usage_deref_unlocked(&fence);
+		psb_drm_fence_usage_deref_unlocked(&fence);
 	}
 	mutex_unlock(&dev_priv->reset_mutex);
 
@@ -1351,7 +1351,7 @@
 	spin_unlock_irq(&scheduler->lock);
 
 	psb_fence_or_sync(priv, PSB_ENGINE_TA, arg, fence_arg, &fence);
-	drm_regs_fence(&dev_priv->use_manager, fence);
+	psb_drm_regs_fence(&dev_priv->use_manager, fence);
 	if (fence) {
 		spin_lock_irq(&scheduler->lock);
 		psb_report_fence(scheduler, PSB_ENGINE_TA, sequence_temp, 0, 1);
@@ -1364,9 +1364,9 @@
 
 	if (fence) {
 #ifdef PSB_WAIT_FOR_RASTER_COMPLETION
-		drm_fence_object_wait(fence, 1, 1, fence->type);
+		psb_drm_fence_object_wait(fence, 1, 1, fence->type);
 #endif
-		drm_fence_usage_deref_unlocked(&fence);
+		psb_drm_fence_usage_deref_unlocked(&fence);
 	}
 
 	mutex_unlock(&dev_priv->reset_mutex);
diff -urNad psb-kernel-source-4.41.2/psb_sgx.c psb-kernel-source-4.41.2.drm_psb/psb_sgx.c
--- psb-kernel-source-4.41.2/psb_sgx.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_sgx.c	2010-05-02 10:13:43.995191879 +0200
@@ -367,7 +367,7 @@
 					   unsigned num_buffers)
 {
 	while (num_buffers--)
-		drm_bo_usage_deref_locked(&((buffers++)->bo));
+		psb_drm_bo_usage_deref_locked(&((buffers++)->bo));
 
 }
 
@@ -446,7 +446,7 @@
 
 		item->ret = 0;
 		item->data = (void *)__user data;
-		ret = drm_bo_handle_validate(file_priv,
+		ret = psb_drm_bo_handle_validate(file_priv,
 					     req->bo_req.handle,
 					     fence_class,
 					     req->bo_req.flags,
@@ -536,8 +536,8 @@
 		psb_2d_lock(dev_priv);
 
 	do {
-		cmd_next = drm_bo_offset_end(cmd_offset, cmd_end);
-		ret = drm_bo_kmap(cmd_buffer, cmd_offset >> PAGE_SHIFT,
+		cmd_next = psb_drm_bo_offset_end(cmd_offset, cmd_end);
+		ret = psb_drm_bo_kmap(cmd_buffer, cmd_offset >> PAGE_SHIFT,
 				  1, &cmd_kmap);
 
 		if (ret)
@@ -564,7 +564,7 @@
 		default:
 			ret = -EINVAL;
 		}
-		drm_bo_kunmap(&cmd_kmap);
+		psb_drm_bo_kunmap(&cmd_kmap);
 		if (ret)
 			break;
 	} while (cmd_offset = cmd_next, cmd_offset != cmd_end);
@@ -578,7 +578,7 @@
 static void psb_clear_dstbuf_cache(struct psb_dstbuf_cache *dst_cache)
 {
 	if (dst_cache->dst_page) {
-		drm_bo_kunmap(&dst_cache->dst_kmap);
+		psb_drm_bo_kunmap(&dst_cache->dst_kmap);
 		dst_cache->dst_page = NULL;
 	}
 	dst_cache->dst_buf = NULL;
@@ -605,14 +605,14 @@
 		return -EINVAL;
 	}
 
-	if (!drm_bo_same_page(dst_cache->dst_offset, dst_offset) ||
+	if (!psb_drm_bo_same_page(dst_cache->dst_offset, dst_offset) ||
 	    NULL == dst_cache->dst_page) {
 		if (NULL != dst_cache->dst_page) {
-			drm_bo_kunmap(&dst_cache->dst_kmap);
+			psb_drm_bo_kunmap(&dst_cache->dst_kmap);
 			dst_cache->dst_page = NULL;
 		}
 
-		ret = drm_bo_kmap(dst_cache->dst_buf, dst_offset >> PAGE_SHIFT,
+		ret = psb_drm_bo_kmap(dst_cache->dst_buf, dst_offset >> PAGE_SHIFT,
 				  1, &dst_cache->dst_kmap);
 		if (ret) {
 			DRM_ERROR("Could not map destination buffer for "
@@ -840,7 +840,7 @@
 	memset(&reloc_kmap, 0, sizeof(reloc_kmap));
 
 	mutex_lock(&dev->struct_mutex);
-	reloc_buffer = drm_lookup_buffer_object(file_priv, reloc_handle, 1);
+	reloc_buffer = psb_drm_lookup_buffer_object(file_priv, reloc_handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 	if (!reloc_buffer)
 		goto out;
@@ -872,7 +872,7 @@
 		goto out;
 	}
 
-	ret = drm_bo_kmap(reloc_buffer, reloc_first_page,
+	ret = psb_drm_bo_kmap(reloc_buffer, reloc_first_page,
 			  reloc_num_pages, &reloc_kmap);
 
 	if (ret) {
@@ -899,7 +899,7 @@
 	}
 
       out1:
-	drm_bo_kunmap(&reloc_kmap);
+	psb_drm_bo_kunmap(&reloc_kmap);
       out:
 	if (registered) {
 		spin_lock(&dev_priv->reloc_lock);
@@ -910,7 +910,7 @@
 
 	psb_clear_dstbuf_cache(&dst_cache);
 	if (reloc_buffer)
-		drm_bo_usage_deref_unlocked(&reloc_buffer);
+		psb_drm_bo_usage_deref_unlocked(&reloc_buffer);
 	return ret;
 }
 
@@ -955,7 +955,7 @@
 
 	mutex_lock(&cmd_buffer->mutex);
 	if (cmd_buffer->fence != NULL)
-		drm_fence_usage_deref_unlocked(&cmd_buffer->fence);
+		psb_drm_fence_usage_deref_unlocked(&cmd_buffer->fence);
 	mutex_unlock(&cmd_buffer->mutex);
 out_unlock:
 	mutex_unlock(&dev_priv->reset_mutex);
@@ -972,7 +972,7 @@
 	int ret;
 	unsigned int i;
 
-	ret = drm_bo_kmap(bo, page_offset, 1, &kmobj);
+	ret = psb_drm_bo_kmap(bo, page_offset, 1, &kmobj);
 	if (ret)
 		return ret;
 
@@ -980,7 +980,7 @@
 	for (i = 0; i < num; ++i)
 		PSB_DEBUG_GENERAL("0x%04x: 0x%08x\n", i, *p++);
 
-	drm_bo_kunmap(&kmobj);
+	psb_drm_bo_kunmap(&kmobj);
 	return 0;
 }
 #endif
@@ -1030,7 +1030,7 @@
 	int ret;
 	struct drm_fence_object *fence;
 
-	ret = drm_fence_buffer_objects(dev, NULL, arg->fence_flags,
+	ret = psb_drm_fence_buffer_objects(dev, NULL, arg->fence_flags,
 				       NULL, &fence);
 
 	if (ret) {
@@ -1053,7 +1053,7 @@
 			fence_arg->error = ret;
 		}
 
-		drm_putback_buffer_objects(dev);
+		psb_drm_putback_buffer_objects(dev);
 		if (fence_p)
 			*fence_p = NULL;
 		return;
@@ -1061,11 +1061,11 @@
 
 	if (!(arg->fence_flags & DRM_FENCE_FLAG_NO_USER)) {
 
-		ret = drm_fence_add_user_object(priv, fence,
+		ret = psb_drm_fence_add_user_object(priv, fence,
 						arg->fence_flags &
 						DRM_FENCE_FLAG_SHAREABLE);
 		if (!ret)
-			drm_fence_fill_arg(fence, fence_arg);
+			psb_drm_fence_fill_arg(fence, fence_arg);
 		else {
 			/*
 			 * Fence user object creation failed.
@@ -1075,8 +1075,8 @@
 			 * to indicate engine "sufficiently" idle.
 			 */
 
-			(void)drm_fence_object_wait(fence, 0, 1, fence->type);
-			drm_fence_usage_deref_unlocked(&fence);
+			(void)psb_drm_fence_object_wait(fence, 0, 1, fence->type);
+			psb_drm_fence_usage_deref_unlocked(&fence);
 			fence_arg->handle = ~0;
 			fence_arg->error = ret;
 		}
@@ -1085,7 +1085,7 @@
 	if (fence_p)
 		*fence_p = fence;
 	else if (fence)
-		drm_fence_usage_deref_unlocked(&fence);
+		psb_drm_fence_usage_deref_unlocked(&fence);
 }
 
 int psb_handle_copyback(struct drm_device *dev,
@@ -1105,8 +1105,8 @@
 	 */
 
 	if (ret) {
-		drm_regs_fence(&dev_priv->use_manager, NULL);
-		drm_putback_buffer_objects(dev);
+		psb_drm_regs_fence(&dev_priv->use_manager, NULL);
+		psb_drm_putback_buffer_objects(dev);
 	}
 
 	if (ret != -EAGAIN) {
@@ -1115,7 +1115,7 @@
 			arg.d.rep.ret = item->ret;
 			bo = item->bo;
 			mutex_lock(&bo->mutex);
-			drm_bo_fill_rep_arg(bo, &arg.d.rep.bo_info);
+			psb_drm_bo_fill_rep_arg(bo, &arg.d.rep.bo_info);
 			mutex_unlock(&bo->mutex);
 			if (copy_to_user(item->data, &arg, sizeof(arg)))
 				err = -EFAULT;
@@ -1148,10 +1148,10 @@
 	if (ret)
 		return ret;
 
-	drm_fence_usage_deref_unlocked(&fence);
+	psb_drm_fence_usage_deref_unlocked(&fence);
 	mutex_lock(&cmd_buffer->mutex);
 	if (cmd_buffer->fence != NULL)
-		drm_fence_usage_deref_unlocked(&cmd_buffer->fence);
+		psb_drm_fence_usage_deref_unlocked(&cmd_buffer->fence);
 	mutex_unlock(&cmd_buffer->mutex);
 	return 0;
 }
@@ -1191,7 +1191,7 @@
 		return -EINVAL;
 	}
 
-	ret = drm_bo_handle_validate(file_priv,
+	ret = psb_drm_bo_handle_validate(file_priv,
 				     handle,
 				     PSB_ENGINE_TA,
 				     DRM_BO_FLAG_MEM_LOCAL |
@@ -1218,7 +1218,7 @@
 		goto out_unref;
 	}
 
-	page = drm_ttm_get_page(bo->ttm, page_no);
+	page = psb_drm_ttm_get_page(bo->ttm, page_no);
 	if (!page) {
 		ret = -ENOMEM;
 		goto out_unref;
@@ -1230,7 +1230,7 @@
 	return 0;
 
       out_unref:
-	drm_bo_usage_deref_unlocked(&bo);
+	psb_drm_bo_usage_deref_unlocked(&bo);
 	return ret;
 }
 
@@ -1255,7 +1255,7 @@
 	if (!dev_priv)
 		return -EINVAL;
 
-	ret = drm_bo_read_lock(&dev->bm.bm_lock, 1);
+	ret = psb_drm_bo_read_lock(&dev->bm.bm_lock, 1);
 	if (ret)
 		return ret;
 
@@ -1263,14 +1263,14 @@
 
 	ret = mutex_lock_interruptible(&dev_priv->cmdbuf_mutex);
 	if (ret) {
-		drm_bo_read_unlock(&dev->bm.bm_lock);
+		psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 		return -EAGAIN;
 	}
 	if (unlikely(dev_priv->buffers == NULL)) {
 		dev_priv->buffers = vmalloc(PSB_NUM_VALIDATE_BUFFERS *
 					    sizeof(*dev_priv->buffers));
 		if (dev_priv->buffers == NULL) {
-			drm_bo_read_unlock(&dev->bm.bm_lock);
+			psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 			return -ENOMEM;
 		}
 	}
@@ -1293,7 +1293,7 @@
 		goto out_err0;
 
 	mutex_lock(&dev->struct_mutex);
-	cmd_buffer = drm_lookup_buffer_object(file_priv, arg->cmdbuf_handle, 1);
+	cmd_buffer = psb_drm_lookup_buffer_object(file_priv, arg->cmdbuf_handle, 1);
 	mutex_unlock(&dev->struct_mutex);
 	if (!cmd_buffer) {
 		ret = -EINVAL;
@@ -1327,7 +1327,7 @@
 		} else {
 			mutex_lock(&dev->struct_mutex);
 			ta_buffer =
-			    drm_lookup_buffer_object(file_priv,
+			    psb_drm_lookup_buffer_object(file_priv,
 						     arg->ta_handle, 1);
 			mutex_unlock(&dev->struct_mutex);
 			if (!ta_buffer) {
@@ -1344,7 +1344,7 @@
 			} else {
 				mutex_lock(&dev->struct_mutex);
 				oom_buffer =
-				    drm_lookup_buffer_object(file_priv,
+				    psb_drm_lookup_buffer_object(file_priv,
 							     arg->oom_handle,
 							     1);
 				mutex_unlock(&dev->struct_mutex);
@@ -1439,16 +1439,16 @@
 	if (pool)
 		psb_scene_pool_unref_devlocked(&pool);
 	if (cmd_buffer)
-		drm_bo_usage_deref_locked(&cmd_buffer);
+		psb_drm_bo_usage_deref_locked(&cmd_buffer);
 	if (ta_buffer)
-		drm_bo_usage_deref_locked(&ta_buffer);
+		psb_drm_bo_usage_deref_locked(&ta_buffer);
 	if (oom_buffer)
-		drm_bo_usage_deref_locked(&oom_buffer);
+		psb_drm_bo_usage_deref_locked(&oom_buffer);
 
 	psb_dereference_buffers_locked(dev_priv->buffers, num_buffers);
 	mutex_unlock(&dev->struct_mutex);
 	mutex_unlock(&dev_priv->cmdbuf_mutex);
 
-	drm_bo_read_unlock(&dev->bm.bm_lock);
+	psb_drm_bo_read_unlock(&dev->bm.bm_lock);
 	return ret;
 }
diff -urNad psb-kernel-source-4.41.2/psb_xhw.c psb-kernel-source-4.41.2.drm_psb/psb_xhw.c
--- psb-kernel-source-4.41.2/psb_xhw.c	2009-04-16 05:25:01.000000000 +0200
+++ psb-kernel-source-4.41.2.drm_psb/psb_xhw.c	2010-05-02 10:13:44.159190940 +0200
@@ -427,13 +427,13 @@
 
 		mutex_lock(&dev->struct_mutex);
 		dev_priv->xhw_bo =
-		    drm_lookup_buffer_object(file_priv, arg->buffer_handle, 1);
+		    psb_drm_lookup_buffer_object(file_priv, arg->buffer_handle, 1);
 		mutex_unlock(&dev->struct_mutex);
 		if (!dev_priv->xhw_bo) {
 			ret = -EINVAL;
 			goto out_err;
 		}
-		ret = drm_bo_kmap(dev_priv->xhw_bo, 0,
+		ret = psb_drm_bo_kmap(dev_priv->xhw_bo, 0,
 				  dev_priv->xhw_bo->num_pages,
 				  &dev_priv->xhw_kmap);
 		if (ret) {
@@ -462,9 +462,9 @@
 	}
       out_err1:
 	dev_priv->xhw = NULL;
-	drm_bo_kunmap(&dev_priv->xhw_kmap);
+	psb_drm_bo_kunmap(&dev_priv->xhw_kmap);
       out_err0:
-	drm_bo_usage_deref_unlocked(&dev_priv->xhw_bo);
+	psb_drm_bo_usage_deref_unlocked(&dev_priv->xhw_bo);
       out_err:
 	atomic_dec(&dev_priv->xhw_client);
 	return ret;
@@ -507,8 +507,8 @@
 		}
 
 		dev_priv->xhw = NULL;
-		drm_bo_kunmap(&dev_priv->xhw_kmap);
-		drm_bo_usage_deref_unlocked(&dev_priv->xhw_bo);
+		psb_drm_bo_kunmap(&dev_priv->xhw_kmap);
+		psb_drm_bo_usage_deref_unlocked(&dev_priv->xhw_bo);
 		dev_priv->xhw_file = NULL;
 	}
 }
